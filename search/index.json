[{"content":"本博客始于 2024 年 7 月，所有日期在其之前的文章均为补档。\nHugo 可能存在一些奇怪的问题，有时候需要 Ctrl+F5 刷新缓存才能看到最新内容。\n本博客中的文章按内容分为以下几类：\n学习 \u0026amp; 技术 算法竞赛 数学 其他科目 教程 理论 \u0026amp; 思想 语言 \u0026amp; 语言学 一些想法 杂记 \u0026amp; 生活 回忆录 随感 收集 \u0026amp; 列表 Minecraft 发现 清单 本博客中的文章按形式分为以下几类：\n学习笔记。我的专业领域内的学习笔记、学习总结或解题报告。包含较多自己对知识的理解与总结，同时有可能是应试内容。 摘抄笔记。我业余做的学习笔记、文章摘抄或教程。专业性和可靠性可能较低，一般可以在网络或书中找到源内容。 想法。我的一些主观想法。 记事。对于曾经或当下发生的事的记叙。 收集。就是杂项，包括例如：自己的 MC 作品、自己的小创意、画廊、书/文章/网址/音乐/电影列表。 每篇文章的副标题会标注最新更新时间（若和第一次发布时间不同）。\n每篇文章的开头会有一个彩色分类卡片，即按上述五种类型分类。卡片内可能会有阅读须知。\n","date":"2024-07-18T00:00:00Z","image":"https://example.com/p/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2/blank_hu4bb27a4dbe5d2db4b54c60dcf774c06a_33772_120x120_fill_box_smart1_3.png","permalink":"https://example.com/p/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2/","title":"关于本博客"},{"content":"$\\gdef\\rank{\\operatorname{rank}}\\gdef\\nul{\\operatorname{Nul}}$\n这是一篇学习笔记。\r书是丘维生的《高等代数（上册）》。由于自己以前学过一些线代，所以这里列出的都是一些细节。\n所有矩阵默认 $n$ 行 $m$ 列，秩为 $r$。\n1.1：这里证明以下最简行阶梯形唯一。第一步是证明主元位置相同。假设 $A$ 化为了 $B=\\begin{bmatrix}\\beta_1\u0026amp;\\cdots\u0026amp;\\beta_n\\end{bmatrix}^\\top$ 与 $C=\\begin{bmatrix}\\gamma_1\u0026amp;\\cdots\u0026amp;\\gamma_n\\end{bmatrix}^\\top$，已知 $\\set{\\beta_i}\\cong\\set{\\gamma_i}$。如果它们在第 $k$ 行第一次出现了主元不同，不妨设 $B$ 的这行主元在前，就会发现 $\\set{\\gamma_i}$ 无法表出 $\\beta_k$，因为 $\\gamma_{1\\sim k-1}$ 的系数必须是 $0$，而 $\\gamma_{k\\sim n}$ 又无能为力。第二步是证明 $\\beta_i=\\gamma_i$，同样是线性表出，其他向量的系数都必须是 $0$。\n另外再证明非主元列是左侧主元列的线性组合。首先阶梯型矩阵中，左侧主元列形成上三角，必满秩，即证。如果要证明原矩阵也符合该性质，只需利用行变换不改变列向量之间关系的性质即可。\n2.4 \u0026amp; 2.6：展开的证明。核心：行列地位相等，$\\tau(p)=\\tau(q)+\\tau(p\u0026rsquo;)$，其中 $\\set{(i,p_i)}=\\set{(q_i,p\u0026rsquo;_i)}$。\n2.4：范德蒙德行列式的证明。要避免 $a_i^k-a_1^k$ 就需要差分，倒过来减。\n2.7.例5：三对角行列式，结论可以记一下。\n2.*：循环矩阵行列式的处理思路。先乘个 $F$，最后可以除掉，或者我的思路是直接单位根反演。另外，计算 $|F|$ 如果只是平方一下，会遇到正负无法确定的问题，处理方法详见 https://zhuanlan.zhihu.com/p/507677010。\n2.5：Cramer 法则。理解：考虑魔改高斯消元的过程：第 $j$ 列当作不存在，$j-1$ 列主元出来了之后直接搞 $j+1$ 列。这样最后一行只有 $a_j$ 和 $b$。这个时候 $|A|$ 就是所有主元再乘上 $a_{n,j}$，$|B_j|$ 就是所有主元乘上 $b_n$，因此除一下就是 $x_j$。\n2.4.例3：加边法。有点神秘。\n2.4.定理4：mark.\n3：线性无关性、极大线性无关组的大小、秩、行列式、线性空间维数（及基大小）、方程解数、可逆性，这么几个角度。\n3.5：行秩等于列秩。无论是行、列秩，行列式，它们的性质都是通过初等变换下的不变性来证的。\n3.7.例3：理解：$k$ 行这个方程没用，$x_l$ 是自由元，取它为 $A_{kl}$，所以它可以移到右边。然后用 Cramer 解。$B_j$ 和 $A_{kj}$ 之间首先差了个负号，然后 $x_l$ 对应列对齐要交换 $|j-l|-1$ 次，还有就是代数余子式的负号。因此\n$$ (-1)^{k+j}B_j=(-1)^{|j-l|}A_{kj}\\\\ \\eta_j=\\frac{B_j}{M_{kl}}A_{kl}=(-1)^{k+l}B_j=(-1)^{k+l+k+j+j+l}A_{kj}=A_{kj} $$ 3.7.习8：他乡遇故知。太逆天了。\n3.9：应用大天地，值得一看。\n4.3：关于 $|A||B|=|AB|$ 的证明思路，一个是分块，一个是拆成初等矩阵（也是相当常见的证明思路，书里没写是因为依赖于 4.4.性质6）。Cauchy-Binet 证明图：\n4.4：证明左逆等于右逆的三个思路。与抽代不同的是这里要给出逆元存在的构造性证明，所以书里是第三种。\n设左逆为 $B$，则 $AB=AIB=ABAB\\Rightarrow I=(AB)^{-1}AB=(AB)^{-1}ABAB=AB$。 设左逆为 $B$，右逆为 $C$，则 $B=BI=BAC=IC=C$。 先证明存在 $B$ 既是左逆也是右逆，再同 2 证没别的逆。 4.4.性质4\u0026amp;例4：mark.\n4.5：分块矩阵初等变换。注意行变换只能左乘（且行列数分别为 to、from 行数），列变换只能右乘（且行列数分别为 from、to 列数），哪怕所有块都是方阵。另外分块初等矩阵只适用于对角是方阵的情况。\n4.9.例17：注意 $A$ 的零空间是与其行空间互为正交补，而不是列空间。因此 $Ax=0$ 的那些 $x$ 并不与 $\\operatorname{Im}\\mathcal{A}$ 垂直，注意几何直观别搞错了。\n5：关于矩阵秩的若干等式、不等式，不是很熟，记一下。\n$\\dim W=m-\\rank(A)$。构造证。\n$\\rank(AB)\\le\\min(\\rank(A),\\rank(B))$。线性表出证。\n$\\rank(A+B),\\rank[A,B]\\le\\rank(A)+\\rank(B)$。线性表出证。\n$\\rank(AA^\\top)=\\rank(A^\\top A)=\\rank(A)$。同解或行列式证（复矩阵不成立）。\n$\\rank(A^m)=\\rank(A^{m+1})\\Rightarrow\\forall k,\\rank(A^m)=\\rank(A^{m+k})$。同解证。\n$\\rank\\begin{bmatrix}A\u0026amp;0\\\\ 0\u0026amp;B\\end{bmatrix}=\\rank(A)+\\rank(B)$、$\\rank\\begin{bmatrix}A\u0026amp;C\\\\ 0\u0026amp;B\\end{bmatrix}\\ge\\rank(A)+\\rank(B)$。线性表出或行列式证。\n$AB=0\\Rightarrow\\rank(A)+\\rank(B)\\le m$。从齐次方程组解角度证。\n$\\rank(AB)\\ge\\rank(A)+\\rank(B)-m$。分块证，也可以用线性变换证。\n左乘列满秩、右乘行满秩，秩不变。同解或用 8 证。\n幂等 $\\Leftrightarrow \\rank(A)+\\rank(I-A)=n$，对合 $\\Leftrightarrow \\rank(I+A)+\\rank(I-A)=n$。分块或 2+3 证。\n补充：我想到 $\\Leftarrow$ 的一个比较妙的证明：$\\rank(A)+\\rank(I-A)=n$，由于 $\\rank+\\dim\\nul=n$，故 $\\dim\\nul A+\\dim\\nul(I-A)=n$，又 $\\nul A\\cap\\nul(I-A)=0$，故 $\\nul A\\times\\nul(I-A)=\\R^n$。于是任意 $x$，$Ax=0$ 或 $x$，于是 $Ax=A^2x\\Rightarrow (A^2-A)x=0$ 对于所有 $x$ 成立，即 $A^2-A=0$。\n$\\rank(A)=r\\Leftrightarrow\\exists B_{n\\times r},C_{r\\times m},\\rank(B)=\\rank(C)=r,A=BC$。分别用相抵、9 或 2+3 证。\n4.6：看着看着发现上三角矩阵的几个性质不是很清楚，记一下。\n上三角矩阵之积还是上三角，上三角矩阵的逆还是上三角。直观或代数证。 上三角矩阵的伴随矩阵还是上三角。 若上三角矩阵 $A$ 满足 $AA^\\top=A^\\top A$，则它为对角矩阵。若 $A$ 是正交矩阵，则 $A$ 的对角全是 $\\pm1$。 LU 分解 LU 分解用于避开逆矩阵求解线性方程组。$L$ 是 $n\\times n$，$U$ 是 $n\\times m$。\n一般的 LU 分解要求可以不用交换行将 $A$ 化简为行阶梯形（注意“各阶顺序主子式非 $0$”仅适用于满秩方阵）。\n求 $L$ 可以理解为：① 对 $L$ 做同样的事情可以变成 $I$；② $L$ 作用于 $U$ 可以变回 $A$（我感觉这种好理解，就是 $L$ 是所有变换顺序倒过来，然后正负互换）。这就是为什么 $L$ 可以由每次行变换乘的系数得出。注意就算目前行对应（下一个主元）位置为 $0$ 也不一定会出事，如果该列下面全 $0$，那就直接往后找。同时允许 $U$ 最后几行全零。\n出现主元问题时用 LUP 分解。通过 $PA=LU$（直接在 $A$ 中剩余行中对换，作用效果与 $U$ 中对换相同，又不会破坏 $L$ 的下三角性质），可以避免一堆奇怪的讨论。看一个例子（注意，当交换两行时，$L$ 中对应行除对角 $1$ 外也要交换）：\n$P$ $L$ $U$ $\\begin{bmatrix}1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;0\u0026amp;1\\end{bmatrix}$ $\\begin{bmatrix}1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;0\u0026amp;1\\end{bmatrix}$ $\\begin{bmatrix}0\u0026amp;2\u0026amp;1\u0026amp;0\\\\ 4\u0026amp;2\u0026amp;13\u0026amp;2\\\\ 2\u0026amp;2\u0026amp;7\u0026amp;1\\\\ 2\u0026amp;3\u0026amp;7.5\u0026amp;.5\\end{bmatrix}$ $\\begin{bmatrix}0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;0\u0026amp;1\\end{bmatrix}$ $\\begin{bmatrix}1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;0\u0026amp;1\\end{bmatrix}$ $\\begin{bmatrix}4\u0026amp;2\u0026amp;13\u0026amp;2\\\\ 0\u0026amp;2\u0026amp;1\u0026amp;0\\\\ 2\u0026amp;2\u0026amp;7\u0026amp;1\\\\ 2\u0026amp;3\u0026amp;7.5\u0026amp;.5\\end{bmatrix}$ $\\begin{bmatrix}0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;0\u0026amp;1\\end{bmatrix}$ $\\begin{bmatrix}1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ .5\u0026amp;0\u0026amp;1\u0026amp;0\\\\ .5\u0026amp;0\u0026amp;0\u0026amp;1\\end{bmatrix}$ $\\begin{bmatrix}4\u0026amp;2\u0026amp;13\u0026amp;2\\\\ 0\u0026amp;2\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;.5\u0026amp;0\\\\ 0\u0026amp;2\u0026amp;1\u0026amp;-.5\\end{bmatrix}$ $\\begin{bmatrix}0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;0\u0026amp;1\\end{bmatrix}$ $\\begin{bmatrix}1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ .5\u0026amp;.5\u0026amp;1\u0026amp;0\\\\ .5\u0026amp;1\u0026amp;0\u0026amp;1\\end{bmatrix}$ $\\begin{bmatrix}4\u0026amp;2\u0026amp;13\u0026amp;2\\\\ 0\u0026amp;2\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;0\u0026amp;-.5\\end{bmatrix}$ $\\begin{bmatrix}0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\\end{bmatrix}$ $\\begin{bmatrix}1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ .5\u0026amp;1\u0026amp;1\u0026amp;0\\\\ .5\u0026amp;.5\u0026amp;0\u0026amp;1\\end{bmatrix}$ $\\begin{bmatrix}4\u0026amp;2\u0026amp;13\u0026amp;2\\\\ 0\u0026amp;2\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;0\u0026amp;-.5\\\\ 0\u0026amp;0\u0026amp;0\u0026amp;0\\end{bmatrix}$ 在解具体方程时，只需解 $Ly=Pb$ 与 $Ux=y$ 即可。注意不要搞错成 $P^{-1}b$。\nLDU 分解只是对满秩方阵而言，就是简单地把 $U$ 的对角元变成 $1$。\n正交相关 根据点乘的几何意义，可得在单个向量上的投影。\n一般的正交投影，我们从两个角度理解。\n代数角度：希望写成 $y=\\hat y+z$ 的形式，其中 $\\hat y=\\sum c_iu_i$，$z\\cdot u_i=0$。后一个式子可以写成 $$ 0=(y-\\hat y)\\cdot u_i=(y-\\sum c_iu_i)\\cdot u_i=y\\cdot u_i-c_iu_i^2\\Rightarrow c_i=\\frac{y\\cdot u_i}{u_i\\cdot u_i} $$ 几何角度就是若干个“分量投影”的和。\n而最佳逼近定理就是由 $z\\perp W$ 加上勾股定理，勾股定理的本质就是正交向量的点积为 $0$。正交相关的一切内容都是围绕这一性质展开的。\n如果 $y\\in W$，那正交投影的公式就给出的线性表出的构造。\n注意如果不是正交方阵，而是若干正交单位向量组成的矩阵 $U=\\begin{bmatrix}u_1\u0026amp;\\cdots\u0026amp;u_n\\end{bmatrix}$，那么 $U^\\top U=I$，但 $UU^\\top\\ne I$——而且 $UU^\\top y$ 给出了 $y$ 在 $W$ 上的投影。\nQR 分解 QR 分解就是用矩阵表示出了 Gram-Schmidt 正交化的过程。\n使用条件：$A$ 列向量线性无关。\n推导很简单，就是记住是正交矩阵在左即可。 $$ \\begin{bmatrix}\\alpha_1\u0026amp;\\cdots\u0026amp;\\alpha_m\\end{bmatrix}=\\begin{bmatrix}u_1\u0026amp;\\cdots\u0026amp;u_m\\end{bmatrix}\\begin{bmatrix}\\alpha_1\\cdot u_1\u0026amp;\\alpha_2\\cdot u_1\u0026amp;\\cdots\u0026amp;\\alpha_m\\cdot u_1\\\\ 0\u0026amp;\\alpha_2\\cdot u_2\u0026amp;\\cdots\u0026amp;\\alpha_m\\cdot u_2\\\\ \\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\ 0\u0026amp;0\u0026amp;\\cdots\u0026amp;\\alpha_m\\cdot u_m\\end{bmatrix} $$ 这里对矩阵作了一点简化，其思路是 $$ \\alpha_i=\\sum_{j\\le i}\\frac{\\alpha_i\\cdot v_j}{v_j\\cdot v_j}v_j=\\sum_{j\\le i}\\frac{\\alpha_i\\cdot(|v_j|u_j)}{|v_j|^2}(|v_j|u_j)=\\sum_{j\\le i}(\\alpha_i\\cdot u_j)u_j $$ 如果觉得别扭也可以把 $v_i$ 拿出来单独讨论。\n实操方法 1：在 Gram-Schmidt 正交化的时候写清楚那个下三角形的公式，写成矩阵，最后第 $i$ 行乘 $|v_i|$ 即可。\n实操方法 2：直接求出单位正交基 $Q$，然后由 $Q^\\top A=R$ 算出 $R$。\n唯一性见 4.6.例5。\n最小二乘法 理解角度 1：在不求出正交基的情况下求投影，即利用垂直的性质。$\\alpha_i\\cdot(Ax-b)=0$。\n理解角度 2：要最小化 $|Ax-b|$，也就是最小化 $(Ax-b)\\cdot(Ax-b)$。 $$ 0=\\frac{\\partial(\\sum\\alpha_jx_j-b)^2}{\\partial x_i}=2\\sum \\alpha_i\\cdot\\alpha_jx_j-2\\alpha_i\\cdot b $$ 这里 $\\sum \\alpha_jx_j=Ax$，于是式子就变成 $A^\\top Ax=A^\\top b$。\n从代数角度证明必有解：一方面，$[A^\\top A,A^\\top b]$ 的列向量都是 $A^\\top$ 之列向量的线性组合，故秩不超过 $\\rank(A)$。另一方面 $\\rank(A^\\top A)=\\rank(A)$。\n当 $A$ 列满秩时，$A^\\top A$ 满秩，即有唯一解。\n另外，如果想把 $A$ 正交分解了再 $b$ 去投影，也没问题。设 $A=QR$，$b$ 的正交投影为 $QQ^\\top b$。如果要转成用 $A$ 列向量的线性组合来表示，那就是 $Ax=QQ^\\top b\\Rightarrow QRx=QQ^\\top b\\Rightarrow Rx=Q^\\top b\\Rightarrow x=R^{-1}Q^\\top b$（其实都是 $\\Leftrightarrow$）\n应用理解：有若干样本点 $(a_i,b_i)$，考虑用一个函数 $y=\\sum c_if_i(x)$ 去拟合（$c_i$ 未知，$f_i$ 已知。例如直线就取 $f_1(x)=1,f_2(x)=x$），误差就是 $y$ 与对应 $b_i$ 的差的平方和。那这时其实就是求以下方程的最小二乘解： $$ \\begin{bmatrix}f_1(a_1)\u0026amp;\\cdots\u0026amp;f_m(a_1)\\\\ \\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\ f_1(a_n)\u0026amp;\\cdots\u0026amp;f_m(a_n)\\end{bmatrix}\\begin{bmatrix}c_1\\\\ \\vdots\\\\ c_m\\end{bmatrix}=\\begin{bmatrix}b_1\\\\ \\vdots\\\\ b_n\\end{bmatrix} $$ 这里的函数可以是多自变量函数。\n矩阵的相抵与相似 相抵矩阵秩相同。将矩阵转换成相抵标准型的过程，类比将满秩方阵拆分成初等矩阵的过程。其最大作用就是拆矩阵简化证明。非满秩的矩阵在推式子时会出现类似“丢失信息”的现象。\n广义逆矩阵是不易直观理解的部分，几个性质的证明动机也不清晰，我只能记下书里基础的东西，其实都是些废话：\n处理广义逆矩阵相关问题的基本方式是将 $A$ 写成 $PIQ$。 广义逆矩阵的阶为 $m\\times n$。形式为 $A^-=Q^{-1}\\begin{bmatrix}I_r\u0026amp;B\\\\ C\u0026amp;D\\end{bmatrix}P^{-1}$。$Q$ 为 $m\\times m$，$P$ 为 $n\\times n$，中间为 $m\\times n$。 $Ax=b$ 有解当且仅当 $b=AA^-b$。直接用定义+后面的构造证。解为所有 $A^-b$。证明所有解都可以表示为这种形式的方式的思路是，先把 $A$ 拆开，然后 $P,Q$ 就出来了，分析一下构造 $B,C,D$ 即可（这里 $b\\ne 0$，不然构造会找不到非 $0$ 元）。 $Ax=0$ 的解为 $(I_m-A^-A)\\gamma$（$A^-$ 随便固定一个，$\\gamma$ 取所有）。一个解直接对应 $\\gamma=x$。 后面 $A^+$ 我直接投降。其应用就是，$A$ 列满秩时，$Ax=b$ 的最小二乘解就是 $A^+b$。另外，列满秩矩阵满足 $A^-A=I$，其中一个特殊的 $A^-$ 是 $(A^\\top A)^{-1}A^\\top$；行满秩矩阵满足 $AA^-=I$，其中一个特殊的 $A^-$ 是 $A^\\top(AA^\\top)^{-1}$。无论是否列/行满秩，$A^-$ 都不是唯一的，只有满秩方阵才有 $A^-=A^{-1}$。 矩阵的相似可以从线性变换的角度来理解。想象一个线性变换，它将自然基下的向量 $x$ 映射到 $Ax$。现在我们想知道，在另一个基下这样的变换该如何描述。假设另一个基为 $P$（$P$ 的列向量为所有基向量），根据基变换相关的内容我们知道：在这个基的表示下的向量 $x$，在自然基下的表示为 $Px$；反之在自然基表示下的向量 $x$，在这个基的表示为 $P^{-1}x$（空间和向量永远不动，只是表出会变）。\n对于这个基下的向量 $x$，先将它用自然基表出，然后 $A$ 作用，再变回去。这就是 $P^{-1}APx$。$B=P^{-1}AP$ 就是在这个基下的变换矩阵。正如 3b1b 所说，基变换和相似就是一个“语言翻译”的过程。\n所以说，两个矩阵相似，就说明可以通过选取合适的基，使它们对应的线性变换看起来相同。这里我们可以联系抽代里半直积本质相同的判别方式（第 12 章性质 2）来理解——如果自同构是共轭的，就说明可以选取不同的元素作为生成元，使得这两个自同构分别在两种生成元下形式完全相同，那就说明这两个半直积同构。\n对角化的几何解释见 https://www.bilibili.com/video/BV1TH4y1L7PV/。简而言之就是把基变成那些特征向量，然后线性变换就变成简单的各维分别缩放了。这其实让我想到了卷积定理。\n关于特征值和特征向量。首先要明确，相似变换下，行列式、秩、迹、特征值都不变，但特征向量会变。\n无论是否满秩，特征值数量（算上重数）总为 $n$，但特征子空间的维数和就不一定了。如果满秩，则特征值全部非零，但是不满秩时，特征值 $0$ 的重数并不等于 $n-r$，而是大于等于，例如 $\\begin{bmatrix}0\u0026amp;1\\\\ 0\u0026amp;0\\end{bmatrix}$。相关证明见 https://www.zhihu.com/question/297458474/answer/1362625976。\n几何重数小于等于代数重数的证明直观是很好理解的，你都构造出那几个线性无关的特征向量了，那不得至少有这几个嘛。证明的思路就是基变换，把这几个特征向量作为基，别的任选，然后 $|\\lambda I-A\u0026rsquo;|=0$ 就行。\n不同特征值对应的特征向量不同，这个只需看一个简单情况就可以理解证明思路：如果 $A\\alpha_1=\\lambda_1\\alpha_1,A\\alpha_2=\\lambda_2\\alpha_2,c\\alpha_1=\\alpha_2$，那么 $\\lambda_1c\\alpha_1=Ac\\alpha_1=A\\alpha_2=\\lambda_2\\alpha_2=\\lambda_2c\\alpha_1\\Rightarrow\\lambda_1=\\lambda_2$。后面的东西都是比较显然的。\n一些特殊矩阵的特征值。幂等矩阵有 $\\rank(A)$ 重特征值 $1$，$n-\\rank(A)$ 重特征值 $0$。证明这个的步骤是，首先说明特征值只能是 $0$ 或 $1$，然后利用几何重数说明代数重数。对合矩阵也是类似。幂零矩阵与它们的不同点仅在于不能对角化。注意不能从特征值判断特殊矩阵。注意可对角化和满秩之间没有关系。\n现在距离抽代里那个自同构的分析，我们还有两个障碍：一个是 Jordan 标准型还没学，一个是不允许复数。\n简单提一下 Cayley-Hamilton 定理的证明：对角阵易证，因为相当于每个特征值代进特征多项式。从而可对角化的情况易证，因为 $f(P^{-1}AP)=P^{-1}f(A)P$，然后可以用 https://www.zhihu.com/question/31557902/answer/1636767376 这种来理解。另一个证明思路是，先通过证明乘每个 $\\varepsilon_i$ 均为 $0$ 来证明上三角矩阵满足，然后再把任意一个矩阵相似化为上三角：https://zhuanlan.zhihu.com/p/657653840。最后，书里的证明思路是，通过比对 $(\\lambda I-A)(\\lambda I-A)^\\star=|\\lambda I-A|I$ 两侧的系数证明。\n它的一个重要作用是给出了 $A^n$ 关于 $A^{0\\sim n-1}$ 的表达式，从而可以递推（P4723）。\n","date":"2024-07-26T00:00:00Z","image":"https://example.com/study/linear-algebra-1/cover_hue7cd3938229afdc9daa7bec754b92a4f_157916_120x120_fill_box_smart1_3.png","permalink":"https://example.com/study/linear-algebra-1/","title":"线代（上）自学笔记"},{"content":"这是一篇摘抄笔记。\n本文适合不了解 html 和 scc 但想自己建博客的读者看。\r本地初始操作 下载 git，更新用户名和邮箱信息。 下载 hugo，选 extended。 建文件夹，里面存所有网站的文件夹。 hugo new site 名字，会出现一个子文件夹（下称为主文件夹），对应一个网站。 进入，找想要的主题，通过 git clone 或直接复制粘贴的方式放到 themes 文件夹中，最好只有一个主题（实际是可以在配置的 theme 改），然后主题的文件夹名别动。 把主题对应的 exampleSite 内文件复制到主文件夹。 hugo 可以编译（生成 public/ 内的网页文件），hugo server 在 hugo 的基础上开了个 localhost 网页以供实时预览，每次运行即可查看效果，随时改（保存）随时更新，不需要“编译”。Ctrl+C 停止。注意，有的时候改风格或页面布局时出现语法问题，就算改回来也会没反应（停留在一个编译错误页面或没有改动效果），这时应当停止再运行。 主题相关（stack） 如果遇到其他主题需求，一个通用方法是，如果想改某些样式或大小或长宽，则找 assets 里 scss 文件；如果想改页面布局，则找 layouts 里 html 文件。具体可以按文件名实际意思找，也可以 F12 出调试工具后找对应的项名字或数值，然后用查找文件内容在主题文件夹里直接暴力找。\n注意主题对浏览器页面不同大小的时候做了适配，所以会发现有 respond(…) 这种东西，阈值参见 breakpoint.scss。一般建议改参数（某些距离之类）的时候，顺带各种尺寸情况都改了，然后最后拿手机、平板之类的访问一下看看是否合适。\n配置文件应当放在主文件夹中，名字为 hugo.*，后缀可以是 yaml，toml 或 json。建议直接按上面第 6 点，把 exampleSite 的配置文件复制过来，删掉原来的 hugo.toml。下文简称该文件为“配置”。\n多语言选项直接关了完事，配置里 DefaultContentLanguage 改 zh-cn，hasCJKLanguage 改 false，language 删了。\n网站图标：配置里 params.favicon。.ico 文件放到 static/ 里。\n头像放 assets/img/。\n左右边栏最大宽度：grid.css 里 .container\u0026amp;.extended 的 respond(xl) 内。会相应改变中间主题的宽度。\n左右边栏与页面左右边缘距离：grid.css 里 .main-container 的 respond(md) 内。\n头像大小，头像、博客标题、博客描述居中：sidebar.scss 里 .left-sidebar 的 \u0026ndash;sidebar-avatar-size，.sidebar header 的 .site-avatar（其实不改就行）、.site-name、.site-description 内加 text-align: center;。\n左右边栏额外两侧空白：sidebar.scss 里 .left-sidebar、.right-sidebar 内额外加 padding-left: ?px; 和 padding-right: ?px; 即可。\n左右边栏和中间主体的间距：variables.scss 里 :root 的 \u0026ndash;section-separation。\n所以，如果你想真的让左边栏内容完美居中，所要做的就是：把 4 和 7 调成相等，6 的 left、right 不要不相等。\n左侧边栏之页面 second method 的高亮：主题文件夹/layouts/partials/sidebar/left.html 里找到这段：\n{{ $currentPage := . }} {{ range .Site.Menus.main }} {{ $active := or (eq $currentPage.Title .Name) (or ($currentPage.HasMenuCurrent \u0026#34;main\u0026#34; .) ($currentPage.IsMenuCurrent \u0026#34;main\u0026#34; .)) }} 删掉改成：\n{{ $currentPage := . }} {{ $siteTitle := .Site.Title }} {{ range .Site.Menus.main }} {{ $active := or (eq $currentPage.Title .Name) (or ($currentPage.HasMenuCurrent \u0026#34;main\u0026#34; .) ($currentPage.IsMenuCurrent \u0026#34;main\u0026#34; .)) }} {{ $active := or ($active) (and (eq $currentPage.Title $siteTitle ) (eq .Identifier \u0026#34;home\u0026#34;)) }} 目录的行间距：layout/article.scss 里 .widget\u0026ndash;toc#TableOfContents 里面有个 margin 后面带四个数的，分别是上边缘、右边缘、每行下方、左边缘。\n左侧边栏图标与文字的距离：variables.scss 里 :root 的 \u0026ndash;menu-icon-separation。\n最后修改时间：https://shitao5.org/posts/hugo-stack/\nbranch 页面的标题形式：在 layout/_default/list.html 里，我是直接把 section-title 注释掉的（因为无论如何它都只会显示章节两字），希望这个自定义的话我也不大会，但是网上好像可以查到？https://discourse.gohugo.io/t/how-can-i-get-a-user-friendly-section-name-title/10880/3\n段内行距：variables.scss 里 :root 的 \u0026ndash;article-line-height。段间行距：layout/article.scss 里 .article-content 里有个 margin: 1.5em 0;\n关于段首缩进：爆了，下面这个方法会导致列表的编号和内容间有过大的距离，应该无解。\n在 layout/article.scss 里 .article-content 里加一句 text-indent: 2em; 这样会发现它缩进过度了。在 variables.scss 里改 \u0026ndash;card-padding。\n这里有两个注意点，一个是你发现 F12 之后两侧 padding 变了，这个在不是 layout 里的 article.scss 里 .article-list\u0026ndash;tile 的 .article-details 的 padding 改。\n一个是注意到包括标题、图片在内的东西都会被缩进，标题我觉得这样挺好看的，图片的话会导致右侧被遮，这里我的解决方法是用 html 格式的图片，还可以调大小，更好用，唯一可惜的是用不上 stack 自带的图片文字描述下方显示，不过这个也可以写一段 html。\n大标题大小：不是 layout 里的 article.scss 里 .article-title 的 font-size。\nF12 时头像不居中问题：sidebar.scss 里 .sidebar header 的 .site-avatar 的 margin 改成 auto（注意这类 margin 的东西如果不填 0 或 auto，则必须填四个数，分别代表上右下左）。\n网站名称颜色：光把 sidebar.scss 里 .site-name 的 color 改掉没用，还要把 left.html 里 site-name 的链接去掉。\n文章主题图片的高度：layout/article.scss 里 .article-page 的 .article-header 的 .article-image 的 img 的 max-height。\n回到顶部：https://www.blain.top/p/renovation/#%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE 配合 https://yelleis.top/p/61fdb627/#%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8。可以平滑的。\n左边栏项过多但不想滚轮：sidebar.scss 里 .left-sidebar 的 max-height。左边栏各项间距：menu.scss 里 #main-menu 的 gap。\n归档里 CATEGORIES 不是中文：archives.html 里改 \u0026lt;h2 class=\u0026quot;section-title\u0026quot;\u0026gt;{{ $taxonomy.Title }}\u0026lt;/h2\u0026gt;。\n归档的分类卡片大小：list.scss 里 .subsection-list 的 .article-list\u0026ndash;tile 的 article 的 width、height。\n文章先后（默认按时间）、左侧栏、归档分类等都可以用 md 开头 yaml 里 weight 调优先级。\n左侧栏“个性签名”换行：不知为何 \\n 会被空格代替，\u0026lt;br/\u0026gt; 没用。我找遍了整个 theme 文件夹只找到一处把换行替换为空格的代码，去掉之后还是没用。所以只能在 left.html 里硬编码了。\n归档分类卡片渐变颜色：main.ts 里 articleDetails.style.background。我觉得不改也挺好看。\n归档多栏：https://blog.grew.cc/posts/stack.html#%E5%BD%92%E6%A1%A3%E9%A1%B5%E5%8F%8C%E6%A0%8F。\n图标可以在 https://tablericons.com/ 找，放在主题的 assets/icons 里。\n关闭 toc 的编号：layout/article.scss 里 li a:first-of-type::before 部分注释掉。\n代码行号：配置里 markup:highlight:lineNos。\n“评论”标题：在 layouts/partials/comments/include.html 的第一二行间加 \u0026lt;h2 style=\u0026quot;color: var(--card-text-color-main)\u0026quot;\u0026gt;评论\u0026lt;/h2\u0026gt;。这样暗色模式不会还是黑的。\ncontent 目录结构 博客里的页面分为 branch 和 leaf 两类，branch 就是下面还有子页面的页面。\ncontent 文件夹对应 home 页面，是 branch 类型。home 就是主页。\ncontent 的文件夹结构与网站链接结构完全对应，一个文件夹一个页面，branch 对应的文件夹下如果有其他 md 或含 index.md 的子文件夹，就会在对应页面也显示出来。\ncontent 内所有想要能显示出来的页面，必须要包含 index.md 或 _index.md 文件，前者是给 leaf 用的，后者是给 branch 用的。这个 md 的开头应当有一段 yaml（或其他格式）给出其相关信息。对于 branch，就不用写别的东西了（写了也没用）；对于 leaf，yaml 之后就是正文。\n实际上 leaf 页面可以在 post 或对应的 branch 文件夹里直接放 md，但是最好还是按照上面的习惯来。\n这样的一段 yaml 应当符合 https://stack.jimmycai.com/writing/frontmatter 的格式（有漏，可以看 https://zhuanlan.zhihu.com/p/688275787 里“我的模板”，注意冒号之后必须加空格！复杂字符串如果出问题需要两边打引号！）。特殊地，有几类特殊的布局，可以加上 layout 信息，参见 exampleSite 的 page/。\n建议建文件夹 content/page/ 以存放所有出现在左边栏内的页面。所有希望出现在左边栏中的页面（包括 home 的 _index.md 以及 page 的 index.md），它们开头的 yaml 需要额外以 https://stack.jimmycai.com/config/menu 里 first method 的方法写一下。second method 是直接写在配置里的，配合上面第 10 点。\n主页的中间，会显示所有属于 content/post/ 里的内容——这是由配置里 params.mainSection 决定的。\n除了按上述方式配置的 content/_index.md、post（mainSection 的条目）、page 内 md 外，其余东西一律没有导航界面（包括别的 branch），只能在浏览器上改链接来访问，因此其实可以在博客里“藏”东西。\n然后还有一个特殊的文件夹 content/categories，这里面放的东西会和每个文章的分类联系在一起，参见 exampleSite。如果不用这个文件夹，直接写每篇文章的 categories 也是没问题的，就是归档里会没图片。如果用这个文件夹，可以设置 categories 的标签颜色、图片等，而且可以将一个类别的 id 和名称分开来，文件夹名、slug、调用时用 id，title 写名称。\nMarkdown、KaTeX 相关 这部分很重要，请务必注意！\r无论如何要当心任何位置出现的特殊字符，尤其是 Typora 里没出问题的 \\。\n支持内嵌 html。 同普通 Markdown，如果两段间不留空行且第一段末尾没有俩空格，则渲染出来是不换行的。 关于列表的分段，Typora 是显示出来一律是分段的行距，但对于从未在标号（或项目点）前退格的列表，源码会不留空行，在网页里是不分段的行距（对比本列表和上一个列表）。这个可能会有点难看，如果介意的话，要手动改一下。另外列表内分段是按照缩进来的。 公式支持 KaTeX 功能（如果没渲染检查一下配置和 frontmatter 里有没有开 math），行间公式上下不留空行也没事。 如果要利用全局 \\def，必须使用 \\gdef。这个和 Typora 是不一样的，Typora 不识别 \\gdef 但 \\def 是全局的。 矩阵等多行的东西，需要打三个 \\ 后再来个空格，以换行。这个很奇怪。 \\,、\\; 之类的小空格必须改成 \\\\,、\\\\;。这个也很奇怪。 表格里公式偷懒不用 \\lvert\\rvert 直接打 | 时会出现与表格边界混淆的情况（Typora 会自动正确处理），这时要加转义 \\。 公式内星号 * 要加转义 \\（Typora 会自动正确处理）。 还有很多不加 \\ 就会爆的情况。我遇到最诡异的是 ${a}_{b}{c}_{d}$ 无法渲染。这种是因为垃圾 Markdown 渲染器把公式内外搞混了（两个下划线之间被识别为斜体）。遇到这种情况反正就在各个特殊字符前试着加 \\ 就行。 连接自动识别在遇到标点时会有问题，建议还是用 \u0026lt;\u0026gt; 括起来。 撇号如果直接用 ' 会很丑（$\u0026rsquo;$），必须用 ^\\prime。 html 格式的图片要居中必须单独写 center。 如果希望强制调整表格列宽，可以用 \u0026lt;div style=\u0026quot;width: 宽度\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;。注意其副作用是在不同宽度的屏幕上可能会显示得不好看。 Github 部署 Github 部署的思路如下：\nGithub 上一个公开的 repo 放网页文件。 每次 hugo 完，把 public/ 内东西放到 repo 里。 如果不想手动操作，可以再建一个（可以私有）放整个博客的 repo，每次 push 之后用 github action 自动编译、更新到网页 repo 里。 由于我想经常调试博客的 theme，而且第三步略麻烦，所以我就是手动更新。\n总的操作方法见 https://zhuanlan.zhihu.com/p/568470172（有三篇）。\n注意：\n网址只能是 github用户id.github.io，github settings pages 里改域名的选项是得自己先买域名的。 hugo 编译后，public 里老的文件是会留着的（例如你反复给一篇文章换主题图片，它都会留着）。如果你不希望别人来翻你的 github repo 看到这些，得每次手动删除。 每次把网页复制到本地仓库前，最好先删光（别手动删！git 会自动追踪仓库里的文件，可能会出问题。具体处理方法见下文）。 评论 disqus 有广告。 giscus 必须登录 github 才能评论。 twikoo 似乎有审查。 cusdis 万岁！\n免费版 cusdis 一个月 10 条无需 approve 和 100 条需要 approve 的评论（大概就是你得在邮箱的评论通知里点一下），完全够。\n操作非常简单：\n注册个账号。输入博客网址与 notification 邮箱。 配置里 params 的 comments 的 provider 改成 cusdis，下面 cusdis 里 host 和 id 改一下，具体改的内容看 cusdis 里你的 dashboard 上方的 Embeded Code。 如果想改中文，在 layout/partial/comments/provider/cusdis.html 里 \u0026lt;script async defer src=\u0026quot;{{ $host }}/js/cusdis.es.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 的上面加一句 \u0026lt;script async defer src=\u0026quot;https://cusdis.com/js/widget/lang/zh-cn.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;。 日常维护 我一般习惯这样：\n在另外的文件夹里写博客。\n每次手动新建文章文件夹，md 复制过去改名成 index.md，开头加上那段 yaml（我不习惯 hugo new）。yaml 我用的模板：\ntitle: description: date: slug: image: categories: toc: true math: true comments: true 更新到 github。我写了以下脚本（须在 git bash 下运行，我的博客文件夹和 repo 文件夹并列）：\ncd blog/ rm public/* -r hugo cd ../LittleReuben.github.io/ git rm * -r cd ../ cp -rf blog/public/* LittleReuben.github.io/ cd LittleReuben.github.io/ git add --all git commit -m \u0026#34;upd\u0026#34; git push -u origin main 注意博客网页更新较慢，大概要等个 2min。\n如果想搭博客也可以直接问我要魔改的 theme。\n参考链接 https://thirdshire.com/hugo-stack-renovation-part-two/\nhttps://xrg.fj.cn/p/hugo-stack%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/\nhttps://munlelee.github.io/post/hugo%E5%8D%9A%E5%AE%A2-stack%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%80%E7%AB%99/\nhttps://zhixuan2333.github.io/posts/ac760353/\nhttps://blog.linsnow.cn/p/modify-hugo/\nhttps://zhuanlan.zhihu.com/p/685991593\nhttps://yelleis.top/p/61fdb627/\n","date":"2024-07-25T00:00:00Z","image":"https://example.com/study/blog-tutorial/logo_hu9066f490e545adcdd047e137df4b7da5_88363_120x120_fill_box_smart1_3.png","permalink":"https://example.com/study/blog-tutorial/","title":"Hugo 博客搭建经验"},{"content":"$\\gdef\\lcm{\\operatorname{lcm}}\\gdef\\ker{\\operatorname{Ker}}\\gdef\\im{\\operatorname{Im}}\\gdef\\syl{\\operatorname{Syl}}\\gdef\\or{\\operatorname{or}}\\gdef\\aut{\\operatorname{Aut}}\\gdef\\norm{\\vartriangleleft}\\gdef\\inn{\\operatorname{Inn}}\\gdef\\out{\\operatorname{Out}}\\gdef\\F{\\mathbb{F}}$\n这是一篇学习笔记。\n本文仅供参考，学习顺序是不合理的。如果希望深入研究有限群分类，请先学完环和域。\r原来是为了醋包的饺子。不想看无聊细节的可以直奔第 12 节。\nGTM73 之 我只来得及看完群论了 这本教材内容是比较全的，对初学者不友好的点就是解说较少，就是大量的定理—证明，很多证明能看懂它是对的，但是无法理解它的思路是怎么想到的。\n1. 三个代数结构 大纲 半群、幺半群、群的定义，能导出它们的性质以及它们能导出的性质。 构建新群的方法：直积、用等价类划分。 笔记 幺元的定义是对每个元素都有一个同样的元素与它运算后不变，幺元的唯一性也是指在刚才这个定义中的唯一。对于半群与幺半群，对某个特定的 $a$，$ab=a$ 的 $b$ 可能有多个，例如含不互质元素的乘法半群，按位与、或的半群。\n由半群到群的判定：\n存在左幺元与左逆元的半群是群。\n存在左幺元与右逆元的半群不一定是群（$xy=y$）。\n存在左幺元与唯一右逆元的半群不一定是群（$xy=y$）。\n存在唯一左幺元与右逆元的半群一定是群。\n证：$e=a^{-1}(a^{-1})^{-1}=a^{-1}e(a^{-1})^{-1}=a^{-1}aa^{-1}(a^{-1})^{-1}=a^{-1}ae$，因此 $a^{-1}a$ 也是逆元，$a^{-1}a=e$。\n感觉这个证明没那么自然，可能是为了硬凑 $a^{-1}a$ 形式。能否给出更自然的证明？\n存在左逆元与右逆元的半群一定是群（这里没有定义幺元，所以左右逆元可以定义为 $ax=b$ 与 $ya=b$ 均有解）。\n证：$(\\exists x,ax=a)\\land(\\forall b,\\exists y,ya=b)\\Rightarrow\\forall b,bx=b$，因此存在右幺元。\n具有左右消去律的有限半群一定是群。\n证：由消去律 $aG=G$（双射），可以得到幺元以及逆元。\n具有左右消去律的无限半群不一定是群。（$\\N$）\n2. 同构、同态、子群、+循环群 大纲 同态、单同态、满同态、同构、自同态、自同构的定义。 核、像的定义。 子群、生成子群、循环群的定义。 以上概念相关性质（仅限群）： 单位元、逆元与子群在映射下的对应性，核、像也是子群，子群的交也是子群； 核大小为 $1$ 则为单同态； 子群的判定、生成子群的结构（最小）； 笔记 几个书里的理解问题： 单同态：$G$ 与 $H$ 的子群同构；满同态：$G$ 的商类与 $H$ 同构。 幺半群同态，幺元可能不对应，是因为可以找 $H$ 中某个平方等于自身的非幺元，把 $G$ 中所有元素都映射到它。然而群中是找不到这样的元素的。如果是满同态就对应了。 群同态中，每个有原像的元素，它们的原像集合大小相等。 群中一个元素不断自乘，是不可能形成 ρ 形的。于是有限子群的判定只需要看封闭性即可。 无限群一定有无限个子群，这是因为取出其每个元素的循环子群，如果只有有限个，那么必定有一个子群为无限的，那取其的子群即可。 循环群基本上讲的是废话，但是有个性质还是挺重要的，在数论中用得很多。对于阿贝尔群： $|a|\\perp|b|\\Rightarrow|ab|=|a||b|$。证明思路有两个：① 如果 $a^t=b^{-t}=x\\ne e$，那么 $|x|\\mid|a|\\land|x|\\mid|b|$，故 $|x|=1$，矛盾；② 如果 $(ab)^t=e$，那么 $a^{t|b|}=(ab)^{t|b|}=e=(ab)^{t|a|}=b^{t|a|}$，故 $|a|\\mid t\\land|b|\\mid t$。 $\\exists c,|c|=\\lcm(|a|,|b|)$。设 $|a|=xy^\\prime$，$|b|=x^\\prime y$，设所有在 $|a|$ 中次数 $\\ge$ 在 $|b|$ 的质因子乘积为 $X$，其余为 $Y$，$x=\\gcd(|a|,X^\\infin)$，其余同理。取 $c=a^yb^x$，由于 $|a^y|=x\\perp|b^x|=y$，故 $|c|=xy=\\lcm(|a|,|b|)$。 $|a|=p^x,|b|=p^y,x\u0026lt;y\\Rightarrow|ab|=p^y$。若有 $z\u0026lt;x$ 使 $(ab)^{p^z}=1$，则 $p^{x-z}=|a^{p^z}|=|b^{p^z}|=p^{y-z}$。 2 的形式对于（不一定循环）子群也成立。这个学了后面的知识就显然了，阿贝尔是个很强的性质。 3. Lagrange 定理相关 大纲 群中左/右同余、左/右陪集、左/右商集的定义及性质。 指标、子群乘积的定义及相关性质： （拉格朗日定理）$[G:H]=|G|/|H|$ $[G:K]=[G:H][H:K]$ $|HK|=|H||K|/|H\\cap K|$ $[H:H\\cap K]\\le [G:K]$，取等 $\\Leftrightarrow G=HK$ 笔记 关键抓住两句话：\n同一陪集内的元素对应的陪集仍为该陪集。 陪集形成等大的划分。 阶为质数的群一定与 $\\Z_p$ 同构，可以取 $\\set e$ 以外的循环子群，利用拉格朗日定理。\n另外，拉格朗日定理本质上就是 Burnside 引理的引理 $|E||Z|=|G|$，这个后面会详细讲。\n4. 正规子群与商群 大纲 正规子群的定义、等价表述、相关性质。 由正规子群的陪集构成的商群，其性质。 群的三个同构定理： $G$ 关于其同态核的商群，同构于同态映射的像。 某一子群关于一正规子群（与其交）的商群，同构于两者的积关于该正规子群的商群。 两个具有包含关系的正规子群，原群关于小者的商群与大者关于小者的商群，同样构成正规子群关系，且原群关于大者的商群，同构于两者分别关于小者取商群后再取的商群。 满同态下子群、正规子群、商群的一一对应性（当然，得是符合某些简单条件的）。 下文所有“正规子群”都默认为除 $\\set{e}$ 与本身外的正规子群。\n笔记 正规子群的核心是可以将群拆成“两层子群”，原理是左右幺元的同一。只有正规子群能生成商群（证明：https://www.zhihu.com/question/525584612/answer/2419749410）。\n一个群可能有多个同样大小的正规子群。\n$K\\norm H\\norm G\\nRightarrow K\\norm G$。而 $K\\norm G,K\\sub H\\sub G\\Rightarrow K\\norm H$，因为子群与正规子群的交是子群的正规子群。另外 $H,K\\norm G\\Rightarrow H\\cap K,HK\\norm G$。另外直积因子的直积因子是正规的。另外若 $K$ 是 $H$ 的正规 Sylow 子群且 $H\\norm G$，则 $K\\norm G$。\n关于群的三个同构定理的理解：\n（5.6）一个同态在缩了核之正规子群后，可以认为啥也没变，只是原像“类型转换”了一下。 （一）从同态在 $H$ 中的行为可看出，$a\\ker G$ 表现得和 $f(a)$ 完全一样，$\\ker G$ 表现得和 $e_G$ 一样。也正是因为左右幺元为同一个，故 $\\ker G\\norm G$。 （二）两种情况下商群结构完全相同，$K/(N\\cap K)=\\set{k(N\\cap K)}$，$NK/N=\\set{kN}$。注意与另一种情况区分：$NK\\subset H$，这时 $K/(N\\cap K)$ 相比于 $H/N$ 会漏一些。 （三）取商群就是划分等价类，只是把某些原来不同的元素视为相同，而保留原先的运算关系（行为），因此原群与大者分别关于小者取商群，并不会真正改变什么。 你甚至可以把（二）（三）都理解成类似约分的东西，一个是同乘的时候约分，一个是链式约分。\n本节相关命题的证明思路：\n只是证明正规或交换律。书里基本上都是用代数推导，也就是先用等价表述 (iv)，即设 $ana^{-1}$，在需要的时候用 (iii)，即令 $an_1=n_2a$。代数推导缺点是没那么直观，我会喜欢只用 (iii)，但有的命题必须用代数。\n证明同构。要么直接构造双射，要么用群的第一同构定理（需要凑同态，一般不难），这里给出二、三同构定理依赖于第一同构定理的证明：\n（二）构造 $K\\to NK/N$，这边需要 $nkN=kN$ 以证明满同态。这个映射干了两个事，一个是划分 $K$ 中的等价类（同时确立了核为 $N\\cap K$），另一个是纯类型转换，把 $k(N\\cap K)$ 转换为 $kN$。 （三）构造 $G/K\\to G/H$。这个映射单纯就是个类型转换，把 $gK$ 转换为 $gH$，当然这个类型转换就伴随着等价类划分（$K\\sub H$ 故不同元素数变少），即按核 $H/K$ 划分。 可以得到一种感觉，就是这种同态的构造就是一种“缩”（按等价类划分），这种缩是伴随着类型转换（小正规子群的陪集到大正规子群的陪集）出现的（注：（二）中的缩其实是 $k\\set e\\to k(N\\cap K)$）。\n5. 对称群、交错群、二面体群 大纲 某些 OIer 众所周知的东西。 对称群（$n\\ge 5$）有唯一正规子群。 证明交错群的单性： 证明三轮换能生成原群，以及包含三轮换的正规子群是原群。 证明正规子群不管长什么样，都得包含三轮换。 二面体群的刻画。 笔记 在对置换较复杂的处理中，不要想着把置换看作作用于某一排列的移动，而应当把它看作一个双射。运算时直接看每个元素从右往左经过映射后到哪就行。\n为了更轻松地理解证明的动机，需要熟悉以下几个置换的运算：\n称形如 $ana^{-1}$ 的东西为 $n$ 的共轭。书里没讲的一点是，$\\tau(i_1\\cdots i_r)\\tau^{-1}=(\\tau(i_1)\\cdots\\tau(i_r))$。这给出了“偷换”轮换中某些元素而不改变结构的一个极佳手段。 $(aJ)(aI)=(aIJ)$，其中 $I\\cap J=\\varnothing$。这边用大写字母表示一段元素。相当于用一个元素把两个轮换“串”起来了（8 字形）。一个特例是 $(i_1\\cdots i_r)=(i_1i_r)\\cdots(i_1i_2)$。 $(aJ_1bJ_2)(aI_1bI_2)=(aI_1J_2)(bI_2J_1)$，其中 $I\\cap J=\\varnothing$。对于三轮换的情况：$(ab)(abc)=(bc)$、$(abc)(ab)=(ac)$、$(abd)(abc)=(ad)(bc)$、$(adb)(abc)=(bcd)$、$(abd)(acb)=(acd)$、$(adb)(acb)=(ac)(bd)$。另外还有 $(abc)^2=(acb)$、$(acb)(abc)=e$。 证明单群要找出三轮换，无非就是自乘和构造 $\\nu^{-1}\\tau\\nu\\tau^{-1}$。\n对 $S_n$ 子群的总结：\n除 $S_4$ 外，其余群只有唯一正规子群 $A_n$，因为如果有另一个，它与 $A_n$ 的交就是 $A_n$ 的正规子群，必须是 $\\set{e}$，那这样的一个正规子群必须恰好包含 $e$ 和一个奇置换（如果有两个，奇奇得偶 $\\ne e$ 就爆了），这个奇置换必须由奇数个对换组成，随便用共轭替换掉其中一两个元素就爆了。 $K_4\\norm A_4\\norm S_4$ 且 $K_4\\norm S_4$。主要就是只要由若干共轭类组成，就至少满足了正规性，只需要再保证封闭即可。$K_4$ 神奇地封闭了，就是这样。$S_4$ 仅有这两个正规子群，$A_4$ 也仅有这个正规子群，证明直接考虑大小。 $A_4$ 没有 $6$ 阶子群。考虑 $3$ 阶元。 $S_n$ 中指数为 $2$ 的子群仅有 $A_n$（利用指数为 $2$ 的子群一定是正规子群，$n=4$ 时如果还有的话，交大小就得是 $6$，矛盾）。 满足二面体群性质的群结构唯一，这个证明比较典型。后面自由群给了一般性的证明。\n$S_n$ 和 $A_n$ 的子群无法刻画。关于 $D_n$：\n正规子群。如果 $a^xb\\in H$，则 $H\\ni(a^ib)(a^xb)(a^ib)=a^{2i-x}b$。因此正规子群有 $\\lang a^d\\rang$（$d\\mid n$），如果 $2\\mid n$，则还有 $\\lang a^2,b\\rang$ 和 $\\lang a^2,ab\\rang$。 子群。如果 $H\\cap\\set{a^ib}\\ne\\varnothing$，那么要么 $|H|=2$，要么 $H\\cap\\set{a^i}=\\lang a^d\\rang$（$d\\mid n$）。后面一种情况下，$H\\cap\\set{a^ib}=\\set{a^{kd+r}b}$（$0\\le r\u0026lt;d$）。如果还有别的元素，就可以用类似循环群子群的证明方法找到更小的 $a^{d^\\prime }$。因此真子群有 $\\lang a^ib\\rang$、$\\lang a^d\\rang$、$\\lang a^d,a^rb\\rang$。 关于 $S_4/K_4\\cong S_3$ 与 $A_4/K_4\\cong Z_3$，固然可以用第二同构定理证，但这里从置换的作用出发给出了一个直观的证明：https://math.stackexchange.com/questions/302654/show-that-s-4-v-is-isomorphic-to-s-3-where-v-is-the-klein-four-group。\n这个证明说了一个事，当使用第一同构定理时，从群的作用意义上来说，我们实际上考虑了被作用对象的一部分特征，而那个同构的小群，就是这部分特征所作出的变化本质不同的作用方式形成的群。\n6. 直积 大纲 直积、外直积、内直积的定义，在同态、取商情况下的性质。 笔记 $\\lang\\rang$ 符号是有限生成， 内、外直积都是在此基础上定义。注意有限和无限情况不同，例如无限位二进制数的异或，逐位为一的直积的阶为 $\\aleph_1$，内、外直积的阶为 $\\aleph_0$。这个就像有理数与无理数间的关系。 在满足条件时，内、外直积的区别只在于类型不同。当我们说（内）直积，或者说一个群等于一些子群的积时，默认这个直积不是多元组的形式，而是直接相乘的形式，也就是说，当且仅当每个 $N_i$ 均为正规子群且与别的子群的积交为 $\\set e$ $\\Longleftrightarrow$ 每个元素的表达方式唯一 $\\Longleftrightarrow$ $e$ 的表达方式唯一时，这个说法才有意义。而当我们说外直积，或者说一个群同构于一些小群的积时，默认是多元组的形式。 注意，$N\\times(G/N)\\cong G$ 是不一定成立的，例如 $2\\Z_4\\oplus(\\Z_4/2\\Z_4)\\cong\\Z_2\\oplus\\Z_2\\not\\cong\\Z_4$。 7. 自由群 大纲 自由群的定义。 用自由群生成任何群。 笔记 虽说自由群也是有运算的群，但我们可以将它理解成字符串，这种字符串刻画的是一堆元素的运算，其中关键的一点是，只要运算式字面上不同，就认为实质不同，这一点在其余群中是基本不会出现的，否则这样的群就没啥性质了。\n但是，这里需要避免混淆的一点是，字内字母的排列，与两个字的运算，都写成了顺次拼接的形式。在证明自由群的结合律时，如果要硬证的话，必须讨论三个字 $a,b,c$ 以不同顺序考虑抵消时实际的抵消情况来证明，或者用归纳法。而不能说“由于每个字都可以看成若干个单 $x^{\\pm 1}$ 运算在一起，而所有 $x^{\\pm 1}$ 是有结合律的，因此所有元素都满足结合律”（相当于只证了部分元素的结合律）。不过，书里的这个证明很有意思：赋予每个元素一个实际含义“对所有字的置换”，这样既保证了区分任何字面不同的情况，又将结合律的证明归约到了对称群的结合律。\n另外，这节的理论很好地解释了 [CSP-S 2023] 消消乐 的 trie 树做法的动机——找所有 $s_i\\cdots s_j=e$，就可以转化成找所有 $(s_1\\cdots s_{i-1})^{-1}s_1\\cdots s_j=e$，也就是 $s_1\\cdots s_j=s_1\\cdots s_i$。这题唯一的特殊性是给定了关系 $xx=e$，不过没什么影响。\n自由群的子群均为自由群，这个证明很难。另外自由群子群的最小生成元集大小可能大于原群的。\n所有群都同构于自由群的商群，以及给定生成元集和关系可以唯一确定“最大”的群，这个很重要。几点理解：\n这个证明的核心是，在自由群的基础上添加特定群的额外关系后不会出现矛盾，而这是平凡的（否则自由群就不够自由了……）。 关系的生成正规子群，这个东西的确定，依赖于正规子群的交仍为正规子群。关于 9.5 的证明，直观的理解就是，最大的群对应那个最小的核，有大核的话有可以它通过 5.6 或 5.8 搞个满射。 一个群的商群可能不同构于其子群，否则由“自由群的子群均为自由群”，就会出现很诡异的事情。 证明某一个表示对应的群是某个群：先验证符合，然后再通过关系的代数推导，得出“所有的元素都能表示为某类形式”，从而证明大小的上界。\n8. 有限生成 Abel 群结构定理 大纲 自由阿贝尔群的定义。 用自由阿贝尔群生成任何阿贝尔群。 若干种取子群的方式（$mG,G[m],G(p),G_t$）的定义及性质。 有限秩的自由阿贝尔群的子群的结构，即所有有限生成阿贝尔群的结构。 笔记 我们来大致梳理以下整个刻画过程的思路：\n定义自由阿贝尔群，知道自由群后，这个定义是很自然的。处理自由阿贝尔群的性质时，套路是和线性代数很相似的，唯一不同的点是线性代数允许一个向量乘有理数加给另一个向量（以及向量本身乘一个数），而阿贝尔群不允许。也正是这一点，导致了。\n导出自由阿贝尔群的一些性质：\n每个元素表示唯一、基在某个元素乘若干倍加给另一个元素的操作下仍为基，以及它的“自由”性（同样，自由的证明仅需要证明良定义即可）。 额外地，证明自由阿贝尔群的基大小唯一。这里对秩有限情况的证明策略是通过取商群，将无限转化为有限，而秩无限的情况就直接用定义和序数理论。我们会注意到，对于唯一性的证明，套路一般就是通过一种不依赖于具体分解的方式，取子群或商群，然后通过这两个不能不相等，证回唯一。 有限秩的自由阿贝尔群的子群的结构。这个证明最好的方式其实是给出一个构造性的算法：首先考虑用自由群的基线性表出子群的各个生成元，写成一个矩阵。对这个矩阵列变换就是改变基，行变换就是改变生成元集。为了保证改变后可生成性不变，只能使用交换两行/列、一个乘整数倍加给另一个、以及一行/列乘 $-1$。现在可以通过一个算法将矩阵化为史密斯标准形：\n每次通过多元素的辗转相除法，将左上角元素变为所在行或所在列的 $\\gcd$，并把对应行/列的其他元素全部减成 $0$。注意到，一旦 $\\gcd$ 不缩小，就可以将行列均变为 $0$，那这样就可以归约到两维各减一的子矩阵。（这里我有一个时间复杂度更优的算法）\n现在可以假定只有 $a_{1,1}$ 到 $a_{r,r}$ 非零。注意到可以用： $$ \\begin{bmatrix}a\u0026amp;0\\\\ 0\u0026amp;b\\end{bmatrix}\\xrightarrow{\\mathrm{B\\acute{e}zout}}\\begin{bmatrix}a\u0026amp;g\\\\ 0\u0026amp;b\\end{bmatrix}\\rightarrow\\begin{bmatrix}a\u0026amp;g\\\\ -l\u0026amp;0\\end{bmatrix}\\rightarrow \\begin{bmatrix}g\u0026amp;0\\\\ 0\u0026amp;l\\end{bmatrix} $$ 将两个元素分别变为它们的 $\\gcd$ 和 $\\lcm$。那就可以用类似冒泡的过程，将这个对角线上的元素调整为依次整除。\n而书里用了一个类似无穷递降法的过程。根据证明贪心的一些经验，由于一般反证只干掉单步，故会比构造性的过程简单一些。书里的思路是：首先找到所有可行生成元被所有基表出的所有系数中最小的一个系数对应的一项 $d_1x_1$，这个 $d_1x_1$ 能作为第一个生成元，然后接着归约就行。其递降的核心是，若不整除，则余数会导致更小项。\n然后就是利用第一同构定理加商群在直积下的同构性，直接导出任何有限生成阿贝尔群存在一种预想的拆分方式。合数阶的拆分太显然了。最后是证明拆分的唯一性：\n$\\Z$ 部分，商掉挠子群，归到自由阿贝尔群表示的唯一性。 “唯一分解定理”，处理方式仍然是抽出子群证相等或矛盾。注意到有限阿贝尔群的商群和子群是可以打通的（https://math.stackexchange.com/questions/64982/is-every-quotient-of-a-finite-abelian-group-g-isomorphic-to-some-subgroup-of），所以用哪种无所谓。 依次整除的表示唯一。这个看起来不大直觉，但是把每个阶都拆开来排成矩阵，就显然了。 阶为 $n$ 的阿贝尔群的数量 $f(n)$ 是积性函数，其中 $f(p^k)=p(k)$，$p(k)$ 是 $k$ 的无序拆分数。\n练习 2.2 的思路：只考虑指数幂情况。归纳，找到一个阶为质数的，与 $\\lang x\\rang$ 交为 $\\set{0}$ 的群 $H$（直接找循环群即可），然后归纳。归纳有个细节，就是 $G/H=(\\lang x\\rang H)\\oplus(K/H)$ 推到 $G=\\lang x\\rang+K+H=\\lang x\\rang\\oplus K$ 时，要用直积那节交为 $\\set{0}$ 的性质。然后推大结论用的是所有元素的阶都整除最大阶。\nhttps://math.libretexts.org/Bookshelves/Abstract_and_Geometric_Algebra/Abstract_Algebra%3A_Theory_and_Applications_(Judson)/13%3A_The_Structure_of_Groups/13.01%3A_Finite_Abelian_Groups 的 Lemma 13.9。\n注意挠群不一定有限，例如 Prüfer 群 $\\Z(p^\\infin)$，它是无限个 $\\Z_p$ 的内直积。\n9. Krull-Schmidt 定理 大纲 最看不懂的一集。\n不可分解群、升降链的定义与关系，正规自同态、幂零的定义。 为证明 Krull-Schmidt 定理所作的准备，自同态在满足升降链条件的情况下的四条性质。 Krull-Schmidt 定理。 笔记 不可分解的条件比单群弱。\n梳理一下证明思路。Krull-Schmidt 定理核心说的就是，ACC 和 DCC 同时成立的情况下分解唯一（我怎么感觉有限群之外一般都用不了这个……）\n满足 ACC\u0026amp;DCC 的不可分解群的自同态要么是自同构，要么是幂零。可根据 $G=(\\ker f^n)(\\im f^n)$ 直接导出，而 3.4 和 3.5(Fitting) 都是把链设出来之后妙妙推式子。注意在 DCC 是 $f$ 需要正规只是为了 DCC 正规，而正规最终是为了和内直积对上。 在 $G=G_1\\times\\cdots\\times G_r\\times H_{r+1}\\times\\cdots\\times H_t$ 的情况下，要找到一个 $H_j\\cong G_{r+1}$。找的思路是，$G$ 中的元素，它在全 $G_i$ 分解中的 $G_{r+1}$ 分量，在当前分解中体现为 $H_{r+1}\\sim H_t$ 分量的一部分，用书中的代数语言写，就是如果让 $\\varphi$、$\\psi$ 为取分量操作，$\\varphi_r=\\sum_{j\\ge r}\\varphi_r\\psi_j$。$\\varphi_r$ 是 $G_r$ 下的单位映射，所以右式不能全是幂零。 要证明最后一句话，就是要证幂零自同态之和封闭 $\\Rightarrow$ 幂零。容易想到反证，因为直觉上来说，多个幂零的东西加起来也是幂零的。但直接取幂，由于自同态关于加法没有交换律，所以搞不了。这里证明搞了个 $g_i=f_i(f_1+f_2)^{-1}$，然后一波妙妙推式子就交换了。这边加法和复合构成环。 回到原证明，找到一个不是幂零的也就是自同构，分析一下单、满射就可以得到 $\\psi_j$ 和 $\\varphi_r$ 是（正反方向）同构，然后就要证直接把 $H_j$ 换成 $G_r$ 就行了，就是说虽然 $H_j$ 和 $G_r$ 的东西不一样，但是它们乘上别的之后就得到了整个 $G$，从两个方面（不重——和别的交为 $\\set{e}$，不漏——单+3.4=双）证即可。最后才导出 $s=t$。 3.4、3.5、3.7 都有妙妙推式子，我真没法理解思路，除了 3.4：\n$\\ker f^n=\\ker f^{n+1}$ 的话，说明只有原来的核是新的核，也就是只有原来的 $e$ 是新的 $e$，则单射则双射。\n$\\im f^n=\\im f^{n+1}$ 的话，说明原来的像能覆盖新的像了，那像以外的部分就得汇聚到像内导致多对一，于是根本就不能有像以外的部分，则满射则双射。\n然后怎么理解 3.8 的这个“逐一替换”强于单说同构呢？可以看 https://math.stackexchange.com/questions/2982433/krull-schmidt-theorem-for-groups，本质上就是内直积它是直接子群直积，避开了多元组然后同构的步骤，也就是说 Krull-Schmidt 定理说的不单单是结构唯一，而且还能直接从 $G$ 里取出一堆来直接生成。\n另外，这个替换过程可以类比线代：比如 $\\R^2$ 的基既可以是 $[1\\quad0]$ 和 $[0\\quad1]$，也可以是 $[1\\quad0]$ 和 $[1\\quad1]$，可以把 $G_r$ 和 $H_j$ 分别看成两个基的后者。\n另外注意证明过程中是否有：有限、$G\\ne\\set{e}$、either ACC/DCC 还是 both ACC\u0026amp;DCC。\n3.3 的证明就反证后随便找找子群（DCC 做个前缀和），不过存在不可分解群不满足 ACC 也不满足 DCC 吗？\n10. 群作用 大纲 群作用、轨道、稳定化子、共轭类、中心化子、正规化子、类方程、中心、内自同构的定义。 关于它们的一些性质，主要是以 $|E||Z|=|G|$ 为核心思想的部分，和质数正规的部分。 笔记 关于群作用的概念较多，研究的核心就是两个：作用者和被作用者。被作用者，我们主要关心其等价类与使它不变的“子”；作用者，主要关心其不动点。特别地，我们非常关心群自身作用自身的情况，这时作用者和被作用者的地位可互换（中心，$gx=xg$）。\n在这几节中，每个定理我们都必须首先明确作用者和被作用者，不然马上就糊涂了。\n指数为最小质因子的子群必正规，这个的证明思路是：考虑陪集 → $G$ 左作用给左陪集是置换 → $G$ 根据作用效果分类 → ① 置换子群最大质因子是 $p$ ② 划分得是 $|G|$ 的因子 → 只可能 $H$ 自身是核（核至多是 $H$）。\n这个过程还算易懂，但是是怎么想到绕这样一个弯证出来的？\n补充一下，内自同构是自同构群的正规子群，其商群成为外自同构。\n11. Sylow 定理 大纲 Sylow 定理的一些引理，主要是关于阶为质数的群的性质。 Sylow $p$ 子群的定义、Sylow 三定理。 笔记 这个部分主要有几个核心思想：\n$|S|\\equiv|S_0|\\pmod p$ 一类。这个说的是，被作用者形成的等价类中，由于稳定化子的陪集构成整个轨道，故每个的大小都是 $p$ 的次幂，然后取 $p^0$（不动点）那部分。这个性质的唯一作用就是说非平凡不动点存在。注意用它的前提条件是作用者的阶必须是质数幂。\n有个重要的思想有点难表述，我们看下几个有相似点的证明思想：\n定理 5.5. $p$ 子群 $H$ 满足：它的“正规化陪集”数（显然，一个 $H$ 的陪集要么全是正规化子要么全不是），与它的陪集数同余。\n首先得明确，引理 5.1 只能用于同余式两边都是被作用者的情况，但是 5.5 的形式中，就算我们考虑把 $H$ 的陪集作为被作用者，这个“正规化陪集”再怎么说都只能是作用者啊！都写明了是“使 $H$ 正规”。这里我们联想 4.7 证明里的一句话：\n$g$ 是中心 $\\Leftrightarrow$ $g$ 是不动点。（前提：$G$ 共轭作用给 $G$ 自身）\n说明：$gxg^{-1}=x\\Leftrightarrow xgx^{-1}=g$\n我们得以从“中心”这一作用者的角度，转化为“不动点”这一被作用者的角度。那这里也是一样的。\n这里，选用的是 $H$ 的元素作为作用者（左作用），这个感觉有点怪异。那么 $|S_0|$ 就应该是在所有 $h$ 的作用下不动的陪集：$h(xH)=xH\\Leftrightarrow xHx^{-1}=H$，于是就打通了。发现这个的本质和上面这种单点的是类似的。\n另外注意：$\\forall h\\in H,x^{-1}hx\\in H\\Rightarrow x^{-1}Hx=H$ 这个是在有限前提下的。\n第二定理：要证 $H\\sub xPx^{-1}$，模仿上面的证明，逆向考虑，我们要找的应当是 $h(xP)=xP$（$p(xH)=xH$ 的话就倒反天罡了），即 $P$ 陪集为被作用者，$H$ 的元素为作用者（左）。然后就是个 $[G:P]\\not\\equiv0$。\n第三定理：其实说的就是 $[G:N_G(P)]\\equiv 1$，拿 5.5 除一下就出来了。不过多个思路也是好事。这里显然考虑被作用者是 $P$ 的所有共轭，即 $\\syl_p(G)$，然后让 $S_0=\\set P$ 就行。$P$ 的元素为作用者，于是 $\\forall p\\in P,pQp^{-1}=Q\\Rightarrow P\\sub N_G(Q)$ 然后由第二定理就得到 $P=Q$。\n容易发现，这里的通用构造是“某个小集合（可能就是这个子集）作用在所有子集的陪集上”，然后从不动点出发，去推一些神奇的结论。前一节中是将作用视作置换群，先从作用者的稳定性考虑，能推的不是很多（仅能推出 $\\mid n!$ 相关的性质）。反正记住有这两类证的思路就行。\n第一定理反而显得简单了，就是用柯西定理找个循环群，然后找稳定化子升幂即可。5.11 和第三定理思路中的一块是相同的，就是共轭不变 $+$ Sylow $p$ $\\Rightarrow$ 唯一。\n看了第一定理后，会有一个直觉，就是 Sylow $p$ 子群唯一，感觉上如果有两个，可以乘一下搞出更大的。但是这个是不对的，可以看 https://planetmath.org/subgroupsofs4 为例。另外两个 Sylow $p$ 子群的交也可能非平凡：https://math.stackexchange.com/questions/24704/distinct-sylow-p-subgroups-intersect-only-at-the-identity-which-somehow-follo。\n这里提一下 Sylow 第三定理的加强版本：\n设 $v_p(|G|)=m$ 且 $G$ 的所有 Sylow $p$ 子群中，交最大大小为 $p^r$，则 $n_p(G)\\equiv1\\pmod{p^{m-r}}$。\n证：我们仍然考虑某一 Sylow $p$ 子群 $P$ 共轭作用在 $\\syl_p(G)$ 上。在上面的第三定理中，我们说明的是 $Q$ 不能不动即 $N_P(Q)\\ne P$ 即 $P\\not\\sub N_G(Q)$，其证明手段是，$N_G(Q)$ 中只有唯一 Sylow $p$ 子群 $Q$。那这里也是一样的，$N_P(Q)=N_G(Q)\\cap P$，现在我们额外地说，由于 $N_G(Q)\\cap P$ 必须是 $p$ 子群，而 $N_G(Q)$ 的 $p$ 子群都包含于 $Q$ 中，因此 $N_P(Q)\\sub P\\cap Q$，故 $|N_P(Q)|\\le|P\\cap Q|\\le p^r$，故 $p^{m-r}\\mid|\\mathrm{Orb}_P(Q)|$。\n这个在有限群分类、证明单群时可以用。\n问题：是否会出现某个大小的 $p$ 子群唯一，但 Sylow $p$ 子群不唯一的情况？\n看个搞笑的：https://www.zhihu.com/question/36479927/answer/1554929023。\n12. 有限群分类 大纲 $pq$、$8$、$12$ 阶群结构。 笔记 下文所有 $n_p$ 默认为 $n_p(G)$。\n主要的几个分析方法：\n最常用的几个基本定理：拉格朗日定理、第一同构定理、阿贝尔群结构、$G/C(G)$ 循环则阿贝尔、全 $2$ 阶则阿贝尔、指数为最小质因子则正规、$p$ 群中心非平凡、Sylow 定理。\n一个极为有效的推导：$n_p=kp+1$ 且 $n_p\\mid\\frac{|G|}{\\gcd(|G|,p^\\infin)}$，然后要么就是单个正规子群，要么数量可能性少。单个正规子群时，可以从正规性和商群的角度列出两个式子 $bab^{-1}=a^?$ 与 $b^{[G:N]}=a^?$。处理共轭时常用的推导是 $ba^jb^{-1}=(bab^{-1})^j$ 以及 $b^{i}ab^{-i}=b^{i-1}a^kb^{-(i-1)}=\\cdots=(bab^{-1})^{k^i}$。\n这样的一个推导实际上是在分析一个任意子群到正规子群自同构的同态。实际上我们主要会遇到：\n$\\aut\\Z_n=\\Z_n^\\times$。然后根据中国剩余定理与原根存在定理进行拆分。 $\\aut\\Z_p^k\\cong\\mathrm{GL}_k(\\F_p)$。就是 $\\bmod p$ 下的 $k$ 阶满秩矩阵，其列向量对应每个生成元映射到哪。 其他一些阿贝尔群的自同构。先尝试按质因子拆，包含多个 $\\Z_{p^k}$ 直积因子可能会不好搞 其他。只能讨论一些小的情况，另外可考虑正规子群的不动性。 如果正规子群太小，可以用 Correspondence Theorem（或叫 Lattice Theorem）扩大。其实感觉比较平凡，就是说 $G/N$ 的正规子群对应 $G$ 的正规子群，其实在 I.5.11 提到过。然后这个反过来也是成立的，即 $G$ 的正规子群也对应 $G/N$ 的正规子群。\n如果正规子群太大，也可以考虑第 4 节笔记里的方法。\n如果搞不出正规子群，我们一定要强制搞出来。有几个处理思路：\n考虑共轭 Sylow 子群多的话可能元素会分配不过来。 考虑对子群的陪集或正规子群共轭的作用，同态于对称群。 考虑中心，可以直接讨论，或者考虑共轭 Sylow 子群的交之类的。中心意味着直积。 然后总结一下各种情况的证明思路。注意当给出一个生成关系时，应当证明它对应的群大小恰好是它且确实是群，不然是不够的，但是这里就略去了。\n$p^2$。中心个数是 $p$ 的倍数，于是 $G/C(G)$ 是 $1$ 或 $p$ 阶的，后一种情况通过写出元素的形式可得交换，于是 $G$ 是阿贝尔群。\n$pq,(p\u0026lt;q)$。存在唯一 Sylow $q$ 子群 $\\lang a\\rang$，$n_p\u0026gt;1$ 就必须是 $q\\mid(p-1)$ 情况，取个其中的元素 $b$，$bab^{-1}=a^s\\Rightarrow a=b^pab^{-p}=a^{s^p}\\Rightarrow s^p\\equiv 1\\pmod q$。证明所有 $ba=a^sb$ 的群同构只需构造 $\\varphi(a)=a^\\prime ,\\varphi(b)={b^\\prime }^{\\operatorname{ind}_{s^\\prime }s}$ 即可，这给出了 $G\\cong\\Z_q\\rtimes\\Z_p$ 且半直积的下标可以省略。\n$8$。非阿贝尔的情况一定有一个阶为 $4$ 的元素 $a$，取 $b\\notin\\lang a\\rang$，① $b$ 对 $\\lang a\\rang$ 的共轭形成 $\\lang a\\rang$ 的自同构，于是不交换只能是 $bab^{-1}=a^3\\Rightarrow ba=a^{-1}b$；② $b^2\\in\\lang a\\rang\\Rightarrow b^2=e\\or a^2$。分别对应 $D_4$ 和 $Q_8$。\n$12$。类似证明指数为最小质因子的群正规的方式，考虑对 $4$ 个 Sylow $3$ 子群的陪集的左作用，到 $S_4$ 的同态。若核是 $\\set{e}$，则 $G\\cong A_4$；否则由于核是该 Sylow $3$ 子群的子群，故必为其本身，故 Sylow $3$ 子群正规，设为 $\\lang a\\rang$，它的中心化子里一定有 $|b|=2$，于是 $|ab|=6$。记 $c=ab$，则 $dcd^{-1}=c^5$（非交换）且 $d^2=c^{0\\or2\\or3\\or4}$。如果是 $2\\or 4$ 就会 $c^{\\pm 2}=d^2=dc^{\\pm2}d^{-1}=c^{\\mp2}$ 矛盾，故 $d^2=e\\or c^3$。\n这两种分别对应 $D_6$ 与 $\\Z_6\\rtimes\\Z_2$……吗？？？如果是 $\\Z_6\\rtimes\\Z_2$ 的话，含 $d$ 的元素的阶就全是 $2$ 了，就是 $D_6$。考虑以 $a$ 和 $d$ 作为生成元（$d^2=b$ 所以 $d$ 可以替代 $b$ 的功能），于是关系就变成了 $a^3=d^4=e,dad^{-1}=a^2$，这样就可以写成 $\\Z_3\\rtimes\\Z_4$ 了。\n又看到一个不错的证明思路 https://www.youtube.com/watch?v=dS-fIMHVNcE。\n实际上回头看这里，考虑一个 Sylow $2$ 子群（$\\Z_4$ 或 $\\Z_2^2$）到 $\\aut\\Z_3$ 的同态（非平凡的只有一个）即可。\n$p^3$。如果有 $p^2$ 阶元 $a$ 则 $\\lang a\\rang\\norm G$，那么显然希望找到另一个 $p$ 阶元 $b$ 从而构成 $\\Z_{p^2}\\rtimes\\Z_p$，这个可以先随便取一个 $b$，然后如果它的阶数不对的话，乘上某个 $a^?$ 就行，这个 $?$ 可以待定系数法解出来。然后容易证明所有的 $bab^{-1}=a^k$ 都是同构的，这里要求 $\\delta_{p^2}(k)=p$，所以关系可以写成 $a^{p^2}=b^p=1,ba=a^{p+1}b$。\n如果没有，则选个 $p$ 阶中心 $c$（$|C(G)|=p$ 否则类似 $p^2$ 情况就阿贝尔了），选 $\\lang c\\rang$ 以外 $p$ 阶元 $a$，再选另外的 $b$。这里 $\\Z_p^2\\cong\\lang c\\rang\\times\\lang a\\rang\\norm G$，同样讨论在 $b$ 的共轭作用下这个正规子群会怎样自同构，这里讨论比较复杂，最后得出的同样是所有可能都是同构的，即 $\\Z_p^2\\rtimes\\Z_p$，关系可以写成 $a^p=b^p=c^p=e,ac=ca,bc=cb,c=bab^{-1}a^{-1}$。推导细节详见 https://www.zhihu.com/question/497442031/answer/3098229320。\n在搜资料的时候我发现半直积的性质还是很重要的，所以这里先补充一下相关的知识：\n应该从内半直积开始理解，现在假设 $HK=G$，$H\\cap K=\\set{e}$，但只有 $H\\norm G$。我们想使用类似直积的，$H\\rtimes K\\cong G$ 的方式来拆分 $G$，因此有同构映射 $f:(h,k)\\mapsto hk$，运算必须满足 $$ f((h_1,k_1)\\cdot(h_2,k_2))=f((h_1,k_1))f((h_2,k_2))=h_1k_1h_2k_2 $$ 就需要应对 $h$ 与 $k$ 无法交换的问题（如果 $K\\norm G$ 则根据 $hkh^{-1}k^{-1}\\in H\\cap K=\\set{e}$ 可得交换性）。这里的关键是： $$ h_1k_1h_2k_2=h_1(k_1h_2k_1^{-1})k_1k_2 $$ 于是定义 $(h_1,k_1)\\cdot(h_2,k_2)=(h_1\\cdot k_1h_2k_1^{-1},k_1k_2)$，其余运算规则略，可验证其对应的群符合条件。\n外半直积也是一样的，我们知道在群中，共轭对应了内自同构。这里要构造群，就只需要是自同构就行了，即，若有同态（不能单单是映射，否则运算就不是良定义的了） $\\varphi:K\\to\\aut H$，就可以定义 $(h_1,k_1)\\cdot(h_2,k_2)=(h_1\\varphi(k_1)(h_2),k_1k_2)$。这就是外半直积 $H\\rtimes_\\varphi K$，在不引起歧义时可省略 $\\varphi$。\n以上内容参考了 https://www.youtube.com/watch?v=Pat5Qsmrdaw。\n性质 1：对于 $\\varphi:K\\to\\inn H$，$H\\rtimes_\\varphi K\\cong H\\times K$。\n证：根据 $\\varphi$ 得到一个 $\\psi:K\\to H$，$(h_1,k_1)(h_2,k_2)=(h_1\\psi(k_1)h_2\\psi(k_1)^{-1},k_1k_2)$。构造同构映射 $f:(h,k)\\mapsto h\\psi(k)$，验证 $$ \\begin{align*} \u0026amp;f((h_1,k_1)(h_2,k_2))\\\\ ={}\u0026amp;h_1\\psi(k_1)h_2\\psi(k_1)^{-1}\\psi(k_1k_2)\\\\ ={}\u0026amp;h_1\\psi(k_1)h_2\\psi(k_2)\\\\ ={}\u0026amp;f((h_1,k_1))f((h_2,k_2)) \\end{align*} $$\n性质 2：$\\exists\\chi\\in\\aut H,\\forall k\\in K,\\psi(k)=\\chi\\circ\\varphi(k)\\circ\\chi^{-1}\\Rightarrow H\\rtimes_\\varphi K\\cong H\\rtimes_\\psi K$。\n证：构造 $f:(h,k)\\mapsto(\\chi(h),k)^\\prime $，验证 $$ \\begin{align*} \u0026amp;f((h_1,k_1)(h_2,k_2))\\\\ ={}\u0026amp;f((h_1\\varphi(k_1)(h_2),k_1k_2))\\\\ ={}\u0026amp;(\\chi(h_1)(\\chi\\circ\\varphi(k_1))(h_2),k_1k_2)^\\prime \\\\ ={}\u0026amp;(\\chi(h_1)(\\psi(k_1)\\circ\\chi)(h_2),k_1k_2)^\\prime \\\\ ={}\u0026amp;(\\chi(h_1),k_1)^\\prime (\\chi(h_2),k_2)^\\prime \\\\ ={}\u0026amp;f((h_1,k_1))f((h_2,k_2)) \\end{align*} $$ 这个反过来是不对的，一个简单的反例就是性质 1。\n直觉上来说，这个性质就是对自同构本身作了自同构，或者在实际证明时，往往形如“我们换 $H$ 的生成元（比如 $a$ 换成 $a^3$ 之类），发现它变成了另一个自同构”，于是这两（几）个就只需考虑一个。\n性质 3：对于有限循环群 $K$，$\\exists\\chi\\in\\aut H,\\psi(K)=\\chi\\circ\\varphi(K)\\circ\\chi^{-1}\\Rightarrow H\\rtimes_\\varphi K\\cong H\\rtimes_\\psi K$。\n证：设 $K=\\lang k\\rang$。首先循环群有性质 $\\varphi(k^a)(h)=\\varphi(k)^a(h)$，因此下面以 $\\varphi,\\psi$ 指代 $\\varphi(k),\\psi(k)$。\n设 $\\psi^c=\\chi\\circ\\varphi\\circ\\chi^{-1}$，构造 $f:(h,k^a)\\mapsto(\\chi(h),k^{ac})^\\prime $，验证 $$ \\begin{align*} \u0026amp;f((h_1,k^a)(h_2,k^b))\\\\ ={}\u0026amp;f((h_1\\varphi^a(h_2),k^{a+b}))\\\\ ={}\u0026amp;(\\chi(h_1)(\\chi\\circ\\varphi^a)(h_2),k^{(a+b)c})^\\prime \\\\ ={}\u0026amp;(\\chi(h_1)((\\chi\\circ\\varphi\\circ\\chi^{-1})^a\\chi)(h_2),k^{(a+b)c})^\\prime \\\\ ={}\u0026amp;(\\chi(h_1)(\\psi^{ac}\\circ\\chi)(h_2),k^{(a+b)c})^\\prime \\\\ ={}\u0026amp;(\\chi(h_1),k^{ac})^\\prime (\\chi(h_2),k^{bc})^\\prime \\\\ ={}\u0026amp;f((h_1,k^a))f((h_2,k^b)) \\end{align*} $$ 注意，$K$ 有限时易验证 $c\\perp|K|$，从而 $f$ 是双射。$K$ 无限时 $f$ 就不是双射了。\n更多的反例详见 https://math.stackexchange.com/questions/624672/semi-direct-product-of-groups-with-one-of-them-cyclic 和 https://math.stackexchange.com/questions/527800/when-are-two-semidirect-products-isomorphic。\n由于群分类时大部分情况这个 $K$ 都是循环群，所以性质 3 会更好用。这个性质 3 相比性质 2 强的点在于，它只要求整个像共轭，而不用每个 $k$ 对应共轭。性质 3 和 $pq$ 情况的证明的核心思想是一样的。\n现在，我们可以从更高的角度理解 $p^3$ 情况的分析：若正规子群是 $\\Z_{p^2}$，那么性质 3 就说有本质唯一的 $\\varphi:\\lang b\\rang\\to\\set{f\\in\\aut\\Z_{p^2}\\mid f(a)=a^{kp+1},k\\ne 0}$。若正规子群是 $\\Z_p^2$，$\\aut\\Z_p^2\\cong\\mathrm{GL}_2(\\F_p)$，而 $|\\mathrm{GL}_2(\\F_p)|=(p^2-1)(p^2-p)$，于是它的唯一 Sylow $p$ 子群共轭类 $\\overline{\\left\\langle\\begin{bmatrix}1\u0026amp;1\\\\ 0\u0026amp;1\\end{bmatrix}\\right\\rangle}$ 就对应了所需的映射，于是半直积也是唯一的。\n$p^2q$。这个情况需要一个我不会证的性质，先写出来：\n对于性质 3，如果 $|H|\\perp|K|$，则反推也成立。\n这个性质是 https://math.stackexchange.com/a/1834299 的简单推论。\n这使我们能快速说明分类后各类不同构。接下来是按 $([p\\mid(q-1)],[q\\mid(p^2-1)])$ 的四种情况来分讨。\n$p\\mid(q-1)\\land q\\mid(p^2-1)$。唯一的可能是 $p=2,q=3$，已经在上面讨论过。 $p\\nmid(q-1)\\land q\\nmid(p^2-1)$。阿贝尔。 $p\\nmid(q-1)\\land q\\mid(p^2-1)$。 Sylow $p$ 子群是 $\\Z_{p^2}$。取个 $q$ 阶循环群，如果 $q\\mid(p-1)$，类似于 $pq$ 的时候，会有一个非平凡的情况，就是 $bab^{-1}=a^s$，其中 $\\delta_{p^2}(s)=q$。不同的 $s$ 对应的都是同构的。 Sylow $p$ 子群是 $\\Z_p^2$。这里的分析很复杂，概括一下就是，首先 $q\\mid(p-1)\\lor q\\mid(p+1)$。分三种情况，$q=2$ 是简单的，$q\\mid(p+1)$ 的情况有唯一共轭类，$q\\mid(p-1)$ 的情况有 $(q+3)/2$ 种。这里核心思路是，从特征值角度出发分析 $\\mathrm{GL}_2(\\F_p)$ 中 $q$ 阶循环子群之间的共轭关系。细节详见 https://www.math.purdue.edu/~jlipman/5532011/order-p%5e2q.pdf，注意这篇文章 $q=2$ 多算了个错的。 $p\\mid(q-1)\\land q\\nmid(p^2-1)$。还是随便取一个 Sylow $p$ 子群。 它是 $\\Z_{p^2}$。$bab^{-1}=a^s$ 的 $s$ 满足 $\\delta_q(s)=p$ 或 $\\delta_q(s)=p^2$（如果 $p^2\\mid(q-1)$），分别对应一种。 它是 $\\Z_p^2$。这里用不了性质 3 了，但是也不难搞。设生成元为 $b,c$，$bab^{-1}=a^s,cac^{-1}=a^t$，满足 $\\delta_q(s),\\delta_q(t)\\mid p$ 且不同时为 $1$。我们回顾 $pq$ 情况以及其他形如“不同的阶为 $q$ 的 $s$ 对应群都同构”的证明，它们的思路就是，将生成元换成 $b^?$ 使 $b^?ab^{-?}=a^{s_0}$，就是所有 $s$ 是等价的，所以同构。那 $\\Z_p^2$ 的情况也可以类似地构造——设某个 $p$ 次单位根是 $s_0$。如果 $s,t$ 有个是 $1$ 那让另一个变成 $s_0$ 就行，否则设 $s^i\\equiv t^{-1},t^j\\equiv s_0$，这样将生成元换为 $b^\\prime =b^ic,c^\\prime =c^j$ 就可以了，显然 $b^\\prime ,c^\\prime $ 可以反过来表示 $b,c$。于是无论怎么样都可以变成 $b^\\prime a{b^\\prime }^{-1}=a,c^\\prime a{c^\\prime }^{-1}=a^{s_0}$，也就是唯一。 我们总结一下：\n情况 条件 非阿贝尔群 $n$ 例 平凡 $p\\nmid(q-1)\\land q\\nmid(p^2-1)$ 无 $45,99,153,175,207$ $12$ $n=12$ $3$ 个：$\\Z_3\\rtimes\\Z_4$、$\\Z_3\\rtimes\\Z_2^2$、$\\Z_2^2\\rtimes\\Z_3$ $12$ $p$ 小 $p\\parallel(q-1)\\land n\\ne 12$ $2$ 个：$\\Z_q\\rtimes\\Z_{p^2}$、$\\Z_q\\rtimes\\Z_p^2$ $28,44,63,76,92$ $p^2$ 小 $p^2\\mid(q-1)$ $3$ 个：同上、$\\Z_q\\rtimes_{\\varphi^\\prime }\\Z_{p^2}$ $20,52,68,116,148$ $2p^2$ $q=2$ $3$ 个：$\\Z_{p^2}\\rtimes\\Z_2$、$\\Z_p^2\\rtimes_{\\varphi,\\varphi^\\prime }\\Z_2$ $18,50,98,242,338$ $p+1$ $q\\mid(p+1)\\land q\\ne2\\land n\\ne 12$ $1$ 个：$\\Z_p^2\\rtimes\\Z_q$ $75,363,867$ 变态 $q\\mid(p-1)\\land q\\ne 2$ $(q+5)/2$ 个：$\\Z_{p^2}\\rtimes\\Z_q$、$\\Z_p^2\\rtimes_{\\varphi_i}\\Z_q$ $147,507,605$ 注意 $\\Z_n\\rtimes\\Z_2^2\\cong\\Z_{2n}\\rtimes\\Z_2\\cong D_{2n}$。其余还有某些半直积可以写成循环群与二面体群/置换群/亚循环群的直积，但我不是很清楚是否有通用的转换方法。\n$pqr\\;(p\u0026lt;q\u0026lt;r)$。首先进行以下简单推理：$n_r\\in\\set{1,pq}$ 且 $n_q\\in\\set{1,r,pr}$。若 $n_r=pq$ 且 $n_q\\ne 1$，则 $G$ 中有 $pq(r-1)$ 个阶为 $r$ 的元素，以及 $r(q-1)$ 个阶为 $q$ 的元素，共 $pqr-pq+rq-r=pqr+(r-p)(q-1)-p\u0026gt;pqr$ 个，矛盾。故 $n_r=1\\lor n_q=1$，无论哪个正规，取 $G$ 关于其的商群，商群中一定有 Sylow 另一个质数 子群，取出其对应原群中的部分，即得一 $qr$ 阶正规子群 $H$。同时，由于 $H$ 有正规 Sylow $r$ 子群，故该子群在 $G$ 中也正规。\n如果 $H\\cong\\Z_{qr}$，那就较简单：考虑 $\\varphi:\\Z_p\\to\\aut H\\cong\\Z_{q-1}\\times\\Z_{r-1}$，如果 $p\\nmid(q-1)(r-1)$ 就只有阿贝尔群，如果 $p\\mid(q-1)$ 与 $p\\mid(r-1)$ 其一成立，就有一种，否则模 $q$ 和 $r$ 下的 $p$ 次单位根都可以取，可以固定其中一个单位根，有 $p+1$ 种（$(0,1)$、$(1,i)$）。\n$q\\mid(r-1)$ 时能不能搞些别的？如果 $p\\nmid(q-1)\\land p\\nmid(r-1)$，则 $G/\\syl_r(G)$ 是个循环群，有 $p$ 阶正规子群，于是就有 $pr$ 阶循环正规子群，然后 $\\Z_q$ 对它共轭即可，有一种。注意如果按下面的方式分析，得出的群是和这里同构的。\n其他情况就要直面 $\\varphi:\\Z_p\\to\\aut(\\Z_r\\rtimes\\Z_q)$ 了。设 $\\Z_r\\rtimes\\Z_q$ 中 $bab^{-1}=a^s\\;(s^q\\equiv1\\pmod r\\land s\\not\\equiv 1)$，其中 $|a|=r$。由于 $\\lang a\\rang$ 正规，故 $\\varphi(c)(a)=a^t\\;(t^p\\equiv1\\pmod r)$。在 $p\\nmid(r-1)\\land p\\mid(q-1)$ 的时候，$\\varphi(\\forall)(a)=a$。设 $\\varphi(c)(b)=a^xb^y$，则 $$ \\varphi(c)(ba)=\\varphi(c)(a^sb)\\Rightarrow a^{x+s^y}b^y=a^{s+x}b^y\\Rightarrow s^{y-1}\\equiv1\\pmod r\\Rightarrow q\\mid(y-1)\\Rightarrow y=1\\\\ \\varphi(c^p)(b)=b\\Rightarrow a^{px}b=b\\Rightarrow x=0 $$ 于是 $\\varphi(c)=\\iota$，即 $(\\Z_r\\rtimes\\Z_q)\\times\\Z_p$ 唯一。\n$p\\mid(r-1)$ 时，若 $t\\ne 1$，则 $$ \\varphi(c)(ba)=\\varphi(c)(a^sb)\\Rightarrow a^{x+s^yt}b^y=a^{st+x}b^y\\Rightarrow y=1\\\\ \\varphi(c^p)(b)=b\\Rightarrow a^{\\frac{t^p-1}{t-1}x}b=b\\Leftrightarrow\\top $$ 所以其实跟前面没什么两样，就是 $t,x$ 都有多种取法。首先 $x=0$ 是一种特殊的。其他情况，而考虑变换生成元：$a$ 变成 $a^\\alpha$，$b$ 变成 $b^\\beta$，$c$ 变成 $c^\\gamma$，则 $$ b^\\beta a^\\alpha b^{-\\beta}=(a^\\alpha)^{s^\\beta}\\\\ \\varphi(c^\\gamma)(a^\\alpha)=(a^\\alpha)^{t^\\gamma}\\\\ \\varphi(c^\\gamma)(b^\\beta)=a^{\\frac{t^\\gamma-1}{t-1}\\frac{s^\\beta-1}{s-1}x}b^\\beta $$ 容易发现是可以都变成某组 $(a^{s_0},a^{t_0},ab)$ 的。\n总结一下：\n$[q\\mid(r-1)]$ $[p\\mid(r-1)]$ $[p\\mid(q-1)]$ 非阿贝尔群 $n$ 例 $0$ $0$ $0$ 无 $255,345,435,455,561$ $0$ $0$ $1$ $1$ 个：$\\Z_{qr}\\rtimes\\Z_p$ $231,357,483,663,715$ $0$ $1$ $0$ $1$ 个：$\\Z_{qr}\\rtimes\\Z_p$ $105,195,285,385,429$ $0$ $1$ $1$ $p+1$ 个：$\\Z_{qr}\\rtimes_{\\varphi_i}\\Z_p$ $30,66,70,102,130$ $1$ $0$ $0$ $1$ 个：$\\Z_{pr}\\rtimes\\Z_q$ $165,615,759$ $1$ $0$ $1$ $2$ 个：$\\Z_{qr}\\rtimes\\Z_p$、$(\\Z_r\\rtimes\\Z_q)\\times\\Z_p$ $609,1265,1491$ $1$ $1$ $0$ $3$ 个：$\\Z_{qr}\\rtimes\\Z_p$、$(\\Z_r\\rtimes\\Z_q)\\times\\Z_p$、$(\\Z_r\\rtimes\\Z_q)\\rtimes\\Z_p$ $465,915,2211$ $1$ $1$ $1$ $p+3$ 个：$\\Z_{qr}\\rtimes_{\\varphi_i}\\Z_p$、$(\\Z_r\\rtimes\\Z_q)\\times\\Z_p$、$(\\Z_r\\rtimes\\Z_q)\\rtimes\\Z_p$ $42,78,110,114,903$ $16$。主要有两个思路：分析 $8$ 阶正规子群、分析中心大小。这里考虑前一种。\n首先我们说明非阿贝尔的 $G$ 一定有 $\\Z_8$ 或 $\\Z_4\\times\\Z_2$ 作为子群，这里的推导很别扭：可以立即假设 $G$ 中元素的阶都 $\\le 4$ 且至少有一个是 $4$，然后考虑 $C(G)$，如果大小是 $4$，那么 $G/C(G)\\cong\\Z_2^2$（否则阿贝尔），即得；否则 $C(G)=\\set{1,c}$，若有 $|x|=4,\\lang x\\rang\\cap C(G)=\\set{e}$，那么即得，否则所有 $x^2=c\\or e$，那么 $G/C(G)\\cong\\Z_2^3$，那么一个 $x$ 的共轭就只可能在 $xC(G)$ 内（否则 $G/C(G)$ 不是阿贝尔），那么 $C_G(x)=8$，那么可以找到另一个 $y$，使 $x,y,z$ 交换且 $y^2=z\\or e$，都对应 $\\Z_4\\times\\Z_2$。\n若 $\\Z_8\\norm G$，同样类似于 $p^3$ 的情况，可以找到外面一个 $2$ 阶元 $b$，然后分析自同构，$bab^{-1}=a^{1\\or3\\or5\\or7}$，并且这四种互不同构。\n否则，考虑 $\\Z_4\\times\\Z_2$ 的自同构（也可以用矩阵描述，但这个矩阵里元素的取值范围不同，不容易分析，事实上 $\\aut(\\Z_4\\times\\Z_2)\\cong D_4$），设它的生成元为 $a,b$，$a\\mapsto a^1\\or a^3\\or a^1b\\or a^3b$，$b\\mapsto b\\or a^2b$（如果 $b\\mapsto a^2$ 那就 $f(a)^2=f(b)^2$ 不对了）。在这些自同构中，$(a,b)\\mapsto(ab,b)$ 和 $(a,b)\\mapsto(a^3b,b)$ 共轭，$(a,b)\\mapsto(a,a^2b)$ 和 $(a,b)\\mapsto(a^3,a^2b)$ 共轭，$(a,b)\\mapsto(ab,a^2b)$ 和 $(a,b)\\mapsto(a^3b,a^2b)$ 共轭。\n现在找另一个元素 $c$。最后一个共轭类是一定不行的，因为无论 $|c|=2\\or4$，$c^2$ 都在正规子群里，所以自同构的阶得 $\\le2$。若 $|c|=2$，则四种互不同构；若 $|c|=4$，分类讨论：\n$(a,b)\\mapsto(a^3,b)$ $(a,b)\\mapsto(ab,b)$ $(a,b)\\mapsto(a,a^2b)$ $c^2=a^2$ $\\lang a,b,c\\mid a^4=b^2=[a,b]=[b,c]=e,c^2=a^2,ca=a^{-1}c\\rang$ $\\lang ac,a\\mid(ac)^4=a^4=e,a(ac)=(ac)^{-1}a\\rang$ $|bc|=2$ $c^2=b$ $\\lang a,c\\mid a^4=c^4=e,ca=a^{-1}c\\rang$ $(ac)^2=a^2$ 不可能 $c^2=a^2b$ $\\lang a,c\\mid a^4=c^4=e,ca=a^{-1}c\\rang$ $|ac|=2$ 不可能 所以实际只有两类，至于如何发现第二类（$(1,2),(2,1),(3,1)$）这些情况同构的，只能说实在是注意力惊人，这个表我也是对着论文搞的。最后只需验证这两类无 $8$ 阶元，有 $3$ 个 $2$ 阶元，且不同构即可。\n总结一下，阿贝尔 $5$ 个，有 $8$ 阶元时 $3$ 个，无 $8$ 阶元时 $4+2=6$ 个，共 $14$ 个。\n参考：本方法：http://buzzard.ups.edu/courses/2015spring/projects/whitcomb-groups-16-ups-434-2015.pdf、https://www.researchgate.net/publication/259147732_The_Groups_of_Order_Sixteen_Made_Easy。另一类方法：http://buzzard.ups.edu/courses/2012spring/projects/clausen-groups-16-ups-434-2012.pdf、https://files.eric.ed.gov/fulltext/EJ1054466.pdf、https://hal.science/cel-01841041/document。\n$p^4$。思路是用矩阵分析 $p^3$ 阶正规子群的自同构，太复杂了，见 https://arxiv.org/pdf/1611.00461、https://future-in-tech.net/17.4/R-Hasanat1.pdf。\n$24$。如果 $n_3=1$，设 $\\aut\\Z_3=\\set{1,f}$。考虑任一 Sylow $2$ 子群（多个 Sylow 子群必同构）：\n$\\Z_8$。只有一种，即 $a\\mapsto f$。 $\\Z_4\\times\\Z_2$。两种，$(a,b)\\mapsto(f,1)\\or{}(1,f)$。$(a,b)\\mapsto(f,f)$ 转 $(ab,b)\\mapsto(1,f)$ 与后者同构。 $\\Z_2^3$。将两个 $\\mapsto f$ 的元素相乘作为生成元，这样来变换，可统一归为 $(a,b,c)\\mapsto(f,1,1)$。 $D_4$。两种，$(a,b)\\mapsto(f,1)\\or{}(1,f)$。$(a,b)\\mapsto(f,f)$ 转 $(a,ab)\\mapsto(f,1)$ 与前者同构。 $Q_8$。类似情况 3 只有一种。 否则 $n_3=4$，考虑 $G$ 共轭作用在它上面形成的 $\\varphi:G\\to S_4$ 同态，讨论 $\\ker\\varphi$。由于每个 Sylow $3$ 子群的正规化子均是 $6$ 个，故 $|\\ker\\varphi|\\mid6$。若 $|\\ker\\varphi|\\in\\set{3,6}$，则 $G$ 有大小为 $3$ 的正规子群 （$6$ 的情况取出唯一大小为 $3$ 的子群 $\\set{e,a^2,a^4}$，由于共轭后 $3$ 阶子群，所以正规。这里的正规传递性是个例），矛盾。若 $|\\ker\\varphi|=1$，则 $G\\cong S_4$。最后 $|\\ker\\varphi|=2$。这种情况下 $G/\\ker\\varphi\\cong A_4$，由于 $\\Z_2^2\\norm A_4$，找到原像，即 $G$ 有正规 Sylow $2$ 子群。讨论它：\n$\\Z_8$。无 $3$ 阶元。 $\\Z_4\\times\\Z_2$。在 $|G|=16$ 里讨论过它的自同构为 $D_4$，没有 $3$ 阶元。 $\\Z_2^3$。很棒的一点是，$3\\parallel168=|\\mathrm{GL}_3(\\F_2)|$，于是共轭类唯一。这种情况其实是 $A_4\\times\\Z_2$。 $D_4$。事实上 $\\aut D_4也\\cong D_4$，所以也不行。 $Q_8$。事实上 $\\aut Q_8\\cong S_4$。$3$ 阶元是所有 $3$ 循环，所以唯一。 上面所有一方正规的情况，另一方必不正规（否则两个正规之间可以交换，直接直积了）。最后总结得到，阿贝尔 $3$ 个，非阿贝尔直积 $2$ 个，Sylow $3$ 正规 $7$ 个，$S_4$ $1$ 个，Sylow $8$ 正规 $2$ 个，共 $15$ 个。\n参考：https://www.youtube.com/watch?v=6TWuo2NO8vg、http://www.brahmanandcollege.org.in/pg_math/Modern%20Algebra-01.pdf。\n$56$。如果 $n_7=1$，则分讨跟 $|G|=24$ 一样（因为 $\\aut\\Z_7$ 除了一个 $2$ 阶元以外，其余都是 $3\\or6$ 阶的，都不能碰）。否则就有 $48$ 个 $7$ 阶元，剩余 $8$ 个元素必形成一正规 Sylow $2$ 子群，这里就比楼上简单了。唯一的可能就是 $\\Z_2^3$，同样 $7\\parallel168$，所以唯一，共 $13$ 个。\n$8p\\;(p\\ne3,7)$。这种情况必有 $n_p=1$。\n$40$ 的时候 $\\aut\\Z_5\\cong\\Z_4$，讨论任一 Sylow $2$：\n$\\Z_8$。$a\\mapsto f^{1\\or 2}$ 两种。 $\\Z_4\\times\\Z_2$。$(a,b)\\mapsto(1,f^2)\\or{}(f^2,1)\\or{}(f,1)$。$(f^2,f^2)$ 同 $24$，$(f,f^2)$ 转 $(a,a^2b)\\mapsto(f,1)$。 $\\Z_2^3$。一种。 $D_4$。同 $24$。$(a,b)\\mapsto(f,?)$ 之类的情况会导致 $\\varphi(ba)\\ne\\varphi(a^{-1}b)$，故不行。 $Q_8$。同 $24$。$(a,b)\\mapsto(f,?)$（$a,b$ 即 $i,j$）之类的情况会导致 $\\varphi(a^2)\\ne\\varphi(b^2)\\or\\varphi((ab)^2)$，故不行。 总的就是 $5+2+3+1+2+1=14$ 种。$4\\parallel(p-1)$ 的情况都是 $14$ 种。\n以 $136$ 为首的 $8\\mid(p-1)$ 的情况就是多了个 $\\Z_8$ 时 $|\\varphi(a)|=8$ 的情况，共 $15$ 种。\n以 $88$ 为首的 $2\\parallel(p-1)$ 的情况是 $5+1+2+1+2+1=12$。\n总结一下：\n$p$ $2$ $3$ $7$ $v_2(p-1)=1$ $v_2(p-1)=2$ $v_2(p-1)\\ge3$ $a(8p)$ $14$ $15$ $13$ $12$ $14$ $15$ 关于 $2^kp$ 见 https://zhuanlan.zhihu.com/p/69254703。\n$36$。首先我们需要证明 $n_2=1\\lor n_3=1$。看起来简单的东西推导很变态，我找了一堆证明（https://math.stackexchange.com/questions/3290888/if-g-36-then-g-has-either-a-normal-2-sylow-or-a-normal-3-sylow、https://math.stackexchange.com/questions/2918359/a-group-of-order-36-has-either-a-normal-sylow-2-subgroup-or-a-normal-sylow、https://math.berkeley.edu/~wodzicki/257/G36.pdf、https://max.book118.com/html/2017/0806/126207403.shtm），没一个少于一页的。\n如果 $G$ 有 $4$ 个 Sylow $3$ 子群 $X_{1\\sim 4}$，那么考虑 $G$ 共轭作用在它们上，形成一个 $\\varphi:G\\to S_4$ 的同态。$|\\im \\varphi|\\mid\\gcd(36,24)=12$，同时由于 $\\forall i,\\exists g,gX_1g^{-1}=X_i$，故 $\\im\\varphi$ 中每个 $\\sigma(1)=1$ 的元素都与 $\\sigma(1)=2,3,4$ 元素各一个对应，故 $4\\mid|\\im\\varphi|$，故 $|\\im\\varphi|\\in\\set{4,12}$。若为 $4$，则 $|\\ker\\varphi|=9$ 矛盾；否则 $G/\\ker\\varphi\\cong\\im\\varphi=A_4$，且 $\\ker\\varphi$ 是一个 $3$ 阶正规子群。① 这说明它是所有 Sylow $3$ 子群的子群，而 $9$ 阶群一定是阿贝尔群，故与 $\\ker\\varphi$ 的元素的中心化子至少为 $27$，于是 $\\ker\\varphi\\sub C(G)$。② 如果 $n_2\u0026gt;1$，比如有 $Y_1,Y_2$，它们显然与 $\\ker\\varphi$ 交为 $\\set{e}$，故它们对应到 $G/\\ker\\varphi$ 上也是 Sylow $2$ 子群，而 $A_4$ 的 Sylow $2$ 子群是唯一的 $\\Z_2^2$，故 $Y_1\\ker\\varphi=Y_2\\ker\\varphi$。由 ①，它们都 $\\cong\\Z_3\\times\\Z_2^2$ 阿贝尔群，于是 $Y_1=Y_2$，因此 $n_2=1$。\n正规 Sylow $3$ 子群 $\\Z_9$，Sylow $2$ 子群 $\\Z_4$。由于 $\\varphi(9)=6$（这个 $\\varphi$ 是欧拉函数），故只有一种。 正规 Sylow $3$ 子群 $\\Z_9$，Sylow $2$ 子群 $\\Z_2^2$。同 6.4.2，一种。 正规 Sylow $3$ 子群 $\\Z_3^2$，Sylow $2$ 子群 $\\Z_4$。$\\mathrm{GL}_2(\\F_3)$ 在相似意义下有两个二阶元 $\\begin{bmatrix}-1\u0026amp;0\\\\ 0\u0026amp;\\pm1\\end{bmatrix}$，一个四阶元 $\\begin{bmatrix}0\u0026amp;1\\\\ -1\u0026amp;0\\end{bmatrix}$，因此有三种。 正规 Sylow $3$ 子群 $\\Z_3^2$，Sylow $2$ 子群 $\\Z_2^2$。记 $\\Z_2^2$ 的两个生成元为 $a,b$，如果 $\\varphi(a)\\ne\\varphi(b)$，则 $\\im\\varphi\\cong\\Z_2^2$，一种。否则可以认为 $\\varphi(b)=1$（不是的话可以把 $b$ 换成 $ab$），$\\varphi(a)$ 两种。共三种。 正规 Sylow $2$ 子群 $\\Z_4$，Sylow $3$ 子群 $\\Z_9$。不行。 正规 Sylow $2$ 子群 $\\Z_4$，Sylow $3$ 子群 $\\Z_3^2$。不行。 正规 Sylow $2$ 子群 $\\Z_2^2$，Sylow $3$ 子群 $\\Z_9$。事实上 $\\aut\\Z_2\\cong\\mathrm{GL}_2(\\F_2)\\cong S_3$，有唯一 Sylow $3$ 子群，一种。 正规 Sylow $2$ 子群 $\\Z_2^2$，Sylow $3$ 子群 $\\Z_3^2$。类似情况 2 也可以归为 $(1,f)$。一种。 总共 $2^2+1+1+3+3+0+0+1+1=14$ 种（第一个加数对应阿贝尔，后同）。\n这里关于 $\\aut\\Z_3^2$ 的同构的共轭类是参照 https://groupprops.subwiki.org/wiki/General_linear_group:GL(2,3)，我不大会证这些，可能以后深入学线代会再补充。\n$4p^2\\;(p\\ne3)$。这时必有 $n_p=1$，但同样由于我不会分析 $\\aut\\Z_p^2$ 而且网上没有按这种思路分析的资料所以这里就留坑了。这里先给出结论：$p=4k+1$ 时有 $16$ 个，$p=4k+3$ 时有 $12$ 个。见 https://xueshu.baidu.com/usercenter/paper/show?paperid=1m4n0tf0y90w0vh0py530vs0ax491706。注意 B 站有个讲 $10$、$100$、$1000$ 阶群分类的视频，讲得不完整，最难的部分整个略掉了。\n$2p^3$。也是直接得到正规，但是 $p^3$ 阶群的自同构难以分析。https://www.zhihu.com/question/637163090/answer/3346156282 这里是一个不完整的分析，问题和那个 B 站的视频类似，都是共轭设得不全。\n$60$。我们首先希望 $n_5=1$。如果不是，那么 $n_5=6$，接下来证明 $G$ 是单群。如果 $G$ 有正规子群 $N$，如果 $5\\mid|N|$，那么$|N|=10\\or15\\or20\\or30$。前三种情况显然有正规 Sylow $5$ 子群，$30$ 的情况根据 $|G|=pqr$ 的分析也有正规 Sylow $5$，于是它也是 $G$ 的正规 Sylow $5$。否则 $|G/N|=5\\or10\\or15\\or20\\or30$，后四种情况可以乘回 $N$ 得到 $5\\mid|N^\\prime |$，第一种情况 $|N|=12$，它有正规 Sylow $2\\or 3$，于是 $G$ 也有，归到前面。\n而 $60$ 阶单群只可能是 $A_5$。我们先证明它有 $12$ 阶子群。$n_2=3\\or5\\or15$，若为 $3$，则每个的正规化子有 $20$ 个，说明 $G$ 有 $20$ 阶子群，则 $G$ 作用在该子群的陪集上时，形成一个 $\\varphi:G\\to S_3$，进而 $\\ker\\varphi$ 是 $G$ 的正规子群；若为 $15$，那么如果这些子群两两只有平凡交，则 $2,4$ 阶元有 $15\\times3=45$ 个，而 $5$ 阶元有 $6\\times4=24$ 个，矛盾。因此存在两个 Sylow $2$ 子群 $X_1,X_2$，$X_1\\cap X_2=\\set{e,x}$。由于 $4$ 阶群必阿贝尔，故 $X_1,X_2\\sub C_G(x)$，故 $C_G(x)=12\\or20\\or60$，后两种都不可能。现在 $G$ 有 $12$ 阶子群了，考虑作用在它的陪集上，形成 $\\psi:G\\to S_5$，且单性故 $\\ker\\psi$ 平凡，故 $G\\cong\\im\\psi\\cong A_5$，$n_2=5$ 的情况直接跳到这里。\n现在 $G$ 有正规 Sylow $5$ 子群 $H$，讨论 $n_3$。$G$ 的 Sylow $3$ 子群与 $G/H$ 的 Sylow $3$ 子群一一对应（正过来直接取，反过来是因为可以对应 $15$ 阶子群 $\\cong\\Z_{15}$ 从而有唯一 Sylow $3$ 子群），因此 $n_3\\ne10$。如果 $n_3=4$，那么它们各自乘 $H$ 形成四个同构于 $\\Z_{15}$ 的，两两交于 $H$ 的群，这意味着 $|N_G(H)|\\ge 45$ 从而 $H\\sub C(G)$，这大大简化了讨论——$G/H$ 的 Sylow $3$ 子群不正规，这意味着它 $\\cong A_4$，类似于这段开头，$G/H$ 的唯一 Sylow $2$ 子群与 $G$ 的唯一 Sylow $2$ 子群对应（注意这里的对应依赖于 $H\\sub C(G)$ 因为不然 $20$ 阶群的讨论就爆炸了），于是将这个正规 Sylow $2$ 子群与 Sylow $3$ 子群相乘，立即得到同构于 $A_4$ 的 $12$ 阶子群，从而 $G\\cong\\Z_5\\times A_4$。PS：这里搞得这么麻烦的原因是，如果直接搞出正规子群 $\\Z_5\\times\\Z_2^2$，自同构就很难讨论了。\n如果 $n_3=1$，那么只需考虑 $\\Z_4\\to\\aut\\Z_{15}$ 与 $\\Z_2^2\\to\\aut\\Z_{15}$，显然分别有五、四个。\n总共 $2+1+1+5+4=13$ 种。\n参考：https://www.math.utoronto.ca/alfonso/347/Groups60.pdf、https://math.stackexchange.com/questions/3068904/group-of-order-60、https://math.stackexchange.com/questions/1121248/classifying-groups-of-order-60、https://math.stackexchange.com/questions/360816/about-the-proof-that-a-simple-group-of-order-60-is-isomorphic-to-a5、https://epgp.inflibnet.ac.in/epgpdata/uploads/epgp_content/S000025MS/P001533/M016962/ET/1468557941E-textofChapter3Module4.pdf。\n$90$。核心是说明 $G$ 有 $45$ 阶子群。若 $n_5=1$，则 $18$ 阶商群的 $n_3=1$，即得。否则，如果 $n_3\u0026gt;1$，那么我们说这些子群 $X_{1\\sim 10}$ 不可能两两只有平凡交，因为反之则 $3$ 与 $9$ 阶元有 $80$ 个，但 $5$ 阶元有 $24$ 个。现在找到 $X_i\\cap X_j=H\\ne\\set{e}$，考虑其正规化子数量： $|N_G(H)|\\ge|X_1X_2|\\ge27$。同时 $X_i\u0026lt;N_G(H)$ 故 $|N_G(H)|=45\\or90$。后者即 $H\\norm G$，由于 $G/H$ 这个 $30$ 阶群有 $15$ 阶子群，所以也得到 $45$ 阶。而 $45$ 阶群一定是阿贝尔群。\n那现在只需考虑 $\\Z_2\\to\\aut\\Z_{45}$ 与 $\\Z_2\\to\\aut(\\Z_3\\times\\Z_{15})$。前者有三种。后者，由于正规子群在自同构下不动，故 $\\aut(\\Z_3\\times\\Z_{15})\\cong\\aut\\Z_3^2\\times\\aut\\Z_5$，$\\mathrm{GL_2}(\\F_3)$ 的二阶共轭类有两种，故这个是 $3\\times2-1=5$ 种。共 $2+3+5=10$ 种。\n参考：https://math.stackexchange.com/questions/360790/classifying-groups-of-order-90、https://math.stackexchange.com/questions/146687/how-do-i-show-that-every-group-of-order-90-is-not-simple。\n$132$。首先我们说明 $n_{11}=1$。若 $n_{11}=12$，若 $n_3=1$，则可得到商群的正规 Sylow $11$，然后得到 $G$ 的 $33$ 阶正规子群，由于 $33$ 阶群只能是 $\\Z_{33}$，故 $11$ 阶正规；若 $n_3\u0026gt;1$，它不可能是 $22$，只可能是 $4$。于是有 $G$ 到 $S_4$ 的同态，其像大小整除 $12$ 且是 $4$ 的倍数（同 $|G|=36$ 第二段的分析），因此只可能是 $4\\or 12$，对应核都说明 $11$ 阶正规。\n现在 $n_{11}=1$，这里的分析跟 $|G|=60$ 完全一样：由 $n_3\u0026gt;1$ 可得 $\\Z_{11}\\times A_4$，由 $n_3=1$ 可得正规子群 $\\Z_{33}$，$\\Z_4$ 和 $\\Z_2^2$ 分别对应 $3$ 和 $4$ 个。共 $2+1+3+4=10$ 种。\n$135$。立即得 $45$ 阶正规子群，考虑 $\\Z_3$ 到 $\\aut\\Z_{45}$ 和 $\\aut(\\Z_3\\times\\Z_{15})$。根据 $|G|=36$ 最后的链接，$\\mathrm{GL}_2(\\F_3)$ 有唯一三阶共轭类，故总共 $3+1+1=5$ 种。\n$140$。立即得 $35$ 阶正规，考虑 $\\Z_4$ 和 $\\Z_2^2$ 到 $\\aut\\Z_{35}$，和 $|G|=60$ 一样。共 $2+5+4=11$ 种。\n$198$。立即得 $99$ 阶正规，考虑 $\\Z_2$ 到 $\\aut\\Z_{99}$ 和 $\\aut(\\Z_3\\times\\Z_{33})$。后者是 $3\\times2-1=5$ 种，共 $2+3+5=10$ 种。\n如果说下一步要继续分析的话，$4pq$、$p^2q^2$、$p^2qr$ 可能是相对可做的，但目前感觉都很难了。以下是 $200$ 以内我不会分析的情况：\n$n$ $a(n)$ 情况 $32$ $51$ 变态 $48$ $52$ 变态 $54$ $15$ $2p^3$ $64$ $267$ 变态 $72$ $50$ 变态 $80$ $52$ 变态，$n_2=1\\or n_5=1$ 然后不会 $81$ $15$ $p^4$ $96$ $231$ 变态 $100$ $100$ $4p^2$ $108$ $45$ 变态 $112$ $43$ 变态 $120$ $47$ 变态，https://www.youtube.com/watch?v=t5YcYuDl0hk $126$ $16$ $n_7=1$ 但 $63$ 阶群自同构不好分析 $128$ $2328$ 变态 $144$ $197$ 变态 $150$ $13$ $n_5=1$ 但 $75$ 阶群自同构不好分析 $156$ $18$ $n_{13}=1$ 但 $39$ 阶群不好分析 $160$ $238$ 变态 $162$ $55$ 变态 $168$ $57$ 变态，不过可以了解一下单群 $176$ $42$ 变态 $180$ $37$ 变态 $189$ $13$ $n_7=1$ 但 $63$ 阶群自同构不好分析 $192$ $1543$ 变态 $196$ $12$ $4p^2$ $200$ $52$ 变态 综合的参考资料：\n《有限群构造》（张远达） 《有限群构造新论》（陈松良） https://www.math.auckland.ac.nz/~obrien/research/gnu.pdf https://link.springer.com/article/10.1007/BF01443651 https://groupprops.subwiki.org/ 13. 可解群 大纲 幂零群的定义与性质：直积幂零、正规化子严格包含、幂零群的等价刻画。 换位子群、导子群、特征子群、全不变子群、极小正规子群的定义，特征子群的正规传递性。 可解群的定义与性质：与幂零群的关系、子群与同态像可解、正规子群+商群可解、极小正规子群的结构、Hall 定理。 笔记 幂零群的等价定义是，存在一个从 $\\set{e}$ 到 $G$ 的列 $\\set{G_i}$，只要求 $G_{i+1}/G_i\\sub C(G/G_i)$ 即可。证明考虑归纳证 $G_i\\sub C_i(G)$，这里的核心思想是，$G$ 的两个正规子群 $K\\sub H$ 必满足 $\\pi_K^{-1}(C(G/K))\\sub\\pi_H^{-1}(C(G/H))$。看起来简单的东西设得不好也会证不出来。一个好搞的形式是 $[x,y]\\in K\\Rightarrow[x,y]\\in H$。\n幂零群的子群和同态像也是幂零群。详见 https://math.stackexchange.com/questions/1571815/need-help-proving-any-subgroup-and-quotient-of-a-nilpotent-group-is-nilpotent。这类问题证明思路都是类似的，就是选好归纳假设，然后分析同态，利用同构第二、四定理即可。反倒是可解群证明这类东西容易些，因为导列就是不断选子群。\n可解群的等价定义是，存在一个从 $\\set{e}$ 到 $G$ 的列 $\\set{G_i}$，只要求 $G_i\\norm G_{i+1}$ 且 $G_{i+1}/G_i$ 阿贝尔即可（注意换位子群是最小（其他都包含它）的这样的 $G_i$，这也是求一个群的导列的方法）。证明考虑归纳证 $G^{(i)}\\sub G_{n-i}$，知道了换位子群最小这不就是显然的吗……\n注意极小正规子群不一定唯一：https://math.stackexchange.com/questions/1402526/smallest-normal-subgroup-and-minimal-normal-subgroup-whats-the-difference。\n幂零群结构定理证明的思路并不难，核心是找到一个矛盾：Sylow $p$ 子群的正规化子等于其正规化子的正规化子，以及幂零群中，正规化子是严格包含的。然后就是直积相关的简单东西。\nHall 定理实在无法理解是怎么想到的，所以只能把思路记下来，这下真得死记硬背了。\n存在一个正规子群 $H$，阶不被 $n$ 整除。设阶与 $m,n$ 分别有公因子 $m_1,n_1$。(i) $G/H$ 里找 $m/m_1$ 阶，乘回 $H$ 变 $mn_1$，再找 $m$。(ii) 俩 $m$ 阶的 $B,C$，$|BH|=|CH|=mn_1$，$BH/H$ 与 $CH/H$ 在 $G/H$ 中共轭，于是 $BH$ 与 $CH$ 共轭，于是 $B$ 的共轭与 $C$ 在 $CH$ 中共轭。(iii) $k$ 阶 $D$，$G/H$ 里找包含 $DH/H$ 的，乘回 $H$ 变 $mn_1$ 阶，再找 $m$。\n所有正规子群的阶都被 $n$ 整除。首先证明引理：可解群的极小正规子群为阿贝尔 $p$。$N^\\prime $ 是 $N$ 的正规子群且只能是平凡的（不能是 $N$ 不然就不可解了，事实上这是整个证明中唯一用到可解性的地方），于是 $N$ 阿贝尔，且不能再有真 Sylow 子群。这里值得注意的是，极小正规子群的定义是不存在原群的正规子群是其子群，而并非其本身是单群，因此上述证明中利用与极小矛盾时，至少得说明是特征子群。\n现找出 $G$ 的极小正规子群 $H$，由于 $H$ 是阿贝尔 $p$，故只能 $|H|=n$ 从而 $H$ 是 Sylow。(i) 看图：\n（黄色对应 $B$，蓝色对应 $D$，绿色对应 $DH\\cap M$，蓝灰色对应 $D$ 所属的 $m$ 阶）\n取出 $G/H$ 的极小正规子群 $K/H$，$S$ 为 $K$ 的 Sylow $q$，$S\\cap H=\\set{e}$。记 $N=N_K(S),M=N_G(S)$，$N$ 之于 $K$ 相当于 $M$ 之于 $G$（因为 $S$ 的共轭都在 $K$ 里面），所以只需证明 $N=S$ 即得 $|M|=m$。$N\\cap H$ 中元素与 $S,H$ 中元素均交换从而为 $K$ 的中心，而 $K$ 的中心作为 $G$ 的正规子群只能是 $\\set{e}$。(ii) $m$ 阶子群 $B$ 交 $H$ 于 $\\set{e}$，交 $K$ 于 Sylow $q$，故 $B\\cap K$ 与 $S$ 共轭，正规化子也共轭，$N_G(B)=B$。 (iii) $k$ 阶子群 $D$ 的 $DH$ 交 $M$ 于一 $k$ 阶子群与 $D$ 共轭，扩到 $m$ 阶。\n14. 正规列 大纲 正规列、次正规列、精细、合成列、可解列的定义及它们之间的关系。 Zassenhaus 引理、Schreier 精细定理、Hölder 定理。 笔记 理一下各种列之间的关系：首先讨论的所有列都是次正规列。次正规列有两种特殊情况：合成列和可解列。合成列是“划分最密”的。对于可解群，其导列是“划分最疏”的可解列，其可解列是所有“划分介于导列与合成列之间”的，其合成列具有因子为 $\\Z_p$ 的性质，从而也是可解列（能不用 Hölder 证吗？）。除了可解群的导列和幂零群的中心列以外，所有提到的列都不一定是正规列。例如，$S_4\\vartriangleright A_4\\vartriangleright K_4\\vartriangleright\\textcolor{red}{\\Z_2}\\vartriangleright\\set{e}$。\nZassenhaus 引理也是完全看不懂作者是怎么想的，只能提要一下证明策略：先证明诸如 $(A\\cap B^*)\\norm(A\\cap B)$ 之类的，再构造满同态证明 $$ \\frac{A^*(A\\cap B)}{A^*(A\\cap B^*)}\\cong\\frac{A\\cap B}{(A\\cap B^*)(A^*\\cap B)}\\cong\\frac{B^*(A\\cap B)}{B^*(A^*\\cap B)} $$ 后面两个定理反倒是很好理解的了。就是互相精细，然后合成列没法再精细了。\n注意无限群不一定有合成列，例如 $\\Z$ 没有，而 $A_\\infin$ 就有。\n漏掉的东西 群的扩张 群的可视化（格、环图等） 范畴论 与无限群相关的理论 $168$ 阶单群、有限单群分类、Lie 群 可解性相关进一步的内容，例如 Burnside 定理、Feit-Thompson 定理 ","date":"2024-07-25T00:00:00Z","image":"https://example.com/study/gtm73-group-theory/GTM73_hu02b0fe4ffa5d7b48ab95ff3f97244579_173421_120x120_fill_box_smart1_3.png","permalink":"https://example.com/study/gtm73-group-theory/","title":"抽代（群论部分）自学笔记"},{"content":"这是一篇摘抄笔记。\r考虑求 $(f\\circ g)^{(n)}$。\n我们看几个例子： $$ \\begin{align*} (f\\circ g)^\\prime\u0026amp;=f^\\prime\\circ g\\cdot g^\\prime\\\\ (f\\circ g)^{\\prime\\prime}\u0026amp;=f^{\\prime\\prime}\\circ g\\cdot {g^\\prime}^2+f\u0026rsquo;\\circ g\\cdot g^{\\prime\\prime}\\\\ (f\\circ g)^{\\prime\\prime\\prime}\u0026amp;=f^{\\prime\\prime\\prime}\\circ g\\cdot {g^\\prime}^3+3f^{\\prime\\prime}\\circ g\\cdot g^\\prime\\cdot g^{\\prime\\prime}+f^\\prime\\circ g\\cdot g^{\\prime\\prime\\prime} \\end{align*} $$ 注意到结果可以写成若干 $f^{(i)}\\circ g\\cdot h$ 的形式，其中 $h$ 是一些 $g^{(j)}$ 的积。\n考虑到 $(f^{(i)}\\circ g\\cdot h)^\\prime=f^{(i+1)}\\circ g\\cdot g^\\prime\\cdot h+f^{(i)}\\circ g\\cdot h^\\prime$，也就是说，有两种选择：\n将 $f$ 升一阶导并乘一个 $g^\\prime$； 导一下 $h$。 由于初始形式是 $f\\circ g\\cdot\\mathbf{1}$，故根据决策会得到形如这样的 $h$：一个长为 $n$ 的操作序列，每次要么乘上一个 $g\u0026rsquo;$，要么导一下。而根据乘法法则，每次求导就相当于选一个先前的 $g$ 升一阶导。\n于是 $h$ 的模型就变成这样：一个可重数集，每次要么往里面加一个 $1$，要么选一个 $+1$。然后最终的集合大小就是 $f$ 导的阶数。\n发现直接对操作序列计数不好算。现考虑对于一个最终的集合（也就是结果中的一项），求出其系数。对于一个集合，它的数首先可以任意排列，代表加入它的顺序，然后一个数 $x$ 的后面要有 $x-1$ 个选中它的求导。\n如果把加入顺序的排列和求导选择的排列分开来计数，不容易搞。如果放在一起，就可以理解成，对于一个数 $x$，有 $x$ 个同种颜色无法区分的球（最终放在最开头的就算加入，其余算求导）。然后所有相同的 $x$ 对应的颜色无标号。那么这时如果数 $x$ 有 $m_x$ 个（集合中数的和一定是 $n$），总的系数就是： $$ \\frac{n!}{\\displaystyle\\prod_{x=1}^nm_x!x!^{m_x}} $$ 于是我们就可以写出最终的表达式： $$ (f\\circ g)^{(n)}=\\sum_{\\sum i\\cdot m_i=n}\\frac{n!}{\\prod m_i!i!^{m_i}}f^{(\\sum m_i)}\\circ g\\cdot\\prod {g^{(i)}}^{m_i} $$ 其中 $\\sum$ 和 $\\prod$ 略去了 ${}_{i=1}^n$。\n这就是 Faà di Bruno\u0026rsquo;s formula。它可以直接解决倒数、除法的高阶导（反函数和参数方程可能需要递推）。\n这个公式可以导出几个比较平凡的结论，在解题时可以用： $$ (f(x+k))^{(n)}=f^{(n)}(x+k)\\\\ (f(kx))^{(n)}=k^nf^{(n)}(x)\\\\ \\left.\\left(f(x^k)\\right)^{(n)}\\right|_{x=0}=\\begin{cases}0,\u0026amp;k\\nmid n\\\\ \\dfrac{n!}{(n/k)!}f^{(n/k)}(0),\u0026amp;k\\mid n\\end{cases} $$ 最后一个可以直接展开级数证（很诡异），用于展开 $\\arcsin x$ 之类的。\n","date":"2024-03-27T00:00:00Z","permalink":"https://example.com/study/faa-di-bruno/","title":"复合函数高阶导的公式"},{"content":"这是一篇学习笔记。\r$\\gdef\\o{\\mathrm{o}}\\gdef\\d{\\mathrm{d}}\\gdef\\D{\\Delta}$\n微分的定义 对于一个在 $x_0$ 邻域内有定义的函数 $f$，如果： $$ f(x_0+\\D x)-f(x_0)=a\\D x+\\o(\\D x)\\quad(\\D x\\to 0) $$ 则称 $\\d f(x_0)=a\\D x=a\\d x$。\n同理对于任意的 $x$，可以记 $\\d y=\\d f(x)=a(x)\\D x=a(x)\\d x$。根据导数与微分的关系，$a(x)=f^\\prime(x)$。\n问题的开端 微分的最大好处在于它将求导这一求极限的动态过程转为了静态的，那么 $\\d y/\\d x$ 就可以视作除法了。那在证明复合函数和反函数的微分时，我们就会想：为什么不能直接进行分数操作呢？为什么高阶微分不具有形式不变性呢？\n对于式： $$ \\frac{\\d y}{\\d x}=\\frac{\\d y}{\\d u}\\frac{\\d u}{\\d x} $$ 如果要利用分数操作，大前提就是将 $\\d y$ 和 $\\d u$ 都写成关于 $\\d x$ 的形式。而在实际求时，我们时直接求出 $y$ 关于 $u$ 的函数的导数，这两者是不同的。如果直接这样证明，会导致循环论证。\n那问题就来了——这里的 $\\d y/\\d u$ 就必须作为一个整体，那就违背微分拆成除法的思想了啊？\n扩展定义 问题的核心出现在数学符号的模糊性上。注意到，在书中，微分是基于函数 $f$ 定义的，而函数只有唯一的自变量和因变量，因此 $\\d f(x)$ 只能写成关于 $\\d x$ 的表达式。但是当 $\\d y=\\d f(x)$ 后，我们就可以不知不觉地将 $y=f(x)=g(t)=\\cdots$ 写出多种表达式了。这时 $\\d y$ 就出现了歧义，因为按定义算它时，到底应该以那个函数关系为准呢？我们还没有说明微分各个函数是等价的，或者说，$y=f(x)=g(t)$ 并不能推出 $\\d f(x)=\\d g(t)$。\n为了处理这个问题，我进一步明确了一下定义。\n变量。$x,y,t$ 这些字母代表的就是变量，它们两两之间存在着唯一的关系，这些关系互不矛盾，可能可以用函数或隐函数描述，也可能需要用间接的变量描述或难以描述。如果一对变量 $u,v$ 之间不存在关系，那么强制认为 $\\d u=0\\d v,\\d v=0\\d u$；如果一个变量 $z$ 必须同时依赖于两个无关变量 $x,y$，那就是多元微分的事情了。总之，在一元函数微分这里，我们希望将所有涉及到的变量对应的高维坐标系画出来，所有符合关系的点应当形成若干曲线，即，可以将这些曲线拆成有限段，每一段曲线中，任何一维坐标的任何可能取值仅出现一次，或者至少要求所有变量能形成一个链式的关系，这样保证能归约到函数上的微分解决。 函数。单独拿出一个函数，也是用例如 $f,g$ 的字母描述。它描述的是一种关系，可以与一个变量进行运算，得到另一个变量，例如 $y=f(x)$。注意 $y$ 和 $f$ 不能视作同一个东西，$\\d f$ 是不合法的，$\\d f(x)$ 才合法。\n函数代入任何变量，得到的结果形式都是相同的；而对一个变量写出关于不同变量的表达式，这些表达式形式是不同的。如果要对变量代入值，必须要写成例如 $y|_{x=1}$。\n定义函数的复合：$(f\\circ g)(x)=f(g(x))$。优先级高于乘除。 微分。非原始形式的微分必须是“什么变量关于什么变量的微分”，记 $y$ 关于 $x$ 的微分为 $\\d_xy$，$y=f(x)$ 则 $\\d_xy$ 就对应书中的 $\\d f(x)$。其结果是一个变量乘上 $\\D x$。这个 $\\D x$ 是一个“形式”，可以理解成类似生成函数里的 $x$ 这样的一个东西，它就是标明微分类型的一个类似常数的东西。当然也可以从极小变化量角度理解，但是这里不管怎么小，都不能一阶近似，$\\d_xy$ 才能一阶近似。微分与微分的商就是一个变量。\n$\\D x$ 与 $x$ 无关，但 $\\d_xx=\\D x$，而 $\\d_xy=a\\D x=\\D y+\\o(\\D x)\\ne\\D y=\\d_yy$，也就是说 $\\d_xy$ 和 $\\d_yy$ 只差一个 $\\o(\\D x)$。这里的 $\\D y$ 既可以理解为 $f(x+\\D x)-f(x)$，也可以直接理解为 $y$ 的一个微小变化量。\n至于这里 $\\D x$ 这类的东西是不需要考虑“什么关于什么”的，只需要所有的变量的 $\\D *\\to 0$ 即可，而这由可导性保证。\n为了避免歧义，规定 $\\d_xuv=(\\d_xu)v$，$\\d_x\\frac uv=\\frac{\\d_xu}v$，$\\d_xu^2=(\\d_xu)^2$。也就是说如果要写在里面必须加括号。 导数。记 $y^\\prime_x=\\d_xy/\\d_xx$。 这样，上面那个式子会被写成： $$ \\frac{\\d_xy}{\\d_xx}=\\frac{\\d_uy}{\\d_uu}\\frac{\\d_xu}{\\d_xx} $$ 或 $y^\\prime_x=y^\\prime_uu^\\prime_x$，从而无法约分。\n推导 现在关于微分只有两样东西可以使用：\n通过定义得到某个 $\\d_x y$，以及将 $\\d_xy$ 反写回定义； $u=v\\Rightarrow\\d_xu=\\d_xv$。 根据这两样东西，可以推出：\n$\\d_x(u+v)=\\d_xu+\\d_xv$，$\\d_x(cu)=c\\d_xu$。证略。\n$\\d_x(uv)=v\\d_xu+u\\d_xv$。证： $$ \\begin{align*} \\d_x(uv)\u0026amp;=\\D(uv)+\\o(\\D x)\\\\ \u0026amp;=(u+\\D u)(v+\\D v)-uv+\\o(\\D x)\\\\ \u0026amp;=v\\D u+u\\D v+\\D u\\D v+\\o(\\D x)\\\\ \u0026amp;=v(\\d_xu+\\o(\\D x))+u(\\d_xv+\\o(\\D x))+(\\d_xu+\\o(\\D x))(\\d_xv+\\o(\\D x))+\\o(\\D x)\\\\ \u0026amp;=v\\d_xu+u\\d_xv+\\o(\\D x) \\end{align*} $$ 由于含 $\\d$ 的部分都是常数倍 $\\D x$，故这里的 $\\o(\\D x)$ 应该是 $0$。\n注意 $\\d_x u\\d_x v=\\Theta(\\D x^2)=\\o(\\D x)$。\n$\\d_xu^{-1}=-\\d_xu/u^2$。证： $$ \\begin{align*} \\d_x\\left(\\frac 1u\\right)\u0026amp;=\\frac 1{u+\\D u}-\\frac 1u+\\o(\\D x)\\\\ \u0026amp;=-\\frac{\\D u}{u(u+\\D u)}+\\o(\\D x)\\\\ \u0026amp;=-\\frac{\\d_x u}{u(u+\\D u)}+\\o(\\D x)\\\\ \u0026amp;=-\\frac{\\d_x u}{u^2}+\\frac{\\d_x u}{u^2}-\\frac{\\d_x u}{u(u+\\D u)}+\\o(\\D x)\\\\ \u0026amp;=-\\frac{\\d_x u}{u^2}+\\frac{\\d_x u(\\d_x u+\\o(\\D x))}{u^2(u+\\D u)}+\\o(\\D x)\\\\ \u0026amp;=-\\frac{\\d_x u}{u^2}+\\o(\\D x) \\end{align*} $$\n$\\d_xy=\\d_uy/\\d_uu\\cdot\\d_xu$。证： $$ \\begin{align*} \\d_xy\u0026amp;=\\D y+\\o(\\D x)\\\\ \u0026amp;=\\frac{\\d_uy}{\\d_uu}\\D u+\\o(\\D u)+\\o(\\D x)\\\\ \u0026amp;=\\frac{\\d_uy}{\\d_uu}(\\d_xu+\\o(\\D x))+\\o(\\D x)\\\\ \u0026amp;=\\frac{\\d_uy}{\\d_uu}\\d_xu+\\o(\\D x) \\end{align*} $$\n$\\d_yx/\\d_yy=1/(\\d_xy/\\d_xx)$。证：只需令 4 中 $u=y$ 即可。\n以上给出了微分形式的求导法则证明。注意到，3 的证明比直接 $\\lim$ 麻烦。\n一阶微分形式的不变性，可以理解成（注意 $\\d_xy\\ne\\d_uy$）： $$ \\forall u,\\frac{\\d_xy}{\\d_xx}=\\frac{\\d_uy}{\\d_ux} $$ 或是（注意 $y^\\prime_u\\ne y^\\prime_x$）： $$ \\d_xy=y^\\prime_u\\d_xu=y^\\prime_x\\d_xx $$ 关于自变量微分时，中间变量的微分形式和自变量的微分形式相同。这个性质一般会这样被使用：求 $\\d_xy$ 时，先求出 $\\d_uy$，然后把等式两侧的 $\\d_u$ 替换为 $\\d_x$ 再把 $\\d_x u$ 展开。这在不标关于谁微分的时候是不容易被发觉的，书里的写法 $\\d y=y^\\prime_u\\d u=y^\\prime_x\\d x$ 感觉像在说废话，其本质原因是它会被混淆成 $\\d_uy=y^\\prime_u\\d_uu$，而这就是定义啊。\n至于为什么教材里不表明是对谁微分，主要因为一般微分都是关于分母，不然得到的东西类型就不对了。\n那么在答题时如何用教材中的形式呢？在没有使用链式法则或直接处理高阶微分时，默认是关于上文中唯一的自变量微分；用链式法则处理一阶微分时，必须单独写出一步，并且在脑中，如果要替换“关于谁微分”，必须是成对替换，这种成对可以是分子分母，也可以是等式两边。\n高阶微分 如果硬要用类似一阶的定义方法定义高阶微分，可以这样类比定义：\n对于一个在 $x_0$ 邻域内有定义的函数 $f$，如果： $$ \\D^nf(x)=\\sum_{i=0}^n(-1)^{n-i}\\binom nif(x_0+i\\D x)=a\\D x^n+\\o(\\D x^n)\\quad(\\D x\\to 0) $$ 则称 $\\d^nf(x_0)=a\\D x^n=a\\d x^n$。\n但是这个似乎只能直接用导数的 $\\lim$ 形式证，我没法通过反复利用一阶微分的定义证。\n回到正常的定义。高阶微分的写法也是好理解的： $$ \\d_x\\left(\\frac{\\d_xy}{\\d_xx}\\right)=\\frac{\\d_x^2y\\d_xx-\\d_xy\\d_x^2x}{\\d_xx^2}=\\frac{\\d_x^2y}{\\d_xx} $$ 核心是 $\\d_x^2x=\\d_x(\\D x)=0$。\n二阶微分不具有形式不变性，可以如下试验：\n记 $u=g(x)$，$y=f(u)$。 $$ \\begin{align*} \\d_u^2y\u0026amp;=\\textcolor{teal}{f^{\\prime\\prime}(u)\\d_uu^2}\\\\ \u0026amp;=(f^{\\prime\\prime}\\circ g)(x)\\d_uu^2\\\\ \u0026amp;=\\textcolor{green}{(f^{\\prime\\prime}\\circ g\\cdot {g^\\prime}^2)(x)\\d_ux^2}\\\\ \\d_x^2y\u0026amp;=(f\\circ g)^{\\prime\\prime}(x)\\d_xx^2\\\\ \u0026amp;=\\textcolor{green}{(f^{\\prime\\prime}\\circ g\\cdot {g^\\prime}^2+f^\\prime\\circ g\\cdot g^{\\prime\\prime})(x)\\d_xx^2}\\\\ \u0026amp;=\\textcolor{teal}{f^{\\prime\\prime}(u)\\d_xu^2+f^\\prime(u)\\d_x^2u} \\end{align*} $$ 也就是： $$ \\frac{\\d_x^2y}{\\d_xx^2}\\ne\\frac{\\d_u^2y}{\\d_ux^2} $$ 至于为什么不一样，可以大致理解为有一项高阶项不能忽略。由于水平有限，我无法指出到底源自于哪儿。\n从而我们也就能理解，为什么在书里，参数方程一阶导可以 $\\d y/\\d x=\\d y/\\d t\\cdot\\d t/\\d x$，而二阶导必须拆成两次一阶导，而不能 $\\d^2y/\\d x^2=\\d^2y/\\d t^2\\cdot (\\d t/\\d x)^2$。\n","date":"2024-03-26T00:00:00Z","permalink":"https://example.com/study/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%88%86%E7%9A%84%E7%90%86%E8%A7%A3%E9%97%AE%E9%A2%98/differential/","title":"关于微分的理解问题"},{"content":"这是一篇学习笔记。\r关于本题的一个注记。\n钦定背包上界为 $72$，这样搜得的状态数为 $12880$。对其进行 dfa 最小化，状态数优化到 $715$（注意到设上界较大时最小化 dfa 后大小仍为该值）。预处理 $f_{k,i,s,r}$ 表示限制差 $\\le k$，$i$ 位待定，当前 dfa 上状态为 $s$，当前位至多取 $r$ 的答案，即可 $\\mathrm{O}(\\log r)$ 回答单组。远古最优解代码。\n这题在徐哲安的 2021 年集训队论文《浅谈有限状态自动机及其应用》中作为例题出现，其证明了背包上界只需开到 $80$ 即可，但没证 $72$。以下是我口胡的证明。\n结论：对于一个只包含 $\\le w$ 的正整数的序列，给每个数安排正负号，使得和的绝对值最小。那么最大前缀和绝对值 $\\le w(w-1)$。\n引理（CF618F）：对于大小 $\\ge n$ 的可重集合 $A$ 和任意大小（设为 $m$）的可重集合 $B$，它们的元素都是 $\\le n$ 的正整数。如果 $n+\\sum_{b\\in B}b\u0026gt;\\sum_{a\\in A}a$，那么可选两者各自的一个非空子集，使得和相同。证略。\n证明：首先最优答案一定 $\\le w$，并且当且仅当序列为奇数个 $w$ 时最优答案为 $w$，这是易证的。接下来只考虑最优答案 $\\le w-1$ 的情况。\n考虑某组最优解，找到其最靠前的前缀和绝对值 $\u0026gt;w(w-1)$ 的位置 $t$，不妨设该前缀和是正的。取出该前缀中最靠后的 $w$ 个取正号的数 $x_{1\\cdots w}$，以及剩余后缀中所有共 $k$ 个取负号的数 $y_{1\\cdots k}$。其中由鸽巢原理，$x_1,\\cdots,x_w$ 一定是可以取出来的，而由于 $\\sum_{i=1}^ky_i\\ge w(w-2)+2$，故 $k\\ge w-1$。\n接下来的目标是选择某些 $x$ 和某些 $y$，改变它们的符号，使全体和不变，且 $t$ 及之前不反而出现前缀和 $\u0026lt;-w(w-1)$ 的情况，且 $t$ 处的前缀和降低。这样就可以不断归纳了。\n如果 $\\sum_{i=1}^wx_i\\le w(w-1)$，则令 $A=\\set{x_{1\\cdots w}}$，$B=\\set{y_{1\\cdots k}}$，套用引理即可。\n否则随意套用引理可能会导致 $x_1$ 处前缀和 $\u0026lt;-w(w-1)$。这时，$x$ 中必然有 $w$。如果 $y$ 中也有 $w$，那么选这两个互换符号即可1。\n否则，选择 $y$ 中最短的前缀 $y_{1\\cdots k^\\prime}$，使得和 $\\ge w(w-2)+2$。由于 $y$ 中无 $w$，故 $k^\\prime\\ge n$。这时由于 $w(w-2)\u0026lt;\\sum_{i=2}^wx_i\\le w(w-1)$，$\\sum_{i=1}^{k^\\prime}y_i\\le w(w-1)$，故可令 $A=\\set{y_{1\\cdots k^\\prime}}$，$B=\\set{x_{2\\cdots w}}$，套用引理即可。\n这里其实有个特殊情况，就是 $x_1=w$，然后 $x_1$ 前的前缀和最小会达到 $-w+1$，这样一来 $x_1$ 处的前缀和会达到 $-2w+1$，在 $w=2$ 时会炸。但 $x_1$ 前的前缀和达到 $-w+1$ 时 $x$ 会全是 $w$，所以选后面的 $x$ 就行。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-02-18T00:00:00Z","permalink":"https://example.com/study/solution-cf924f/","title":"[题解] CF924F Minimal Subset Difference"},{"content":"这是一篇学习笔记。\r提供一个自己做的思路。用到的性质比其他正解弱，但更容易想。\n考虑单棵树的判定。初步读题后会得到两个性质：\n一个点的儿子边权不能重复。 设所有权为 $i$ 的边的较浅端点形成集合 $S_i$，则所有 $S_i$ 形成一个“连续包含链”的结构。或者也可以从一个点的所有儿子边权角度等价描述。 这些性质都是 beautiful subtree 的必要条件，并且对于想象力不够丰富的选手来说，难以加强至充要条件。既然必要角度不行，那考虑充分角度——同样是一个很常见的套路，我们希望找到一种排列的构造，使得对于 beautiful subtree，构造出来的排列必定是 beautiful permutation；如果不是 beautiful subtree，那就不用考虑了。于是剩余要做的就是验证一遍题意中的条件即可。\n归纳易证排列中越靠前的点子树 size 越大，因此先按 size 排序；如果两棵子树 size 相同，那么也归纳易证它们同构，因此它们的相对顺序只取决于它们各自父亲的相对顺序。因此可以在按 size 排序后再扫一遍，size 相同的按父亲在序列中的位置排序。这样可以做到 $\\mathrm{O}(n\\log n)$ 单次判定。这些归纳易证的部分也都很直觉的。\n对于原问题，一个有意思的猜想是，一棵 beautiful subtree 的子树也都是 beautiful 的。考试中当然可以直接 assert 然后交上去看看，不过这也是好证的。考虑 $T(u)$ 对应的某个 beautiful permutation $p$。对于 $v\\in T(u)$，将 $p$ 中 ${}\\in T(v)$ 的点对应的子序列 $p\u0026rsquo;$ 取出来，可以证明这就符合条件。因为对于某种权值的边，除去它的较深端点为 $v$ 的情况以外（$v$ 本身在 $p\u0026rsquo;$ 中不贡献给计数器，故也不用考虑），其余该权值的边的两端点要么同时在 $p\u0026rsquo;$ 中，要么同时不在 $p\u0026rsquo;$ 中。因此扔掉 $p\u0026rsquo;$ 以外的部分后，剩余的连边情况是保持不变的。\n剩下的就是思想类似 [WC2018] 即时战略 的二分了。取出重链，在上面二分，然后往轻儿子递归。硬二分是 $\\mathrm{O}(n\\log^3n)$ 的（代码），如果按全局平衡二叉树的方式带权二分，则是 $\\mathrm{O}(n\\log^2 n)$ 的。这是因为考虑大小为 $n$ 的树的第一轮二分，假设得到的根最浅 beautiful subtree 大小为 $s$，那么分 $\\ge 2s$ 和 $\u0026lt;2s$ 的子树判定讨论，这轮二分的复杂度为 $\\mathrm{O}(n\\log n+s\\log^2 n)$。接下来，剩余若干大小 $\\le n/2$，和为 $n-s$ 的子问题，这样分析下来就是 $\\log^2$ 的。\n","date":"2024-01-23T00:00:00Z","permalink":"https://example.com/study/solution-lgp9603/","title":"[题解] lgP9603 [IOI2023] 山毛榉树"},{"content":"这是一篇学习笔记。\r本文非常地粗糙和民科，算法很可能是假的。如果您知道已有的其他解法或者找到了我的证明的问题，请告知我是小丑。\n最近做 CF1909G 的时候想复杂了，结果发现了一些奇怪的性质，感觉不大平凡？\n引理：一个足够长的串 $s$，$s_1\\ne s_{n+1}$。若 $s_{1\\cdots n}$ 的最小整周期为 $p\u0026lt;n$，有某个 $1\u0026lt;i\\le n$，$s_{i\\cdots i+n-1}$ 的最小整周期为 $q\u0026lt;n$，那么 $i\u0026gt;n-p-q+\\gcd(p,q)+1$。\n证：反证，假设 $i\\le n-p-q+\\gcd(p,q)+1$。\n$p\\mid q$ 的情况下，$i\\le n-q+1$，$s_{n+1}=s_{n-q+1}=s_{1}$，矛盾。\n$p\\nmid q$ 的情况下，$s_{i\\cdots n}$ 这一段长度至少为 $p+q-\\gcd(p,q)$，且有 $p$ 和 $q$ 作为周期，由强周期引理，$p$ 不是 $s_{1\\cdots n}$ 的最小整周期，矛盾。\n$i$ 取到 $n-p-q+\\gcd(p,q)+2$ 的情况应该可以构造，不过我现在还没找到通用的形式。\n一个有趣的推论是 $i\u0026gt;n/3+1$，这可以通过讨论所有 $p,q\u0026gt;n/6$ 证明。取到 $i=n/3+2$ 的情况是这样的： $$ \\texttt{a}t\\texttt{b}t\\texttt{a}\\textcolor{red}{t\\texttt{a}t\\texttt{b}t\\texttt{a}t}+\\textcolor{red}{\\texttt{b}t\\texttt{a}t\\texttt{b}} $$ $t$ 表示任意串。前面一个串 $p=n/2$，红色部分 $q=n/3$。\n然后发现了一个求定长区间最小整周期的线性算法（定长长为 $n$）：\n首先 $p=n/2$ 的情况要暴力判掉。\n从左往右移窗口。对于当前子串 $s_{l\\cdots r=l+n-1}$，反过来跑 KMP。\ncase 1. 如果找到了 $\u0026lt;n$ 的最小整周期（这里找到 $n/2$ 也无所谓），那就可以一步步移左右端点，看能否维持当前周期，如果不行，根据引理可以至少一次性往后跳 $(n-p)/2$。称这个为优化 A。\ncase 2. 否则，如果下一个具有最小整周期 $p\\le n/3$ 的区间与 $[l,r]$ 有交，那么交的部分一定也有 $p$ 的周期。并且，如果交的部分长 $\\ge 2n/3$，那么 $p$ 一定是它的最小周期（否则可以用弱周期引理导出更小的 $p$）。现在，找到当前区间的最长后缀 $[t,r]$，满足这个后缀的最小周期是 $\\le n/3$ 的 $n$ 的因数，把区间左端点移到 $\\min(t,l+n/3)$。称这个为优化 B。注意优化 B 是不能兼容 $p=n/2$ 的，因为交里的循环节不足 $2$ 次，无法保证最小周期。比如当前子串为 $\\texttt{aaaaaaaaaabaaaaa}$，那么后续必须逐一检查。\n性质：连续进行两次优化 B，左端点移动超过 $n/3$。\n证：如果两次中有至少一次左端点移到的这个 $\\min$ 式子取的后一项，那么已证毕。\n否则考虑反证，如果左端点移动 $\\le n/3$，设两次分别移动到 $[l^\\prime,r^\\prime],[l^{\\prime\\prime},r^{\\prime\\prime}]$，$[l^\\prime,r]$ 和 $[l^{\\prime\\prime},r^\\prime]$ 的最小周期分别为 $p,q\\le n/3$。由于 $r-l^{\\prime\\prime}+1\\ge 2n/3$，故 $[l^{\\prime\\prime},r]$ 具有周期 $\\gcd(p,q)$，故 $[l^\\prime,r^\\prime]$ 具有周期 $\\gcd(p,q)$，不应有第二次优化 B，矛盾。\n综上，无论何种情况，都可以一次性跳过至少 $n/3$ 个位置，总时间复杂度为 $\\mathrm{O}(n\\cdot \\lvert s\\rvert/n)=\\mathrm{O}(\\lvert s\\rvert)$。\n优化 A 应该是不必要的（可以直接从 $l+1$ 继续），因为如果 case 1 紧跟 case 2 的话，case 2 应当一定会跳 $\\min$ 的后一项。这个我没仔细证。\n","date":"2024-01-18T00:00:00Z","permalink":"https://example.com/study/string-period/","title":"定长区间最小整周期问题的线性解法"},{"content":"这是一篇学习笔记。\r下文中的 $\\max/\\min$ 可以为了严谨起见理解成 $\\sup/\\inf$。\n众所周知，WQS 二分优化的是这样一类问题：有一个函数 $f(x)$，给定 $a$，希望求得 $f(a)$，但是 $f$ 的单点值无法快速求。这时，如果有以下性质之一：\n$f(x)$ 上凸，且能快速求 $\\max_x\\set{f(x)-kx}$。 $f(x)$ 下凸，且能快速求 $\\min_x\\set{f(x)-kx}$。 那么就可以利用二分 $k$（也就是所谓的“多选扣分”）的方法“凑”出所需的 $f(a)$。\n接下来只以满足第 1 种性质的 $f$ 为例。\n常用的不严谨方法 问题出在二分判定的时候。常用的写法要求 check 函数返回一个取到 $\\max$ 的 $x_0$ 值，然后与 $a$ 比较大小。如果 $x_0$ 是任选的，那么如果二分的斜率恰好正确，而切线上有多于一个点（所谓“共线情况”），那么 $x_0$ 与 $a$ 的大小关系是任意的。而由于整数二分一定有一边会排斥掉 $mid$，故这个做法是错误的。\n相应的弥补方案有两种。一种是 check 返回最小或最大的 $x_0$。例如返回最小的 $x_0$，如果 $x_0\\le a$，那么 $r\\gets mid$，否则 $l\\gets mid+1$。另一种是实数二分，其正确的原因在于总是不排除 $mid$，这样正确的斜率总是包含在 $[l,r]$ 中，而如果整数二分这样做，就会在区间为 $[l,l+1]$ 时卡住。以 $l=1$ 为例：\n实数二分考虑了这条红切线（$k=l+0.5$），因此可以区分绿点是在哪一边。\n但是这两种处理方法面对着一个共同的问题，即高维的情况无法简易地处理：CF739E 和 CF1799F。\n以二维的情况为例，有函数 $f(x,y)$，要求 $f(a,b)$（其中 $f(x,b)$ 关于 $x$ 是上凸的，且 $\\forall,k,\\max_x\\set{f(x,y)-kx}$ 关于 $y$ 是上凸的）。这时外层二分的判定条件应该是“使 $f(x,b)-kx$ 取到 $\\max$ 的 $x$ 值”，然而这个值是难求的。\n你可能会说，内层二分的斜率 $k^\\prime$ 已经求出来了，那拿它和 $k$ 一起跑一遍 check，尽量使 $x$ 最小或最大就行了呀。这里的问题在于，无法保证 $y$ 恰好取到 $b$，因为 $y$ 这一维同时也会出现共线情况，这时可能会取到错误的 $y$，从而取到不该取的 $x$。这个问题即使用实数二分也无法解决，例如这个提交记录。\n一种解决方法 Neal Wu 在这里提出了一种精细的处理方法。例如要求最小的取到 $\\max$ 的 $x_0$，那么在 check 中求出必须要用几个 $x$，必须要用几个 $y$，和既可以用 $x$ 又可以用 $y$ 但不能都不用（必须都用的情况不算在内，应算作前两个各自加一）的数量，分别记作 $\\alpha,\\beta,\\gamma$。外层二分如果 $\\alpha\\le a\\land \\alpha+\\beta+\\gamma\\le a+b$，那么 $r\\gets mid$。这个判断的正确性如下：\n如果这些条件不满足，那么显然不存在合法分配方案，斜率一定是太小了。 如果这些条件满足，那么一定存在一个 $x\\le a$，使得 $f(x,b)$ 被切线切到。构造方法是，$y$ 先取 $\\beta$ 部分，显然 $\\beta\\le b$（不然内层二分就不会二分到这个斜率）。然后尽量用 $\\gamma$ 的部分补满 $b$。如果补满了，那么由 $\\alpha+\\beta+\\gamma\\le a+b$，故 $x=\\alpha+\\gamma-(b-\\beta)$ 一定可以。如果没补满，那么找另一些不影响 $x$ 用量的元素补满 $y$（一定能补满，不然内层二分就不会二分到这个斜率），这时由 $\\alpha\\le a$，故 $x=\\alpha$ 一定可以。 这里是另一题我写的类似的处理方法。\n但是这个方法缺乏通用性。首先，刚才这个解法中“用”的定义只在这两题里成立（即用两类精灵球和用两类操作），如果没有类似的组合意义就不行了，所求条件就再次变成了不可解决的，类似于原问题的“强制限定 $y=b$”。其次，维数再高就难以讨论了。\n通用的解决方法 核心性质：对于上凸的 $f(x)$，令 $g(k)=\\max_x\\set{f(x)-kx}+ka$，$g(k)$ 是下凸的，且最小值恰为 $f(a)$。\n这张动图中红色轨迹即为 $g(k)$。\n证 1：若 $f(k)$ 处处可导，令 $h(k)=\\min\\set{x\\mid f^\\prime(x)=k}$，则 $g(k)=f(h(k))-k(h(k)-a)$。 $$ \\begin{aligned} g^\\prime(k)\u0026amp;=f^\\prime(h(k))h^\\prime(k)-kh^\\prime(k)-(h(k)-a)\\\\ \u0026amp;=kh^\\prime(k)-kh^\\prime(k)-h(k)+a\\\\ \u0026amp;=-h(k)+a \\end{aligned} $$ 而 $h(k)$ 是递减的，故 $g^\\prime(k)$ 递增。\n证 2：用更加普遍的定义来证。同样令 $h(k)$ 为使 $g(k)$ 取到 $\\max$ 的某个 $x$。$\\forall,k_1,k_2$，对于 $\\lambda\\in (0,1)$，令 $k_m=\\lambda k_1+(1-\\lambda)k_2$： $$ \\begin{aligned} \u0026amp;\\lambda g(k_1)+(1-\\lambda)g(k_2)\\\\ ={}\u0026amp;\\lambda\\max_x\\set{f(x)-k_1x}+(1-\\lambda)\\max_x\\set{f(x)-k_2x}+k_ma\\\\ \\ge{}\u0026amp;\\lambda(f(h(k_m))-k_1h(k_m))+(1-\\lambda)(f(h(k_m))-k_2h(k_m))+k_ma\\\\ ={}\u0026amp;f(h(k_m))-k_mh(k_m)+k_ma\\\\ ={}\u0026amp;g(k_m) \\end{aligned} $$ 同时，显然 $\\forall,k,g(k)\\ge f(a)$，又由于 $f$ 的凸性，一定存在一个 $k$ 使得 $g(k)=f(a)$，故得证。\n另外我们会惊奇地发现：除了最后一步外，证 2 甚至没用 $f$ 的凸性！\n于是就可以直接二分了，判定时只需比较 $mid$ 和 $mid+1$（或 $mid+\\varepsilon$）的 check 结果。CF1799 的代码。\n这样做唯一的缺点在于会有 $2^d$ 倍常数（$d$ 为维数）。可以用优选法（按黄金比划分的三分）优化到 ${1.44}^d$ 倍。\n一个小细节 考虑实数二分的精度问题，设当前二分区间为 $[l,r]$，取 $f(h(l))-lh(l)+la$ 来估算答案，它与 $f(a)$ 的差距为： $$ \\begin{aligned} \\lvert f(h(l))-lh(l)+la-f(a)\\rvert\u0026amp;=\\left\\lvert l(a-h(l))-\\int_{h(l)}^af^\\prime(x)\\mathrm{d}x\\right\\rvert\\\\ \u0026amp;=\\left\\lvert\\int_{h(l)}^a(l-f^\\prime(x))\\mathrm{d}x\\right\\rvert\\\\ \u0026amp;\\le\\lvert a-h(l)\\rvert\\cdot(r-l)\\\\ \u0026amp;\\le\\lvert I\\rvert\\cdot(r-l) \\end{aligned} $$ 其中 $I$ 为 $f$ 的定义域。因此二分一般得在 $r-l$ 小于允许的绝对误差除以 $n$ 时才结束。$f(x)=C$ 时可以取到最差情况下的误差。\n参考资料 \u0026amp; 总结 本文基本上就是 Theoretical grounds of lambda optimization 的提要版本。\n目前，WQS 二分在应用中仍难以解决的问题主要是凸性的证明。大量题目直觉上目标函数具有凸性，但无法严格证明。归约费用流可能是一种有前途的方案，但目前这几道题例仍未找到证明。adamant 的这篇文章关于 CF739E 的证明应该是错的，我在下面的评论区也有提问，如果您有想法可以与我交流。\n目前已知的证明方法：\n[IOI2016] Aliens：四边形不等式是要的，然后有两个证明方法，分别于 Kubic 23 年的论文、我 24 年的论文。\nCF739E 和 CF1799F：用题解区这篇的方法建图，然后把一种精灵球选的代价改为 $+\\infty$，这样就可以证 $f(x,b)$ 或 $f(a,x)$ 的凸性；内层的凸性更容易，可以用流或 dp 证。这题外层不能用 dp 归纳证，分讨会有一种情况去世。\nP1792 种树：这类题如果是奇环我是不会证的，并且我目前没看到对的证明。偶环、链、树这类二分图的情况可以看 Kubic 的论文。对于链的情况，可以将限制扩展到“任意两个选的距离必须 $\\ge k$”，这样就只能用四边形不等式（一个区间的代价为除去开头 $k$ 个，剩余的 $\\max$，这样就有四边形不等式了）或者 dp 归纳证。\n[八省联考 2018] 林克卡特树：这篇题解似乎有证明，我没仔细看，不知道是否严谨。反正 dp 归纳是不行的。\n","date":"2023-10-31T00:00:00Z","permalink":"https://example.com/study/wqs/","title":"严谨的 WQS 二分方法"},{"content":"这是一篇摘抄笔记。\r本文基本上就是 Optimal Preprocessing for Answering On-line Product Queries 和 Data Structures for Range Minimum Queries in Multidimensional Arrays 的非形式化翻译，掺杂了自己的理解和思路，略去了一些细节。\n主要讲一下比较基础的静态数组、高维数组的区间查询问题。两篇论文其实关系不大，只是后一篇用了前一篇的部分成果。\n理论性比较强，尤其是后一篇，基本上出不成题。\n静态序列区间半群查询问题 问题：给定半群元素序列 $a_{1\\cdots n}$，在只能使用半群运算 $\\circ$ 的情况下，多次询问区间 $[l,r]$，回答 $\\circ_{i=l}^r a_i$。\n解决思路无非就是预处理一些区间的积，查询时拼起来就行。联想到正常的动态区间查询问题，动态情况下下界就是 $\\Omega(\\log n)$ 的。静态情况下允许的预处理量大大增加，因此分析下去会不一样，但思路还是可以借鉴的。总体来说，核心的思想就是两点：\n预处理与查询的平衡。 分块与分治。 记 $k$ 表示回答查询时允许的半群运算次数 ${}+1$。\n最初的思考从 $k=2$ 开始（$k=1$ 只能预处理所有平方个区间），我们要给每个区间 $[l,r]$ 选定一个切分点，然后进行所需的预处理。为了使公共预处理区间尽量多，考虑每次选择一个点，将所有尚未确定切分点，且能以该点为切分点的区间的切分点选定为该点。这个就是猫树，下面说点题外话。\n记猫树的预处理量为 $p(n)$。每次选取中点作为切分点的最优性是由 $p(n)$ 的凸性保证的。我们可以通过解递归式得到： $$ p(n)=n\\lfloor\\log_2(n-1)\\rfloor+2n-2^{\\lfloor\\log_2(n-1)\\rfloor+1} $$ 为了方便 $\\Omicron(1)$ LCA，猫树有少量冗余。理论上递归可以只进行 build(l,mid-1) 和 build(mid+2,r)，并且在 $r-l\\le 1$ 时结束，记猫树最优的预处理量为 $p^\\prime(n)$： $$ p^\\prime(n)=(n+2)\\lfloor\\log_2(n+1)\\rfloor-n+2-2^{\\lfloor\\log_2(n+1)\\rfloor+1} $$ 猜想：对于长为 $n$ 的序列，$k=2$ 情况下符合条件的预处理区间集合 $\\mathcal{P}$，除去 $n$ 个单元素区间，${\\lvert\\mathcal{P}\\rvert}_{\\min}=p^\\prime(n)$。\n注意这里的最优性和上文的最优性是不一样的，上文是“每次选择一个切分点，然后两边递归”这个思路前提的基础上的最优性。\n纠结于系数意义不大，我们关注 $k=2$ 情况的结构带来的启发。“预处理前/后缀和”是非常有效的线性手段。\n但是如何推理 $k\u0026gt;2$ 呢？众所周知，动态情况下的线段树是从分块嵌套演化过来的，因此考虑类比逆推多个切分点的情况（只预处理每一块内的前后缀和）：\n对于一个询问，如果它在块内部，则递归 $T_2$ 处理，否则两头散块可以用前后缀和算出，然后考虑 $T_1$ 用于维护每块的和形成的较短序列，处理块间部分。\n记块大小为 $B(n)$，预处理复杂度为 $p(n)$，回答询问使用的运算次数最多为 $q(n)-1$。下文中可能出现多个 $f(n)$，作用域仅在单自然段内。\n利用分治的思想，考虑三种可能（记 $q(n)=k$ 的数据结构为 $S_k$，$S_2=$ 猫树）：\n$T_1=T,T_2=T$。\n$p(n)=p(n/B(n))+n/B(n)\\cdot p(B(n))+\\Theta(n),q(n)=\\max\\set{q(n/B(n))+2,q(B(n))}$，上下均自递归的结构其实很像 vEB 树，因此考虑取 $B(n)=\\sqrt n$，将 $p(n)$ 展开后使用初中处理因式的技巧，就可以得到 $p(n)=\\Theta(n\\log\\log n)$，同时 $q(n)=\\Theta(\\log\\log n)$。我猜测无法更优了。 $T_1=T,T_2=S_2$。\n$p(n)=p(n/B(n))+\\Theta(n\\log B(n)),q(n)=q(n/B(n))+2$，可以对输入的固定的 $n$ 取 $\\forall i,B(i)=2^{\\sqrt{\\log n}}$，这样可以平衡成 $p(n)=\\Theta\\left(n\\sqrt{\\log n}\\right),q(n)=\\Theta\\left(\\sqrt{\\log n}\\right)$。这个方向没有前途的直觉解释是：分块后问题分成了 $T_1$——单个规模较小、$T_2$——若干规模很小，但总和不变 这两个子问题，直觉上后者是比前者难的，拿已有的结构作为 $T_2$ 基本没法优化。 $T_1=S_2,T_2=T$。\n$p(n)=\\Theta(n/B(n)\\cdot\\log(n/B(n)))+n/B\\cdot p(B(n))+\\Theta(n),q(n)=4$，很明显可取 $B(n)=\\log n$，从而做到 $p(n)=\\Omicron(n\\log^*n)$，这个就是 $S_4$。 第三种可能实际上提供了一个以 $q(n)$ 增加 $2$ 为代价，将 $p(n)=\\Omicron(n\\cdot f(n))$ 变为 $\\Omicron(n\\cdot f^*(n))$ 的通法（得满足 $f(n)=\\Omicron(\\log n)$，取 $B(n)=f(n)$ 即可），其中 $f^*(n)=\\min\\set{i\\mid f^{(i)}(n)\\le 1}$。 因此我们可以做到： $$ \\forall 2\\mid k\\ge 4,p(n)=\\Omicron(n\\log^{\\begin{matrix}k/2-1\\\\ \\overbrace{**\\cdots*}\\end{matrix}}n),q(n)=k $$ ……吗？\n这里有一个很容易犯的错误，就是如果不用主定理解递归式，那么解的过程中严谨地来说必须避免渐进记号。但 OI 实践中往往不拆也不会出问题，这里实际上套上了一个归纳，并且把 $k$ 作为变量塞进渐进记号里了，就得谨慎地算一下了。$k=4$ 时： $$ \\begin{aligned} p(n)\u0026amp;=n/\\log n\\cdot \\log(n/\\log n)+n/\\log n\\cdot p(\\log n)+2n-2\\log n\\\\ \u0026amp;\u0026lt;3n+n/\\log n\\cdot p(\\log n)\\\\ \u0026amp;=3n\\log^*n \\end{aligned} $$ 同理，可以算得 $k=6$ 时 $p(n)\u0026lt;5n\\log^*n$ 等等。因此： $$ \\forall 2\\mid k\\ge 4,p(n)=\\Omicron(n\\textcolor{red}{k}\\log^{\\begin{matrix}k/2-1\\\\ \\overbrace{**\\cdots*}\\end{matrix}}n),q(n)=k $$ 另外，为了完整，我们把 $2\\nmid k$ 也补上。$k=3$ 套上 $T_1=S_1$，（特例）取 $B(n)=\\sqrt n$，可以得到 $p(n)=\\Theta(n\\log\\log n)$ 的 $S_3$，$k\\ge 5$ 就跟 $k-1$ 情况一样了。\n为了平衡 $p(n)/n$ 和 $q(n)$，考虑取 $k=2\\alpha(n)+2$，其中： $$ \\alpha(n)=\\min\\set{i\\mid\\log^{\\begin{matrix}i\\\\ \\overbrace{**\\cdots*}\\end{matrix}}n\\le 3} $$ 这里 $\\le 3$ 时因为 $n\\ge 5$ 时不管有几个星，结果都至少是 $3$。您可能在其他地方见过 $\\alpha(n)$ 的不同定义方式，不同的定义应该都只差一个常数。\n这时 $p(n)=\\Omicron(n\\alpha(n)),q(n)=\\Theta(\\alpha(n))$。注意这里的 $\\alpha(n)$ 是无法变成 $\\alpha^*(n)$ 的，但是有另一个看起来不大优美的优化方式：\n仍然考虑上文的分块模型，$T_1=S_{2\\alpha(n)+2},T_2=T_{?}$，设 $T_{?}$ 的预处理时间为 $p_{?}(n)=\\Omicron(n\\cdot f(n))$。那么总的 $p(n)=\\Omicron(n/B(n)\\cdot\\alpha(n)+n\\cdot f(B(n)))$，如果要使得 $p(n)=\\Theta(n)$，唯一的方法是取 $B(n)=\\alpha(n),f(n)=\\Omicron(1)$，那么 $T_{?}$ 可以选择普通线段树。好在这部分的询问运算次数不是瓶颈，因此总的 $q(n)$ 只会加 $2$（最外层两端的散块）。这里主要是通过类似于待定系数法的方式解释一下论文里为什么会突然冒出普通线段树。\n这个优化的思想是，用“单个规模较小”优化预处理“常数”（红色的 $k$），“若干规模很小，但总和不变”尽管无法有效减小预处理复杂度，但是可以保证查询次数足够少。二者互补。\n我尝试类推优化掉任意 $k$ 的“常数”（红色的 $k$）（这个原论文里没讲），但 $q(n)$ 会加 $2$。这个是可以避免的：\n希望 $q(n)=k\\ge 3$，最外层是 $T_1=S^\\prime_k,T_2=普通线段树,B(n)=k$。$S^\\prime_k$ 是修改过的结构，基本与 $S_k$ 相同，即 $T_1=S_{k-2},T_2=S^\\prime_k,B(n)=f(n)$，这里 $f(n)$ 指的是设 $S_{k-2}$ 的预处理复杂度为 $\\Omicron(n(k-2)f(n))$。不同的点在于 $S^\\prime_k$ 处理的块内前后缀和是细分到原序列的，而不是严格遵循最外层分块结构把每 $k$ 个一组的和视为整体。这样就避免了最外层跨块时额外查一对前后缀和。$S^\\prime_k$ 的预处理复杂度仍然是 $p(n)=\\Omicron(nk/B(n)\\cdot f(n))+n/B(n)\\cdot p(B(n))+\\Theta(nk)=\\Omicron(nk\\cdot f^*(n))$，其他部分也都没有问题，总体来说就把 $p(n)$ 的 $k$ 除掉了，$q(n)$ 不变。最终我们得到了： $$ p(n)=\\begin{cases}\\Omicron(n^2)\u0026amp;q(n)=1\\\\ \\Omicron(n\\log n)\u0026amp;q(n)=2\\\\ \\Omicron(n\\log\\log n)\u0026amp;q(n)=3\\\\ \\Omicron(n\\log^{\\begin{matrix}\\lfloor k/2\\rfloor-1\\\\ \\overbrace{**\\cdots *}\\end{matrix}}n)\u0026amp;q(n)=k\\ge 4\\end{cases} $$ 但如果具体实现真想做到查询时间复杂度 $=\\Theta(q(n))$，那就得处理一个“变进制数 LCP 问题”，而且 $q(n)\\ge 4$ 后基本没法体现区别，所以只能套一个交互限制运算次数或者像 【北大集训2021】末日魔法少女计划 这样。\n下界的证明思路是对着这个分块结构硬证。对于 $k=2$，选择序列中点 $m$，将只包含于中点左侧（不含中点）和只包含于中点右侧（不含中点）的预处理作为一类，跨左右的预处理作为一类。考虑询问 $[m-i,m+i]$，要用两个预处理拼成该询问，就必须有一个跨左右的预处理。因此 $p(n)\\ge p(\\lfloor n/2\\rfloor)+p(\\lceil n/2\\rceil-1)+\\lceil n/2\\rceil-1$，解得 $p(n)=\\Omega(n\\log n)$。对于 $k\\ge 3$，按 $S_k$ 的块大小分块，但块间空出一位。也是先忽略块内的预处理，剩余跨块的预处理。对于一个位置，如果它不是任何跨块预处理的端点，则标记它。如果含有被标记位置的块不足一半，那么跨块预处理至少 $\\Omega(n)$；超过一半，那么考虑所有以标记位置为两端的询问，组成询问区间的最左右预处理一定是块内的，去掉这两部分后剩余问题一定不弱于 $k^\\prime=k-2,n^\\prime=n/B(n)$ 情况的问题，跨块预处理也是至少 $\\Omega(n)$，归纳即可，这里注意不会带有因子 $k$。论文里提到这个证明可以直接推广成“预处理可以是任意子集且不要求不交并”情况。\n因此，上述解法的半群运算次数是渐进最优的。论文标题上加了个 on-line，不知离线是否会有更好的结果。\n高维 RMQ 问题 问题：给定高维数组 $a_{1\\cdots n_1,\\cdots,1\\cdots n_d}$，在只能使用比较运算的情况下，多次询问高维区间 $[l_1,r_1],\\cdots,[l_d,r_d]$，回答 $\\min_{i_1\\in[l_1,r_1]}\\cdots\\min_{i_d\\in[l_d,r_d]}\\set{a_{i_1,\\cdots,i_d}}$。记 $N=\\prod n_i$。\n以下视 $d$ 为定值，但还是会尽量写一下关于 $d$ 的常数。以下假设 $a$ 中数互不同。\n先尝试把上文的静态区间半群查询问题的 $S_k$ 扩展到 $d$ 维结构 $S_k^d$：非常简单，处理块内前后缀和时，不再是存储单个元素，而是一个 $d-1$ 维数组，就需要嵌套下去，那就归约 $S_k^{d-1}$ 了。时间复杂度的变化是预处理的 $\\log$ 以及查询会带上 $d$ 次方。\n目前可以做到的是预处理 $\\Omicron(N\\log^{d-1}N)$，查询 $\\Omicron(2^d)$，也就是把最内层一维套个四毛子。\n但是我们的目标是预处理 $\\Theta(N)$，查询 $\\Omicron(1)$。可以推理得到以下几点：\n得用四毛子。 直接用 $S_2^d$ 之类的结构肯定不行。 那如果是 $S_3^d$ 的最内层套四毛子，是不是就可以做到 $\\Omicron\\left(N\\frac{(\\log\\log N)^d}{\\log N}\\right)=\\omicron(N)$ 了呢？答案是否定的，因为次内层的结构是带一个前后缀 $\\min$ 的，也就是要得到最内层建树所基于的序列，就先得乘 $\\Theta(n_d)$，而其他外层又无法直接套四毛子，所以如果用这种思路，就必定是 $\\Omega(N(\\log\\log N)^{d-1})$ 的。因此一维的四毛子不行。\n四毛子的关键是找到一个信息量足够小的贴近本质的刻画，那如何找到一个高维数组的所有可能的区间 $\\min$ 的刻画呢？不幸的是，论文中提到，二维的 $n\\times n$ 方阵不存在类笛卡尔树的刻画，因为在矩形 $\\min$ 查询意义下本质不同的方阵个数为 $\\Omega(((n/4)!)^{n/4})$，取对数发现光是靠比较来区分所有的情况都无法做到 $\\Omicron(n^2)$。\n一种新的刻画一维序列的方式如下：考虑猫树，树的每个节点预处理所有前后缀 $\\min$。尽管建树复杂度无法做到 $\\Theta(n)$，但比较次数是可以的：考虑一个节点的前缀 $\\min$，前一半从左儿子继承，后一半从右儿子继承的同时，要与左儿子 $\\min$ 再取个 $\\min$，而这个取 $\\min$ 的决策情况显然可以二分分界点，因此一个节点的比较次数可以做到长度的对数，总体来说就是至多 $2\\sum_{i\\ge1}i\\cdot\\frac{n}{2^i}=4n$ 次。\n猫树可以扩展到高维 $S_2^d$，但为了保证比较次数，处理方法要稍作调整：对于某个节点，设其对应的区间长度为 $2^{i_1}\\times\\cdots\\times 2^{i_d}$，由于不能多维同时二分，故选择最长的一维，将这一维切成两半后对应的节点信息作为继承 $\\min$ 值的来源，其他维暴力扫描，这一维二分。比较次数为（这里的 $2^d$ 是每一维都要前后缀）： $$ \\begin{aligned} \u0026amp;\\sum_{i_1,\\cdots,i_d}\\max_j\\set{i_j}\\cdot\\frac{\\prod_j2^{i_j}}{\\max_j\\set{2^{i_j}}}\\cdot 2^d\\cdot\\frac{N}{\\prod_j2^{i_j}}\\\\ ={}\u0026amp;2^dN\\sum_{i_1,\\cdots,i_d}\\frac{\\max_j\\set{i_j}}{2^{\\max_j\\set{i_j}}}\\\\ ={}\u0026amp;2^dN\\sum_i\\frac{i}{2^i}\\left[(i+1)^d-i^d\\right]\\\\ \u0026lt;{}\u0026amp;2^dN\\sum_i\\frac{i^{d+1}}{2^{i-1}}\\\\ ={}\u0026amp;2^{d+2}N\\cdot \\tilde{b}(d+1)\\\\ \\approx{}\u0026amp;\\frac{2^{d+1}(d+1)!}{(\\ln 2)^{d+2}}N\\\\ ={}\u0026amp;\\Theta(N) \\end{aligned} $$ 其中 $\\tilde{b}(n)$ 是 A000670。注意如果不选最长的一维切就不能线性了。\n由于这个结构并非确定唯一的最小值位置，而是给出 $\\Omicron(2^d)$ 个候选最小值，故它的线性复杂度并不与上文所说的“无法刻画”矛盾。\n好，现在选取边长为 $B=c\\log^{1/d}N$ 的 $d$ 维超立方体作为小块，使用四毛子（为了快速识别输入的每一小块的类型，避免带上 $\\log^d$，可以选取足够小的常数 $c$，$\\Omicron(N)$ 地预处理出判断块类型的决策树）。这种分块方式不是严格意义上的高维嵌套分块，需要重新考虑如何回答询问。\n注意到，只要询问有一个维度的区间是跨块，那么整块部分就可以直接利用除以 $\\log^{1/d} N$ 这个因子，套上 $S_3^d$ 从而达到 $\\Theta\\left(\\max\\Set{N,N\\frac{(\\log\\log N)^d}{\\log^{1/d}N}}\\right)$ 也就是 $\\Theta(N)$（因为 $d$ 是定值）；查询的每一维都是块内的情况不必多说。\n现在就剩下跨块时去掉中间整块后，散块即两端块内前后缀部分的处理。\n论文中给出的方法是：对跨块的这一维的所有块内前后缀 $\\min$（指的是多个内层 $d-1$ 维数组对应位置分别取 $\\min$），递归建 $d-1$ 维时的原问题结构。总体来说，需要预处理以下三部分：\n每个小块的类型； 每一维求出每个块的 $\\min$（$B$ 个内层 $d-1$ 维数组对应位置分别取 $\\min$），然后建 $S_3^d$。 每一维求出每个块内前后缀的 $\\min$，然后递归建 $d-1$ 维的结构。 询问时，如果所有维度都是块内，则直接回答，否则任选一个跨块维度，拆成三个部分处理。\n预处理复杂度 $p(n)=\\Theta(2^d\\tilde{b}(d+1)N)$，具体算一下会发现递归减一维的部分并不是瓶颈，识别小块类型才是。查询 $q(n)=\\Omicron(3^d)$。\n我想到的一个更简单的方法是：只预处理上文中 1 和 2 结构，$p(n)$ 不变。查询时利用 RMQ 可以重复考虑同一个数的性质，分别考虑每一个跨块的维度，忽略其散块部分（其他维保留原询问区间），在 2 结构中查询，这个是 $\\Omicron(d3^d)$；剩余未考虑的就是每一维都是散块的部分，一共有 $\\Omicron(2^d)$ 个（左右段各一个）块，每个小块 $\\Omicron(2^d)$，乍一看是 $\\Omicron(4^d)$，但实际上如果一个维度跨块了，它会给查询数量贡献 $\\times 2$，但在高维猫树中由于这维查的是前后缀，所以对候选最小值数量就不贡献 $\\times 2$ 了，因此还是 $\\Omicron(2^d)$。最终 $q(n)=\\Omicron(d3^d)$。\n","date":"2023-08-27T00:00:00Z","permalink":"https://example.com/study/paper2/","title":"读论文系列 #2——两个偏理论的静态数据结构问题"},{"content":"这是一篇摘抄笔记。\r前天 @changruinian2020 发了我一篇论文，让我帮他读读。以前基本上没有在毫无相关理论准备的情况下读论文，这里记录一下，挺有帮助的。链接。\n首先这篇论文在 OI 范围内没啥意义，纯粹就是练阅读能力，相对一些其他论文来说比较友好。如果您也想练习，推荐先去看原文，再对照一下下面提供的我的理解（不保证正确）。\n问题：给定一张 DAG $G$，点上带有字符串 $\\ell(v)$，给定串 $Q$，求 $Q$ 与 $G$（的所有路径中）的 LCS，一条路径对应的串就是点的串顺次拼起来。\n结构：求得每个单点 $v$ 与 $Q$ 的所有极长公共子串 MEM（说是可以关于 MEM 个数线性地求出，在另一篇论文里。记为 $N$ 个），记作 $(Q[x\\cdots x+\\kappa-1],\\ell(v)[i\\cdots j])$，然后选出一个 MEM 序列，要求 $x\\le x\u0026rsquo;,v\\rightsquigarrow v\u0026rsquo;$，允许 $v=v\u0026rsquo;$，如果这样有额外的条件 $i\\le i\u0026rsquo;$（这里加一撇表示序列中的下一项）。这个时候把这个序列在 $Q$ 和所有涉及到的 $\\ell(v)$ 中都划出对应匹配的子串，如果相邻两个 MEM 在 $Q$ 中或者某个 $\\ell(v)$ 中划的线有重合，就把前面的一个区间缩一下（$Q$ 和 $\\ell(v)$ 同时缩）。这样子得出的公共子序列一定能考虑到最优解。例子可以参见 Figure 1。\n求解：\n先考虑每个点只能选一个 MEM 的情况，那么只能在 $Q$ 中出现划线重合。这个问题相当于：$G$ 中每个点都挂了一些区间，要选一条路径，路径上的每个点选挂在上面的 $0$ 或 $1$ 个区间，得到 $[l_1,r_1],\\cdots,[l_t,r_t]$，其中要求 $l_i\\le l_{i+1}$。现在最大化 $\\sum(\\min(r_i+1,l_{i+1})-l_i)$。由于可能是在 DAG 上跳着走，所以有点难搞。给所有挂着的区间一起编个号，记 $dp[i]$ 表示 $i$ 号区间作为最后一个区间的答案。通过另一个神秘算法找到图的最小（可相交）路径覆盖（记为 $k$ 条），每一条路径统一更新其他所有点（对于每个希望被更新的点，找到路径上最后一个可达它的点，在那个点处理完时更新，这样就避免了后效性），然后就剩下路径内部转移了。具体统一更新的方法就是讨论 $\\sum$ 里的 $\\min$ 取哪一项，就变成了一个单点更新，求区间 $\\max$ 的问题了，每条路径维护两棵线段树/平衡树即可。这样就是 $\\mathrm{O}(kN\\log N)$ 的。\n补充一句，斜体部分在原文中说若要做到与 $\\lvert E\\rvert$ 无关得用 transitive reduction，这个东西看起来有些前途，NOI2021D1T3 用到了这个思想。\n然后要考虑点内部选多个 MEM 的情况。先考虑两个串之间的问题，仍然是已知两者的所有 MEM。这里我认为论文有笔误，显然 M.sort() 应该按照 $i$ 而不是 $x$ 排序。转移就按照 coverage 公式讨论：a. 两者都不重合；b. $T$ 中不重合 $Q$ 中重合（与第一步中类似）；c. $T$ 中重合且比 $Q$ 中重合得多（允许 $Q$ 不重合）；d. $T$ 中重合且比 $Q$ 中重合得少。值得思考的是：① 为什么不能将 bd 合并成 $T$ 中重合得且比 $Q$ 中重合的少（允许 $T$ 不重合）？因为这时要保证 $Q$ 中有重合，那就有两维限制，无法维护。② 为什么 d 无需考虑 $x$ 递增条件不满足的情况？因为这个在后续转移中一定不会成为最优解。\n综合起来，2 中的 ab 情况和 1 的点间更新是兼容的，不用额外转移了。\n这里最感到奇怪的就是这个 MEM 的引入以及链覆盖的做法。现在理论界确实有很多 parameterized 的解法（主要理论下界都被研究完了），即关于输入的某个示性数较优的解法。OI 中这类情况就较少。\n然后是一些闲话。\n形式化是一把双刃剑，保证了严谨性的同时给没有相关基础的读者竖起了一面妨碍理解的高墙。vuq 也讨论过“知识的诅咒”这一问题。当你会了一个模型时，你可以任意地把它形式化地表述出来，但是读者初步看了之后，不懂的还是不懂，因为他们看不到你的文字背后的思考过程（而且实际表述顺序很可能相对于思考顺序是颠倒的），你的 motivation 和 intuition，在理论体系上是怎样的存在（本质、意义、等价表述），当然也包括 vuq 里提到的联想知识；甚至单纯就是被一堆定义绕晕了，就放弃了。我以前看算法导论和部分集训队论文就是这种感觉，就像看别人的代码一样。\n但是论文都得保证严谨性。友善的作者可能会加入例子和非形式化解释，但不多。那我硬啃的过程就是把它变成自己的理解，我觉得关键就是在明确定义的前提下尽量带入自己的思路，尝试还原作者的想法。如果硬着头皮逐字逐句地去看文章，被动地理解，会很痛苦（很多情况下就是莫名其妙提出来一个 theorem 然后证明），而且无法收获思维上的营养。读的过程中要经常停下来，想象目前模型的图形化解释、例子以及如果我面对这个模型，我会怎么考虑。主动地去思考，会比较好。当然前提是核心 definition 和问题模型得先搞清楚，如果发现定义不自洽可以检查一下是不是有些专业表述望文生义了。一些无关紧要的延伸的定义也没必要抠得很明白。当然也没法 100% 搞清背后的动机，毕竟都是基于先前已有的论文成果往上堆。\n欢迎讨论。\n","date":"2023-08-22T00:00:00Z","permalink":"https://example.com/study/paper1/","title":"读论文系列 #1——串与 DAG 的 LCS"},{"content":"这是一篇学习笔记。\r提供一个 $\\mathrm{O}(Tn^3m)$ 的做法，目前在各 oj 上是 rank 1，运行时间为第二名的 $\\frac{1}{6}$ 以内。\n类似于本题解的方法不建议在考试中使用，非常耗时间。并且公式很丑。\n坐稳了！！\nStep 1 @Alex_Wei 已经把严谨的结构刻画讲清楚了，这里再写一下自己的理解（本质上是等价的），看起来不大优美，但比较直观。\n对于一个完整的序列 $a_{1\\cdots n}$，找出其最长的前缀 $a_{1\\cdots r}$，满足：前缀中 $\\le a_r$ 的数严格递增，$\\ge a_r$ 的数严格递减，类似于形成一个尖角。接下来暂时默认 $r\u0026lt;n$。\n如果 $a_{r+1}=a_r$，那么要求 $a_{r+1\\cdots n}$ 中，$\\le a_r$ 的数严格递减，$\\ge a_r$ 的数严格递增。这种情况恰好有 $2$ 种染色方案且得分相同。\n否则，记 $a_{1\\cdots r}$ 中最大的 $\u0026lt;a_r$ 的数为 $D$（不存在则为 $0$），最小的 $\u0026gt;a_r$ 的数为 $U$（不存在则为 $m+1$），不妨设 $a_{r+1}\\le D$（与之对称的一种情况是 $\\ge U$）。现在找到以 $a_{r+1}$ 开头的最长严格递减子段，如果子段末尾还有下一项，则记为 $a_s$，否则肯定是完美的。\n结论：此时完美数组的充要条件是，在 $a_{r+1\\cdots n}$ 中，$\\le a_{r+1}$ 的数严格递减，不存在 $(a_{r+1},a_r]$ 以内的数，且 $\\ge a_s$ 的数严格递增。\n如图，这是一个完美数组的例子（横坐标为下标，纵坐标为值）：\n它共有 $4$ 种染色方案，分别对应着下图中全不选/选一个黄色点染成绿色，其他黄色点染成红色：\n如果 $a_s\\in (D,a_r]$，那么只有 $1$ 种染色方案，以下是一例；如果 $a_s\\in (a_{r+1},D]$ 则无染色方案。\n同时，通过观察例子，可以发现多种染色方案一定是形如：一段前后缀颜色固定，中间剩下的区间，它有一个染色方案是全染红/绿，其余方案仅通过选其中某一个反转颜色得到。若 $a_{r+1}\\le D$，则允许变颜色的点是以 $(a_U^{-1},U)$ 为左上角，$(r+1, a_{r+1})$ 为右下角的矩形以内的点。这部分实际上是递增的，且相对值域是连续的。$a_{r+1}\\ge U$ 类似。\n以上的证明都是容易的，需要一些分类讨论。\n考虑哪种染色方案得分最大，容易发现最后一个可以变的点变色一定比其他点变色更优。因此最优染色一定是：$a_{1\\cdots r-1}$ 中 $\u0026lt;a_r$ 的和 $a_{r+1\\cdots n}$ 中 $\u0026gt;a_r$ 的染红色，$a_{1\\cdots r-1}$ 中 $\u0026gt;a_r$ 的和 $a_{r+1\\cdots n}$ 中 $\u0026lt;a_r$ 的染绿色，$a_r$ 两种均有可能。\nStep 2 下文中 $r,U,D$ 的含义不变。称出现了满足 $a_{r+1}=a_r$ 或 $\\le D$ 或 $\\ge U$ 的情况为“交叉”，$a_r$ 为“交叉点”。称 $a_{1\\cdots t}$ 为“前面”，$a_{t+1\\cdots n}$ 为“后面”。组合数里只要有负数结果就是 $0$，除了 $\\binom{-1}{-1}=1$。\n回到原问题。先来道开胃菜：前面已经交叉了。这时可以由 $a_{1\\cdots t}$ 确定后面染绿部分必须要小于某个值 $L$，染红部分必须要大于某个值 $R$。\n枚举后面有 $i$ 个染绿的。方案数为： $$ \\binom{L-1}{i}\\binom{m-R}{n-t-i}\\binom{n-t}{i} $$ 得分贡献为： $$ \\begin{aligned} \u0026amp;\\left[\\sum_{j\u0026lt;L}\\sum_{k\\le t}[a_k\u0026lt;j]j\\right]\\binom{L-2}{i-1}\\binom{m-R}{n-t-i}\\binom{n-t}{i}\\\\ +{}\u0026amp;\\left[\\sum_{j\u0026gt;R}\\sum_{k\\le t}[a_k\u0026gt;j](m-j+1)\\right]\\binom{L-1}{i}\\binom{m-R-1}{n-t-i-1}\\binom{n-t}{i} \\end{aligned} $$ 可以共 $\\mathrm{O}(n+m)$ 计算。另外需要求前面的贡献，可以用树状数组。\nStep 3 前面尚未交叉时，为了简化起见，分 $a_r;\\fbox{\u0026lt;/=/\u0026gt;};a_t$ 讨论。$a_r=a_t$ 也就是 $r=t$，这时暴力枚举 $a_{r+1}$ 后套用 Step 2 方法，时复只有两次方。\n$a_r\u0026gt;a_t$ 与 $a_r\u0026lt;a_t$ 的算法完全相同。下记 $L$ 为前面最大的 $\u0026lt;a_t$ 的数（不存在则为 $0$），$R=a_r$，$X$ 为前面 $\\le L$ 的数的个数，$Y=t-X$。\n求方案数可以用 dp。交叉之前，想象“识别尖角”的过程，每次新加入的 $a$ 允许处于两个区间中：\n实际计数时，只需要钦定一个区间就行了，一般不会计重。于是 $f_{i,j,k}$ 表示，交叉之前，$a_i=j$，区间另一个端点为 $k$ 的方案数。一种转移是枚举 $a_{i+1}$，然后转移到 $f_{i,a,j/k}$。\n$g_{i,j,k}$ 表示交叉之后，上一个染绿的为 $j$ ，上一个染红的为 $k$ 的方案数，转移略。$f$ 在 $i$ 作为 $r$ 时要转移给 $g$，为了避免信息不够无法转移以及计重的情况，$j\u0026gt;k$ 的 $f_{i,j,k}$ 只枚举 $a_{i+1}\\le k$ 以及 $a_{i+1}=a_i$ 的情况进行贡献，$j\u0026lt;k$ 的只枚举 $a_{i+1}\\ge k$ 的情况进行贡献。\n以上 dp 均可以用前缀和优化做到 $\\mathrm{O}(nm^2)$，但是这个 dp 无法类推求出得分和，我们放弃 dp，尝试直接推式子。同样地，还是只考虑 $a_{r+1}\\le D$、 $a_{r+1}=a_r$ 以及 $r=n$ 的情况，$a_{r+1}\\ge U$ 情况可以将 $a_i\\mapsto m-a_i+1$ 后套用 $a_{r+1}\\le D$ 的算法。\n首先，后面的结构大致包含这些要素：交叉前 $\u0026lt;a_r$ 的数个数、交叉前 $\u0026gt;a_r$ 的数个数、$r$、$a_r$、$a_{r+1}$、交叉后 $\u0026lt;a_r$ 的数个数、交叉后 $\u0026gt;a_r$ 的数个数。考虑枚举其中一些。\n对于 $a_{r+1}\\le D$，枚举交叉前 $\u0026lt;a_r$ 的数个数 $i$，交叉前 $\u0026gt;a_r$ 的数个数 $j$，交叉后 $\u0026lt;a_r$ 的数个数 $k$，方案数为： $$ \\begin{aligned} \u0026amp;\\sum_{a_r}\\sum_{D\u0026lt;a_r}\\textcolor{red}{\\binom{D-L-1}{i-1}\\binom{m-a_r}{n-t-i-j-k-1}}\\textcolor{green}{\\binom{D}{k}\\binom{R-a_r-1}{j}}\\textcolor{blue}{\\binom{i+j}{i}\\binom{n-t-i-j-2}{k-1}}\\\\ ={}\u0026amp;\\binom{i+j}{i}\\binom{n-t-i-j-2}{k-1}\\sum_{a_r}\\left[\\sum_{D\u0026lt;a_r}\\binom{D-L-1}{i-1}\\binom{D}{k}\\right]\\binom{R-a_r-1}{j}\\binom{m-a_r}{n-t-i-j-k-1}\\\\ ={}\u0026amp;\\binom{i+j}{i}\\binom{n-t-i-j-2}{k-1}\\sum_{a_r}C_D(i,k,a_r)\\cdot C_U(j,n-t-i-j-k-1,a_r) \\end{aligned} $$ 红色表示染红部分的方案数，绿色表示染绿部分的方案数，蓝色表示“交织”的方案数。枚举 $D$ 会比枚举 $a_{r+1}$ 稍微方便一点。$C_D$ 和 $C_U$ 主要是为了突出有关变量仅有三个（预处理即可）。\n对于 $a_{r+1}=a_r$，枚举 $l=r-t-1$ 以及 $a_r$，方案数为： $$ \\begin{aligned} \u0026amp;\\sum_i\\sum_k\\textcolor{red}{\\binom{a_r-L-1}{i}\\binom{m-a_r}{n-t-l-k-2}}\\textcolor{green}{\\binom{R-a_r-1}{l-i}\\binom{a_r-1}{k}}\\textcolor{blue}{\\binom{l}{i}\\binom{n-t-l-2}{k}}\\\\ ={}\u0026amp;\\left[\\sum_i\\binom{a_r-L-1}{i}\\binom{R-a_r-1}{l-i}\\binom{l}{i}\\right]\\left[\\sum_k\\binom{a_r-1}{k}\\binom{m-a_r}{n-t-l-k-2}\\binom{n-t-l-2}{k}\\right]\\\\ ={}\u0026amp;C_L(l,a_r)\\cdot C_R(n-t-l-2,a_r) \\end{aligned} $$ 这里明确一下组合意义：\n$C_D(i,j,a)$ 表示 $a_r=a$，要安排 $\u0026lt;a_r$ 的数，交叉前个数为 $i$，交叉后个数为 $j$ 的方案数。 $C_U(i,j,a)$ 表示 $a_r=a$，要安排 $\u0026gt;a_r$ 的数，交叉前个数为 $i$，交叉后个数为 $j$ 的方案数。 $C_L(i,a)$ 表示 $a_r=a$，要安排 $r$ 之前的数共 $i$ 个的方案数（不考虑交叉条件）。 $C_R(i,a)$ 表示 $a_r=a$，要安排 $r$ 之后的数共 $i$ 个的方案数（不考虑交叉条件）。 $r=n$ 的情况可以顺便计入。总体来说，计算方案数为 $\\mathrm{O}(n^3m)$，实际表现比 dp 还快。下面是计算得分和，思路与求方案数类似。\nStep 4 以下 $a_r=a_{r+1}$ 情况部分时间复杂度都是 $\\mathrm{O}(n^2m)$，一般情况部分则是 $\\mathrm{O}(n^3m)$。代码中的顺序和分析的顺序是一样的。\n交叉前下部 首先，不考虑交叉后部分与交叉前上部数值的安排，它们充其量就是外面乘一个系数。枚举交叉前 $\u0026lt;a_r$ 的数个数 $i$，交叉前 $\u0026gt;a_r$ 的数个数 $j$，以及 $D$，该部分得分为： $$ \\begin{aligned} \u0026amp;\\sum_{p=1}^i\\left[\\sum_{q=0}^j\\binom{p-1+q}{p-1}\\binom{i-p+j-q}{i-p}(q+Y)\\right]\\left[\\sum_{a=L+1}^D\\binom{a-L-1}{p-1}\\binom{D-a-1}{i-p-1}(m-a+1)\\right]\\\\ ={}\u0026amp;\\sum_{p=1}^i\\left[\\binom{i+j}{i+1}p+\\binom{i+j}{i}Y\\right]\\left[\\binom{D-L-1}{i-1}(m-L+1)-\\binom{D-L}{i}p\\right]\\\\ ={}\u0026amp;\\binom{i+j}{i}\\binom{D-L-1}{i-1}\\left[\\frac{ij(m-L+1)}{2}-\\frac{(2i+1)j(D-L)}{6}+iY(m-L+1)-\\frac{(i+1)Y(D-L)}{2}\\right] \\end{aligned} $$ 其中 $p$ 枚举交叉前下部的第几个数（称为“它”），$q$ 枚举有交叉前上部有几个数在它前面，$a$ 枚举它的值。第一个等号是利用 Vandermonde 恒等式，第二个等号就是正整数次方求和。记该式为 $(*)$。\n接下来再把剩余未确定的部分确定，枚举交叉后 $\u0026lt;a_r$ 的数个数 $k$，最终得分为： $$ \\begin{aligned} \u0026amp;\\sum_{a_r\u0026gt;D}(*)\\binom{R-a_r-1}{j}\\binom{D}{k}\\binom{m-a_r}{n-t-i-j-k-1}\\binom{n-t-i-j-2}{k-1}\\\\ ={}\u0026amp;(*)\\binom{D}{k}\\binom{n-t-i-j-2}{k-1}\\sum_{a_r\u0026gt;D}C_U(j,n-t-i-j-k-1,a_r)\\\\ ={}\u0026amp;(*)\\binom{D}{k}\\binom{n-t-i-j-2}{k-1}C^\\prime_U(j,n-t-i-j-k-1,D) \\end{aligned} $$ 预处理 $C_U(i,j,*)$ 的后缀和就不用枚举 $a_r$ 了。\n交叉前上部 思路是差不多的。先枚举交叉前 $\u0026lt;a_r$ 的数个数 $i$，交叉前 $\u0026gt;a_r$ 的数个数 $j$，以及 $a_r$，该部分得分为： $$ \\begin{aligned} \u0026amp;\\sum_{p=1}^j\\left[\\sum_{q=0}^i\\binom{p-1+q}{p-1}\\binom{j-p+i-q}{j-p}(q+X)\\right]\\left[\\sum_{a=a_r+1}^{R-1}\\binom{R-a-1}{p-1}\\binom{a-a_r-1}{j-p}a\\right]\\\\ ={}\u0026amp;\\sum_{p=1}^j\\left[\\binom{i+j}{j+1}p+\\binom{i+j}{j}X\\right]\\left[\\binom{R-a_r-1}{j}R-\\binom{R-a_r}{j+1}p\\right]\\\\ ={}\u0026amp;\\binom{i+j}{j}j\\left[\\binom{R-a_r-1}{j}\\left(\\frac{i}{2}+X\\right)R-\\binom{R-a}{j+1}\\left(\\frac{i(2j+1)}{6}+\\frac{(j+1)X}{2}\\right)\\right] \\end{aligned} $$ 抱歉让强迫症难受了，没法化得对称，否则分母上就会有未知数，得乘逆元了 /lb。\n剩余未确定的部分的方案数同理，枚举一下 $k$，就不写了，要乘 $C_D$ 等。\n另外 $a_{r+1}=a_r$ 和 $r=n$ 的情况的交叉前也可以方便地在这里算掉（反正都枚举 $a_r$ 了）。交叉前下部里就不用算了，会在 $a_i\\mapsto m-a_i+1$ 时当成上部算掉。\n另一种思路是不推上部，直接推 $a_{r+1}\u0026gt;a_r$ 情况的下部，我没试过，应该也是可以的。\n交叉点 枚举交叉前 $\u0026lt;a_r$ 的数个数 $i$，交叉前 $\u0026gt;a_r$ 的数个数 $j$，交叉后 $\u0026lt;a_r$ 的数个数 $k$，最终得分为： $$ \\sum_{a_r}C_D(i,k,a_r)\\cdot C_U(j,n-t-i-j-k-1,a_r)\\cdot\\max((Y+j)(m-a_r+1),(X+i)a_r) $$ $a_{r+1}=a_r$ 的部分可能要特殊考虑一下，代码里处理的思路是和交叉前放在一起算，直接乘 $C_R$，就不用枚举 $k$ 了。\n交叉后下部 交叉后就无需考虑 $r=n$ 了。先不考虑上部与“交织”的安排。枚举交叉前 $\u0026lt;a_r$ 的数个数 $i$，交叉后 $\u0026lt;a_r$ 的数个数 $k$，以及 $D$，该部分得分为：\n$$ \\begin{aligned} \u0026amp;\\sum_{i\\le t,a_i\\le L}\\sum_{p=a_i+1}^D\\binom{D-L-1}{i-1}\\binom{D-1}{k-1}p+\\sum_{a=L+1}^D\\sum_{p=a+1}^D\\binom{D-L-2}{i-2}\\binom{D-1}{k-1}p\\\\ =\u0026amp;\\binom{D-1}{k-1}\\left[\\binom{D-L-1}{i-1}\\underline{\\sum_{i\\le t,a_i\\le L}\\frac{(a_i+1+D)(D-a_i)}{2}}_{f_0(D)}+\\binom{D-L-2}{i-2}\\underline{\\sum_{a=L+1}^D\\frac{(a+1+D)(D-a)}{2}}_{f(D)}\\right] \\end{aligned} $$\n其中 $p$ 枚举的是交叉后下部的某个数值。记该式为 $(*)$。划线部分可以预处理。\n考虑剩余部分，枚举交叉前 $\u0026gt;a_r$ 的数个数 $j$，最终得分为： $$ (*)\\binom{i+j}{i}\\binom{n-t-i-j-2}{k-1}C^\\prime_U(j,n-t-i-j-k-1,D) $$\n交叉后上部 $$ {\\underline{a}{f}}{\\underline{b}{f}} $$\n先枚举交叉前 $\u0026gt;a_r$ 的数个数 $j$，交叉后 $\u0026gt;a_r$ 的数个数 $k$，以及 $a_r$，该部分得分为： $$ \\binom{m-a_r-1}{k-1}\\underline{\\left[\\binom{R-a_r-1}{j}\\sum_{i\\le t,a_i\\ge R}\\frac{(2m-a_i-a_r+2)(a_i-a_r-1)}{2}+\\binom{R-a_r-2}{j-1}\\sum_{a=a_r+1}^{R-1}\\frac{(2m-a-a_r+2)(a-a_r-1)}{2}\\right]}_{F(j,a_r)} $$ 最终得分同理也是要乘 $C_D$ 等，略。\n同样要处理一下 $a_{r+1}=a_r$，要做到三次方还得分离一下变量： $$ \\begin{align} \u0026amp;\\sum_{i,j,k,a_r}\\binom{a_r-L-1}{i}\\binom{m-a_r-1}{k-1}F(j,a_r)\\binom{a_r-1}{n-t-i-j-k-2}\\binom{i+j}{j}\\binom{n-t-i-j-2}{k}\\\\ =\u0026amp;\\sum_{a_r}\\sum_l\\left[\\sum_i\\binom{a_r-L-1}{i}F(l-i,a_r)\\binom{l}{i}\\right]\\left[\\sum_k\\binom{a_r-1}{n-t-l-k-2}\\binom{m-a_r-1}{k-1}\\binom{n-t-l-2}{k}\\right] \\end{align} $$ $l$ 就是 $i+j$ 换元，跟 Step 3 里的 $l$ 是一样的。注意第二个中括号里的不是 $C_R$。\nStep 5 说一下优化：我们希望瓶颈部分（四次方的最内层循环）运算次数尽量少，所以可以把只涉及到一部分变量的乘法先预处理掉，把能用分配律的乘法提到外层。\n然后就是 $18$ 次一取模优化。\nCode #define ansc ans. first #define anss ans. second int calcP() { int res = 0; CL (tree); for (int i=1; i\u0026lt;=t; i++) update(A[i]), res += c[i] ? getsum(A[i] - 1) * A[i] : (i - getsum(A[i])) * (m - A[i] + 1); return res; } pii calcX(int L, int R) { pii ans (0, 0); CL (cnt); int pre = calcP(), sumd = 0, sumu = 0; if (t == n) return {1, pre}; for (int i=1; i\u0026lt;=t; i++) cnt[A[i]] ++; for (int i=1; i\u0026lt;L; i++) sumd += cnt[i-1] * i, cnt[i] += cnt[i-1]; for (int i=m; i\u0026gt;R; i--) sumu += cnt[i+1] * (m - i + 1), cnt[i] += cnt[i+1]; for (int i=max(0,n-t-m+R); i\u0026lt;=min(L-1,n-t); i++) { ansc = (ansc + 1ll * C[L-1][i] * C[m-R][n-t-i] % MOD * C[n-t][i]) % MOD; if (i) anss = (anss + 1ll * C[L-2][i-1] * C[m-R][n-t-i] % MOD * C[n-t][i] % MOD * sumd) % MOD; if (n - t - i) anss = (anss + 1ll * C[L-1][i] * C[m-R-1][n-t-i-1] % MOD * C[n-t][i] % MOD * sumu) % MOD; } anss = (anss + 1ll * ansc * pre) % MOD; return ans; } pii calcI(int L, int R, bool flag) { pii ans (0, 0); CL (CD), CL (CU), CL (CUS), CL (CR); for (int k=0; k\u0026lt;n-t; k++) for (int a=L+1; a\u0026lt;=m; a++) CD[0][k][a] = C[L][k]; for (int i=1; i\u0026lt;n-t; i++) for (int k=0; k\u0026lt;n-t-i; k++) for (int a=L+i+1; a\u0026lt;=m; a++) CD[i][k][a] = (CD[i][k][a-1] + 1ll * C[a-L-2][i-1] * C[a-1][k]) % MOD; for (int j=0; j\u0026lt;n-t; j++) for (int k=0; k\u0026lt;n-t-j; k++) for (int a=R-j-1; a\u0026gt;0; a--) CU[j][k][a] = 1ll * C[R-a-1][j] * C[m-a][k] % MOD, CUS[j][k][a] = P(CUS[j][k][a+1], CU[j][k][a+1]); for (int l=0; l\u0026lt;n-t; l++) for (int a=1; a\u0026lt;=m; a++) for (int k=0; k\u0026lt;=l; k++) CR[l][a] = (CR[l][a] + 1ll * C[a-1][k] * C[m-a][l-k] % MOD * C[l][k]) % MOD; for (int i=0; i\u0026lt;n-t-1; i++) for (int j=0; j\u0026lt;n-t-i-1; j++) for (int k=1; k\u0026lt;n-t-i-j; k++) { ull res = 0; for (int a=L+i+1, _=0; a\u0026lt;=R-j-1; a++) { ADD(1ll * CD[i][k][a] * CU[j][n-t-i-j-k-1][a]); } res %= MOD; ansc = (ansc + 1ll * C[i+j][i] * C[n-t-i-j-2][k-1] % MOD * res) % MOD; } if (flag) for (int l=0; l\u0026lt;n-t; l++) for (int a=L+1; a\u0026lt;=R-1; a++) { int CL = 0; for (int i=0; i\u0026lt;=l; i++) CL = (CL + 1ll * C[a-L-1][i] * C[R-a-1][l-i] % MOD * C[l][i]) % MOD; ansc = (ansc + 1ll * CL * (l \u0026lt; n - t - 1 ? CR[n-t-l-2][a] : 1)) % MOD; } for (int i=1; i\u0026lt;n-t-1; i++) for (int j=0; j\u0026lt;n-t-i-1; j++) { for (int a=L+i; a\u0026lt;=R-j-2; a++) F[a] = (i3 * j * (3 * i * (m - L + 1) - (2 * i + 1) * (a - L)) + Y * (2 * i * (m - L + 1) - (i + 1) * (a - L))) % MOD * i2 % MOD * C[i+j][i] % MOD * C[a-L-1][i-1] % MOD; for (int k=1; k\u0026lt;n-t-i-j; k++) { ull res = 0; for (int a=L+i, _=0; a\u0026lt;=R-j-2; a++) { ADD(1ll * C[a][k] * CUS[j][n-t-i-j-k-1][a] % MOD * F[a]); } res %= MOD; anss = (anss + 1ll * C[n-t-i-j-2][k-1] * res) % MOD; } } for (int i=0; i\u0026lt;n-t; i++) for (int j=0; j\u0026lt;n-t-i; j++) { for (int a=L+i+1; a\u0026lt;=R-j-1; a++) F[a] = (1ll * C[R-a-1][j] * R * (i + 2 * X) + i3 * (MOD - C[R-a][j+1]) % MOD * (i * (2 * j + 1) + 3 * (j + 1) * X)) * j % MOD * i2 % MOD * C[i+j][j] % MOD; if (j) if (i + j \u0026lt; n - t - 1) for (int k=0; k\u0026lt;n-t-i-j-1; k++) { ull res = 0; for (int a=L+i+1, _=0; a\u0026lt;=R-j-1; a++) { ADD(1ll * C[m-a][k] * CD[i][n-t-i-j-k-1][a] % MOD * F[a]); } res %= MOD; anss = (anss + 1ll * C[n-t-i-j-2][k] * res) % MOD; } else for (int a=L+i+1; a\u0026lt;=R-j-1; a++) anss = (anss + 1ll * CD[i][0][a] * F[a]) % MOD; if (i + j \u0026lt; n - t - 1) for (int a=L+i+1; a\u0026lt;=R-j-1; a++) anss = (anss + 1ll * (F[a] + 1ll * (X + i) * a * C[R-a-1][j] % MOD * C[i+j][i]) % MOD * C[a-L-1][i] % MOD * CR[n-t-i-j-2][a]) % MOD; } for (int i=0; i\u0026lt;n-t; i++) for (int j=0; j\u0026lt;n-t-i; j++) for (int k=0; k\u0026lt;n-t-i-j; k++) { ull res = 0; for (int a=L+i+1, wr=(Y+j)*(m-a+1), wg=(X+i)*a; a\u0026lt;=R-j-1; a++, wr-=Y+j, wg+=X+i) { res += 1ll * CD[i][k][a] * CU[j][n-t-i-j-k-1][a] % MOD * max(wr, wg); } res %= MOD; if (i + j == n - t - 1 \u0026amp;\u0026amp; flag) anss = (anss + 1ll * C[i+j][i] * res) % MOD; else if (k) anss = (anss + 1ll * C[i+j][i] * C[n-t-i-j-2][k-1] % MOD * res) % MOD; } CL (f0), CL (f); for (int a=L; a\u0026lt;=R-2; a++) { for (int i=1; i\u0026lt;=t; i++) if (A[i] \u0026lt;= L) f0[a] += (A[i] + 1 + a) * (a - A[i]) \u0026gt;\u0026gt; 1; for (int i=L+1; i\u0026lt;=a; i++) f[a] += (i + 1 + a) * (a - i) \u0026gt;\u0026gt; 1; } for (int i=0; i\u0026lt;n-t-1; i++) for (int k=1; k\u0026lt;n-t-i; k++) { if (! i) { F[L] = L ? 1ll * C[L-1][k-1] * f0[L] % MOD : 0; for (int a=L+1; a\u0026lt;=R-2; a++) F[a] = 0; } else for (int a=L+i; a\u0026lt;=R-2; a++) F[a] = (1ll * C[a-L-1][i-1] * f0[a] + (i \u0026gt; 1 ? 1ll * C[a-L-2][i-2] * f[a] : 0)) % MOD * C[a-1][k-1] % MOD; for (int j=0; j\u0026lt;n-t-i-k; j++) { ull res = 0; for (int a=L+i, _=0; a\u0026lt;=R-j-2; a++) { ADD(1ll * CUS[j][n-t-i-j-k-1][a] * F[a]); } res %= MOD; anss = (anss + 1ll * C[i+j][i] * C[n-t-i-j-2][k-1] % MOD * res) % MOD; } } CL (f0), CL (f), CL (_F); for (int a=L+1; a\u0026lt;=R-1; a++) { for (int i=1; i\u0026lt;=t; i++) if (A[i] \u0026gt;= R) f0[a] += (2 * (m + 1) - A[i] - a) * (A[i] - a - 1) \u0026gt;\u0026gt; 1; for (int i=a+1; i\u0026lt;=R-1; i++) f[a] += (2 * (m + 1) - i - a) * (i - a - 1) \u0026gt;\u0026gt; 1; } for (int j=0; j\u0026lt;n-t-1; j++) { for (int a=L+1; a\u0026lt;=R-j-1; a++) _F[a][j] = (1ll * C[R-a-1][j] * f0[a] + (j ? 1ll * C[R-a-2][j-1] * f[a] : 0)) % MOD; for (int k=1; k\u0026lt;n-t-j-1; k++) { for (int a=L+1; a\u0026lt;=R-j-1; a++) F[a] = a \u0026lt; m ? 1ll * C[m-a-1][k-1] * _F[a][j] % MOD : 0; for (int i=0; i\u0026lt;n-t-j-k-1; i++) { ull res = 0; for (int a=L+i+1, _=0; a\u0026lt;=R-j-1; a++) { ADD(1ll * CD[i][n-t-i-j-k-1][a] * F[a]); } res %= MOD; anss = (anss + 1ll * C[i+j][j] * C[n-t-i-j-2][k] % MOD * res) % MOD; } } } for (int l=0; l\u0026lt;n-t-1; l++) for (int a=L+1; a\u0026lt;=min(R-1,m-1); a++) { int res1 = 0, res2 = 0; for (int i=max(0,a-R+l+1); i\u0026lt;=min(l,a-L-1); i++) res1 = (res1 + 1ll * C[a-L-1][i] * C[l][i] % MOD * _F[a][l-i]) % MOD; for (int k=1; k\u0026lt;n-t-l-1; k++) res2 = (res2 + 1ll * C[n-t-l-2][k] * C[a-1][n-t-l-k-2] % MOD * C[m-a-1][k-1]) % MOD; anss = (anss + 1ll * res1 * res2) % MOD; } return ans; } pii calcF(int L, int R) { pii ans (0, 0); ans += calcI(L, R, 1); for (int i=1; i\u0026lt;=t; i++) A[i] = m - A[i] + 1; swap(X, Y); ans += calcI(m - R + 1, m - L + 1, 0); for (int i=1; i\u0026lt;=t; i++) A[i] = m - A[i] + 1; swap(X, Y); anss = (anss + 1ll * ansc * calcP()) % MOD; return ans; } pii calcN() { pii ans (0, 0); c[t] = 1, Y ++, ans += calcF(L, A[t]), Y --; c[t] = A[t] * X \u0026gt; (m - A[t] + 1) * Y, t ++; for (int i=1; i\u0026lt;=L; i++) A[t] = i, c[t] = 1, ans += calcX(i, A[t-1]); c[t] = c[t-1] ^ 1, ans += calcX(A[t-1], A[t] = A[t-1]); for (int i=R; i\u0026lt;=m; i++) A[t] = i, c[t] = 0, ans += calcX(A[t-1], i); t --; c[t] = 0, X ++, ans += calcF(A[t], R), X --; return ans; } int main() { for (int i=0; i\u0026lt;=200; i++) { C[i][0] = 1; for (int j=1; j\u0026lt;=min(i,50); j++) C[i][j] = P(C[i-1][j-1], C[i-1][j]); } cin \u0026gt;\u0026gt; T; while (T --) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; t, L = X = Y = 0, R = m + 1; for (int i=1; i\u0026lt;=t; i++) scanf (\u0026#34;%d\u0026#34;, \u0026amp;A[i]); for (int i=2; i\u0026lt;=t; i++) if (L \u0026lt; R) if (L \u0026lt; A[i] \u0026amp;\u0026amp; A[i] \u0026lt; A[i-1]) R = A[i-1], c[i-1] = 1, Y ++; else if (A[i-1] \u0026lt; A[i] \u0026amp;\u0026amp; A[i] \u0026lt; R) L = A[i-1], c[i-1] = 0, X ++; else if (A[i] == A[i-1]) L = R = A[i], c[i-1] = 0, c[i] = 1; else { c[i-1] = A[i-1] * X \u0026gt; (m - A[i-1] + 1) * Y; if (A[i] \u0026lt; A[i-1]) L = A[i-1], R = A[i], c[i] = 1; else L = A[i], R = A[i-1], c[i] = 0; } else if (A[i] \u0026gt; L) L = A[i], c[i] = 0; else if (A[i] \u0026lt; R) R = A[i], c[i] = 1; else { ans = {0, 0}; goto O; } if (L \u0026lt; R \u0026amp;\u0026amp; t == n) c[n] = A[n] * X \u0026gt; (m - A[n] + 1) * Y, L = R = 0; ans = L \u0026gt;= R ? calcX(R, L) : calcN(); O : printf (\u0026#34;%d %d\\n\u0026#34;, ansc, anss); } } ","date":"2023-08-17T00:00:00Z","permalink":"https://example.com/study/solution-lgp9171/","title":"[题解] lgP9171 [省选联考 2023] 染色数组"},{"content":"这是一篇学习笔记。\r同学打月赛后告诉我有道很离谱的题，遂做，确实挺离谱的，这里讲一下自己做的思路。\n题意 给定 $n$，平面直角坐标系上有点 $(0,0)\\sim(0,n-1),(1,0)\\sim(1,n-1)$。对于一个 $n$ 排列 $p$，对每个 $i$ 连线段 $(0,i)-(1,p_i)$。 考虑从每个横坐标为 $0$ 的点出发，依附于这些线段各走一条折线（或线段）到达一个横坐标为 $1$ 的点，这些折线（或线段）仅能在原先 $n$ 条线段的交点上重合。 求所有 $p$ 的方案数之积${}\\bmod{335544323}$。 $n\\le 10^6$。 Step 1 方便起见称原题中完美匹配（简称匹配）的连线为 “线段”，染色的折线（或线段）为 “路径”。\n模拟一些例子，发现三点：\n路径不会 “往回折” 且线段没有任何部分不被经过。 选择一条路径在（最后）一个交点的走向，剩余的东西并没有本质不同，感性地说像是有一个乘法原理。 三线段交于同一点和三线段交于三个点的方案数是不同的，也就是说这个几何背景是有用的。 可以证明第一点：考虑任一横坐标 $x_0$ 满足原先 $n$ 条线段的交点均不在 $x=x_0$ 上，这时原图有 $n$ 个点在 $x=x_0$ 上，而每一条路径至少穿过一次 $x=x_0$。如果有一条路径往回折，那就穿过某个 $x=x_0$ 大于一次，这就不可能存在 $n$ 条两两交长度 $=0$ 的路径了。\n进一步分析，发现一个 “$k$ 线共点” 的情况会对答案贡献 $k!$。因为这个局部相当于一个 $k$ 阶匹配以决定每条路径的走向，且每种方案显然都是合法的。因此最有可能的思路大概就是对于每个可能的交点，求出每种匹配情况下有几条线段经过它，然后阶乘乘起来贡献给答案。当然不能像这样直接算。\n显然贡献值只取决于该交点最多被几条线段经过（显然这些线段的端点均不同，所以相当于是一个选择问题），故可以求出 $w_k$ 表示将所有可能的 $n^2$ 条线段画出后 $k$ 线共点的情况数，$p_k$ 表示一个至多作为 $k$ 条线段交点的点在所有匹配情况下对答案的总贡献。就有：\n$$ ans=\\prod_{k=2}^n p_k^{w_k} $$\nStep 2 求 $w_k$。考虑刻画线段交于一点的情况。\n（为了美观横过来了）由图中相似关系可见，两边选的相邻点距离要对应成比例。\n第一反应是直接硬着对极大共点选择（一些线段交于同一点，且不能再多选一条经过该交点的线段。显然这些线段的端点均不同）计数，官方解法有更方便的容斥做法，这里就算给一个备选方案了。极大共点选择的条件为：\n两边选的点纵坐标分别成等差数列； 不能再往左右扩展； 公差互质。 首先发现互质条件无法直接处理，因此莫反，枚举公差的公因数 $g$，贡献乘 $\\mu(g)$ 即可。如果考虑左右部分别长为 $x$ 和 $y$ 的极长等差数列，那么画图可得它们能构成的极大共点选择包括：$2$ 个 $2$ 线共点，$2$ 个 $3$ 线共点，……，$2$ 个 $\\min(x,y)-1$ 线共点，$\\lvert x-y\\rvert+1$ 个 $\\min(x,y)$ 线共点。\n那么只需对于每个 $g$，把每种为 $g$ 倍数的公差所能形成的极长等差数列长度及其数量求出来，统计并扫描处理即可。由于一个公差 $d$ 至多只能产生 $\\lfloor (n-1)/d\\rfloor+1$ 与 $\\lfloor (n-1)/d\\rfloor$ 两种长度，而扫描可以优化到线性（枚举长较小者，部分细节略去），故这部分可以做到 $\\mathrm{O}(n\\log n)$。\nStep 3 直接求 $p_k$ 的思路为：对于每个 $i=1,\\cdots,k$，求出有多少种匹配恰好出现 $i$ 条线段经过该点，记为 $f_i$，则：\n$$ p_k=\\prod_{i=1}^k (i!)^{f_i} $$\n$f_i$ 无法直接计算，记 $g_i$ 表示钦定 $i$ 条线段经过该点，其他随便匹配的方案数（可能会算重）。则：\n$$ \\binom ki(n-i)!=g_i=\\sum_{j=i}^k\\binom jif_i $$\n二项式反演得：\n$$ f_i=\\sum_{j=i}^k(-1)^{j-i}\\binom ji\\binom kj(n-j)! $$\n然后就会发现没法快速求出 $p_i$（如果有大佬会的能教一下吗/kel\nStep 4 既然没法快速求 $p_i$，那么考虑利用最终只需求一个积这个性质，把所有 $k$ 放在一起求。记：\n$$ c_i=\\sum_{k=i}^nw_k\\sum_{j=i}^k(-1)^{j-i}\\binom ji\\binom kj(n-j)! $$\n则：\n$$ ans=\\prod_{i=2}^n(i!)^{c_i} $$\n而 $c_i$ 是可以快速求的：\n$$ c_i=\\sum_{j=i}^n(-1)^{j-i}\\binom ji(n-j)!\\left(\\sum_{k=j}^n w_k\\binom kj\\right) $$\n两次差卷积即可。细节略去。\nStep 5 最后一个问题是 $c_i$ 是在指数上的。注意到原模数为质数 $335544323=2^{26}\\times 5+3$，因此如果能求出 $c_i$ 模 NTT 质数 $2^{25}\\times 5+1$ 与 $c_i$ 的奇偶性即可用 CRT 的思路还原 $c_i\\bmod (2^{26}\\times 5+2)$。\n一个性质是 $w_i\\equiv[i=n]\\pmod 2$（显然 $w_n=1$）。这是因为除了两部公差均为 $1$ 的情况，其余所有极大共点选择可以对应其两部交换后的另一个极大共点选择。那么：\n$$ \\begin{aligned}c_i\u0026amp;\\equiv\\sum_{j=i}^n\\binom ji\\binom nj(n-j)!\\\\ \u0026amp;\\equiv n\\binom{n-1}i+\\binom ni\\\\ \u0026amp;\\equiv(n-i+1)[i\\subseteq n]\\pmod 2\\end{aligned} $$\n最终时间复杂度为 $\\mathrm{O}(n\\log n)$。\n代码 一个优化：两次卷积分别要求类似于 $\\text{DFT}(\\mathrm{e}^x)$ 以及 $\\text{DFT}(\\mathrm{e}^{-x})$ 形式的东西，可以省掉一次。共 $5$ 次 DFT。\nvoid NTT(int n, int *a, int o) { for (int i=0; i\u0026lt;n; i++) if (i \u0026lt; f[i]) swap(a[i], a[f[i]]); for (int i=1, _; i\u0026lt;n; i\u0026lt;\u0026lt;=1) for (int j=0; j\u0026lt;n; j+=i\u0026lt;\u0026lt;1) for (int k=j; k\u0026lt;j+i; k++) _ = 1ll * g[i][k-j] * a[k+i] % P, a[k+i] = R(a[k], P - _), a[k] = R(a[k], _); if (o) { reverse (a+1, a+n); for (int i=0; i\u0026lt;n; i++) a[i] = 1ll * a[i] * I % P; } } int main() { cin \u0026gt;\u0026gt; n; for (int i=mu[1]=1; i\u0026lt;=n; i++) if (mu[i]) for (int j=i\u0026lt;\u0026lt;1; j\u0026lt;=n; j+=i) mu[j] -= mu[i]; for (int i=1; i\u0026lt;n; i++) L[i] = (n - 1) / i + 1, C[i] = (n - 1) % i + 1; for (int g=1; g\u0026lt;n; g++) { if (! mu[g]) continue; int m = 0, sl = 0, sc = 0; for (int i=g; i\u0026lt;n; i+=g) { if (m \u0026amp;\u0026amp; l[m-1] == L[i]) c[m-1] = R(c[m-1], C[i]); else if (l[m] == L[i]) c[m] = R(c[m], C[i]); else l[++m] = L[i], c[m] = C[i]; if (C[i] \u0026lt; i \u0026amp;\u0026amp; L[i] \u0026gt; 2) if (l[m] == L[i] - 1) c[m] = R(c[m], i - C[i]); else l[++m] = L[i] - 1, c[m] = i - C[i]; } for (int i=1; i\u0026lt;=m; i++) { w[l[i]] = (w[l[i]] + ((sl + 1ll * (P - l[i] + 1) * sc \u0026lt;\u0026lt; 1) + c[i]) % P * (~ mu[g] ? c[i] : P - c[i])) % P; d[l[i]-1] = (d[l[i]-1] + (2ll * sc + c[i]) * (~ mu[g] ? c[i] : P - c[i])) % P; sl = (sl + 1ll * l[i] * c[i]) % P, sc = R(sc, c[i]); } } for (int i=n; i\u0026gt;1; i--) d[i] = R(d[i], d[i+1]), w[i] = R(w[i], R(d[i], d[i])); for (int i=F[0]=1; i\u0026lt;=n; i++) F[i] = 1ll * F[i-1] * i % P; IF[n] = qpow(F[n], P - 2); for (int i=n-1; ~i; i--) IF[i] = 1ll * IF[i+1] * (i+1) % P; while (m \u0026lt; (n \u0026lt;\u0026lt; 1) - 3) m \u0026lt;\u0026lt;= 1; I = qpow(m, P - 2); for (int i=0; i\u0026lt;m; i++) f[i] = f[i\u0026gt;\u0026gt;1] \u0026gt;\u0026gt; 1 | (i \u0026amp; 1 ? m \u0026gt;\u0026gt; 1 : 0); for (int i=1; i\u0026lt;m; i\u0026lt;\u0026lt;=1) { g[i] = new int [i] {1}; if (i \u0026gt; 1) { g[i][1] = qpow(3, (P - 1) / (i \u0026lt;\u0026lt; 1)); for (int j=2; j\u0026lt;i; j++) g[i][j] = 1ll * g[i][j-1] * g[i][1] % P; } } for (int i=0; i\u0026lt;n-1; i++) a[i] = 1ll * F[n-i] * w[n-i] % P, b[i] = IF[i]; NTT(m, a, 0), NTT(m, b, 0); for (int i=0; i\u0026lt;m; i++) a[i] = 1ll * a[i] * b[i] % P; NTT(m, a, 1); for (int i=0; i\u0026lt;m; i++) a[i] = i \u0026lt; n - 1 ? 1ll * F[i] * a[i] % P : 0; for (int i=0; i\u0026lt;m\u0026gt;\u0026gt;1; i++) swap(b[i], b[i|m\u0026gt;\u0026gt;1]); NTT(m, a, 0); for (int i=0; i\u0026lt;m; i++) a[i] = 1ll * a[i] * b[i] % P; NTT(m, a, 1); for (int i=0; i\u0026lt;n-1; i++) c[n-i] = 1ll * IF[n-i] * a[i] % P; for (int i=2; i\u0026lt;=n; i++) if ((i \u0026amp; n) == i \u0026amp; n - i - 1 \u0026amp; 1 ^ c[i] \u0026amp; 1) c[i] += P; for (int i=n; i\u0026gt;1; i--) { if ((c[i] += c[i+1]) \u0026gt;= P2 - 1) c[i] -= P2 - 1; ans = 1ll * ans * qpow_(i, c[i]) % P2; } cout \u0026lt;\u0026lt; ans; } ","date":"2023-05-24T00:00:00Z","permalink":"https://example.com/study/solution-lgp9159/","title":"[题解] lgP9159 [GLR-R4] 大暑"}]