<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>学习 &amp; 技术 :: 计算机 on LRYP&#39;s Blog</title>
        <link>https://littlereuben.github.io/categories/cs/</link>
        <description>Recent content in 学习 &amp; 技术 :: 计算机 on LRYP&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>LRYP</copyright>
        <lastBuildDate>Sun, 14 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://littlereuben.github.io/categories/cs/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>读论文系列 #4——stretch 2 APSP 的最新进展</title>
        <link>https://littlereuben.github.io/study/paper4/</link>
        <pubDate>Sun, 14 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>https://littlereuben.github.io/study/paper4/</guid>
        <description>&lt;div style=&#34;background-color: #FFE1B9; color: #794500; padding-left: 1em; border-left: 4px solid #DE9B41; line-height: 25pt;&#34;&gt;这是一篇&lt;b&gt;摘抄笔记&lt;/b&gt;。&lt;/div&gt;
&lt;h3 id=&#34;引入&#34;&gt;引入
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://arxiv.org/abs/2307.09258&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;paper&lt;/a&gt;，&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/shiys22/p/17736505.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;APSP 近似的一些其他情形 sys 的笔记&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;问题&#34;&gt;问题
&lt;/h4&gt;&lt;p&gt;对于 APSP 问题，记 $\pi(u,v)$ 为最短路，$d(u,v)$ 为 $\pi(u,v)$ 的长度。如果有一个算法能得到近似 $\delta(u,v)$ 满足 $d(u,v)\le\delta(u,v)\le m\cdot d(u,v)+a$，那么就称为一个 $(m,a)$ 近似。$a=0$ 时称为 stretch $m$ 近似，$m=1$ 时称为 surplus $a$ 近似，下文中简写作 $m$ 近似与 $+a$ 近似。&lt;/p&gt;
&lt;p&gt;distance oracle 指的是以常数时间（？）回答一组 $\delta(u,v)$ 的算法，这样避免了输出的 $\Omega(n^2)$ 界，可以（在稀疏图中）做到平方以下。&lt;/p&gt;
&lt;p&gt;下文中“非确定性算法”指必然正确且以高概率在对应时间内运行结束的算法；期望时间算法可以并列运行 $\log$ 个，通过 Chernoff bound 变成非确定性。&lt;/p&gt;
&lt;h4 id=&#34;一些上下界&#34;&gt;一些上下界
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;大家都知道准确的带权 APSP 被猜想是 $\tilde\Omega(n^3)$ 的，而不带权的可以归约矩乘做。&lt;/li&gt;
&lt;li&gt;$2-\epsilon$ 近似不弱于 01 矩乘，有向图的任意近似都不弱于 01 矩乘。&lt;/li&gt;
&lt;li&gt;当 $m=\Theta(n)$ 时，oracle 有 $\tilde\Omega(m^{5/3})$ 的时空下界（基于一些 fine-grained complexity 的猜想）。&lt;/li&gt;
&lt;li&gt;已知无向无权图的 $(2,1)$ 近似可以 $\tilde\Omicron(n^2)$，所以现在不确定的是，无权/有权的 $2$ 近似能不能 $n^2$，以及 oracle 能不能 sub-$n^2$。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;无权&#34;&gt;无权
&lt;/h3&gt;&lt;h4 id=&#34;已知结果&#34;&gt;已知结果
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;[DHZ00] 存在非确定性与确定性的算法，能在线性时间内得到一张图中所有度 $\ge s$ 点的 hitting-set，大小 $\tilde\Omicron(n/s)$。&lt;/li&gt;
&lt;li&gt;[DHZ00] 无权无向图的 $+\log n$ 近似 APSP 可以在时间 $\tilde\Omicron(n^2)$ 内求解。&lt;/li&gt;
&lt;li&gt;[BK10] 非负整数权无向图的 $2$ 近似 APSP 可以在时间 $\tilde\Omicron(mn^{0.5}+n^2)$ 内用非确定性算法求解。&lt;/li&gt;
&lt;li&gt;[Zwi02] $\langle n,n^r,n\rangle$ 的 $(\min,+)$ 矩阵乘法的 $1+\epsilon$ 近似能在时间 $\tilde\Omicron(n^{\omega(r)}\epsilon^{-1}\log W)$ 内求解，其中 $\omega(r)$ 是 $\langle n,n^r,n\rangle$ 的普通矩阵乘法复杂度，原矩阵值域为 $[W]\cup\set{\infty}$。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;整体处理思路&#34;&gt;整体处理思路
&lt;/h4&gt;&lt;p&gt;我们希望找到一些关键点，只求关键点到全体的最短路，将必经关键点的最短路作为近似结果。&lt;/p&gt;
&lt;center&gt;&lt;img src=&#34;1.png&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/center&gt;
&lt;ol&gt;
&lt;li&gt;如果 $\pi(u,v)$ 经过大度点，可以通过 hitting-set 的套路做到 $+2$ 近似（优于 $2$ 近似）。
&lt;ol&gt;
&lt;li&gt;对于 hitting-set $S$ 内的点，做 MSSP。&lt;/li&gt;
&lt;li&gt;求形如 $\delta(u,v)=\min_{x\in S}\set{d(u,x)+d(x,v)}$ 的 $(\min,+)$ 矩乘。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;否则是稀疏图上的 APSP。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里 1.1 中的 MSSP 我们固定用 Dijkstra，那么剩余的就是需要指定矩乘和稀疏图 APSP 的算法。如果取度数阈值为 $n^{1-r}$ 的话，那么时间就是
$$
\tilde\Omicron(mn^r+T_{1.2}(n,n^r,n)+T_2(n,n^{2-r}))
$$
接下来认为 $m=\Omicron(n^2)$。&lt;/p&gt;
&lt;h4 id=&#34;倍增优化&#34;&gt;倍增优化
&lt;/h4&gt;&lt;p&gt;考虑进一步分治。如果 $\pi(u,v)$ 经过度数在 $[a,b)$ 内的点，那么用第 1 部分的方法，Dijkstra 是点数 $n/a$，边数 $nb$。因此如果我们取一列区间
$$
[n^{1-r},2n^{1-r}),[2n^{1-r},4n^{1-r}),\cdots
$$
分别交给第 1 部分做，时间就降为
$$
\tilde\Omicron(n^2+T_{1.2}(n,n^r,n))
$$&lt;/p&gt;
&lt;h4 id=&#34;近似归约&#34;&gt;近似归约
&lt;/h4&gt;&lt;p&gt;我们知道 $(\min,+)$ 矩乘是没法做的，所以只能近似。如果有 $(m,a)$ 近似的矩乘，那么第 1 部分整体就是 $(m,a+2m)$ 近似。由于只需考虑 $d\ge 2$ 的情况，$(m,a+2m)$ 近似就必然是 $(2m,a)$ 近似。&lt;/p&gt;
&lt;p&gt;于是根据已知 4，第 1 部分存在一个 $2+\epsilon$ 近似，时间关于 $\epsilon^{-1}$ 线性。 取 $\epsilon=1/\log n$。如果 $d(u,v)&amp;lt;\log n$，$2+\epsilon$ 近似相当于 $2$ 近似；否则调用已知 2。&lt;/p&gt;
&lt;h4 id=&#34;套用算法&#34;&gt;套用算法
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;全部用朴素做法，取 $r=0.5$ 得 $\tilde\Omicron(n^{2.5})$。&lt;/li&gt;
&lt;li&gt;第 2 部分用已知 3，就是 $n^2+n^{2+r}+n^{2.5-r}$，取 $r=0.25$ 得 $\tilde\Omicron(n^{2.25})$。&lt;/li&gt;
&lt;li&gt;上一条基础上，第 1 部分用已知 4，就是 $n^2+n^{\omega(r)}+n^{2.5-r}$，可以平衡到 $\tilde\Omicron(n^{2.032})$。&lt;/li&gt;
&lt;li&gt;还已知一个 parameterized 的算法是做 $+k$ 近似的，与矩乘结合得到一个 $(1+\epsilon,k)$ 近似算法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;有权&#34;&gt;有权
&lt;/h3&gt;&lt;h4 id=&#34;已知结果-1&#34;&gt;已知结果
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;[TZ01], [TZ05] 对于“密度” $p$，存在非确定性算法能在 $\tilde\Omicron(m/p)$ 的时间内得到一组大小为 $\tilde\Omicron(np)$ 的关键点集并计算出每个束内的基本信息，满足束和簇的大小均不超过 $\tilde\Omicron(1/p)$。&lt;/li&gt;
&lt;li&gt;[EN22] 非负整数权无向图的 $1+\epsilon$ 近似 MSSP 能在时间 $\tilde\Omicron(m^{1+\omicron(1)}+n^{\omega(r)}\epsilon^{-\Omicron(1)}\log W)$ 内求解，其中起点集合大小 $n^r$，边权值域 $[W]$。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;整体处理思路-1&#34;&gt;整体处理思路
&lt;/h4&gt;&lt;p&gt;同样取一些关键点，但是现在我们考虑这样的结构：对于点 $u$，找到与它距离最近的关键点 $p(u)$，将距离比 $d(u,p(u))$ 小的点，和 $p(u)$ 一起组成 $u$ 的束（branch）$B(u)$。束的逆称为簇 $C(v)=\set{u\mid v\in B(u)}$。&lt;/p&gt;
&lt;center&gt;&lt;img src=&#34;2.png&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;font color=&#39;gray&#39; size=2&gt;蓝色点表示最近关键点，称为“枢轴”&lt;/font&gt;&lt;/center&gt;
&lt;p&gt;通过束的定义以及三角不等式，可以放缩得到一些近似。首先有个 $3$ 近似：若 $v\notin B(u)$，则
$$
d(u,p(u))+d(p(u),v)\le d(u,p(u))+d(p(u),u)+d(u,v)\le 3d(u,v)
$$
若 $v\in B(u)$，已知 1 的做法里能算出 $u$ 到 $B(u)$ 各点的最短路，所以就不用管了。&lt;/p&gt;
&lt;p&gt;我们现在称 $\pi(u,v)\setminus(B(u)\cup B(v))$ 中的点为“束间点”。&lt;/p&gt;
&lt;center&gt;&lt;img src=&#34;3.png&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/center&gt;
&lt;p&gt;（情况 1）如果 $\pi(u,v)$ 有束间点 $x$，那么 $d(u,x),d(x,v)$ 中至少有一个 $\le d(u,v)/2$，不妨设为 $d(u,x)$，则
$$
d(u,p(u))+d(p(u),v)\le 2d(u,p(u))+d(u,v)\le 2d(u,x)+d(u,v)\le 2d(u,v)\tag{1}
$$
剩余的情况（情况 2）是关注的重点。&lt;/p&gt;
&lt;h4 id=&#34;暴力做法&#34;&gt;暴力做法
&lt;/h4&gt;&lt;p&gt;若 $\pi(u,v)$ 无束间点，那么 $\pi(u,v)$ 一定形如 $u\rightsquigarrow u^\prime\to v^\prime\rightsquigarrow v$，其中 $u^\prime\in B(u)$，$v^\prime\in B(v)$。这样的 $(u,u^\prime,v^\prime,v)$ 的数量是 $m|C|^2=\tilde\Omicron(m/p^2)$。总的时间：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;情况 1 从关键点出发跑 Dijkstra，$\tilde\Omicron(nmp)$。&lt;/li&gt;
&lt;li&gt;情况 2 暴力更新，$\tilde\Omicron(m/p^2)$。&lt;/li&gt;
&lt;li&gt;两类情况取 $\min$，$\Omicron(n^2)$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以做一个 oracle，省去 3，取 $p=n^{-1/3}$ 得 $\tilde\Omicron(mn^{2/3})$。&lt;/p&gt;
&lt;p&gt;注意到如果暴力做无束间边（$\tilde\Omicron(n/p^2)$），而恰有一条束间边的情况归到情况 1，可以得到一个 $\tilde\Omicron(nm^{2/3})$ 的 $(2,\max w)$ 近似。&lt;/p&gt;
&lt;h4 id=&#34;稠密情况&#34;&gt;稠密情况
&lt;/h4&gt;&lt;p&gt;对于情况 1 用已知 2 的 $1+\epsilon/2$ 近似，得到 $2+\epsilon$ 近似。&lt;/p&gt;
&lt;p&gt;对于情况 2，分两步做（各束边指的是，每个 $u$ 向 $B(u)$ 内点连边权为距离的边）：&lt;/p&gt;
&lt;center&gt;&lt;img src=&#34;4.png&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;font color=&#39;gray&#39; size=2&gt;② 对应第 1 次 Dijkstra，③ 对应第 2 次&lt;/font&gt;&lt;/center&gt;
&lt;ol&gt;
&lt;li&gt;对每个 $v^\prime$，保留其邻边与各束边，跑 Dijkstra，得到 $d^\prime(v^\prime,u)$。&lt;/li&gt;
&lt;li&gt;对每个 $u$，保留各束边，建边 $(u,v^\prime)$ 权 $d^\prime(v^\prime,u)$，跑 Dijkstra。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;时间均为 $\tilde\Omicron(n^2/p)$，这样算出来的是准确 SP。若 $p=n^{r-1}$，则总时间为
$$
\tilde\Omicron(n^{3-r}+n^{\omega(r)}\epsilon^{-\Omicron(1)}\log W)
$$
可以平衡到 $n^{2.213}$。&lt;/p&gt;
&lt;p&gt;注意到建束内边对非稠密图过于激进了，接下来的做法进行了进一步的平衡。&lt;/p&gt;
&lt;h4 id=&#34;倍增优化-1&#34;&gt;倍增优化
&lt;/h4&gt;&lt;p&gt;相比情况 2，情况 1 更容易优化。注意到有权图的“束”结构与无权图的简单的 hitting-set 结构有以下共同点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过一个中介点 $x$，三角不等式放缩多出两倍的 $d(x,?)$（在无权图中就是 $+2$），得到 $2$（或 $2+\epsilon$） 近似。&lt;/li&gt;
&lt;li&gt;关键点出发全图跑 MSSP，这使我们无法不受限制地增加关键点数，否则这部分会成为瓶颈。&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;不借助中介点&lt;/th&gt;
&lt;th&gt;借助中介点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;无权图&lt;/td&gt;
&lt;td&gt;去除大度点&lt;/td&gt;
&lt;td&gt;必经大度点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无权图做法&lt;/td&gt;
&lt;td&gt;跑稀疏图 APSP&lt;/td&gt;
&lt;td&gt;找 hitting-set，MSSP + 矩乘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有权图&lt;/td&gt;
&lt;td&gt;$\pi(u,v)$ 无束间点&lt;/td&gt;
&lt;td&gt;$\pi(u,v)$ 有束间点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有权图做法&lt;/td&gt;
&lt;td&gt;暴力松弛&lt;/td&gt;
&lt;td&gt;MSSP&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;center&gt;&lt;img src=&#34;6.png&#34; style=&#34;zoom:30%;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;font color=&#39;gray&#39; size=2&gt;对数尺度；每个格子的右边界为该格算法的关键点密度&lt;/font&gt;&lt;/center&gt;
&lt;p&gt;在无权图中，通过考虑子问题：经过度数在 $[a,b)$ 间点的最短路，对其分治，得到倍增做法，减少了边数，使得 Dijkstra 总时间由 $mn^r$ 降至 $n^2$。在有权图中，模仿这一思路：考虑关键点集 $S_{i+1}\subset S_i$，现在需要对于所有 $(u,v)$ 满足 $\pi(u,v)$ 在 $S_{i+1}$ 下无束间点，而在 $S_i$ 下有束间点的情况，去求 $d(u,v)$ 的近似。同样，我们的目标是减少关键点出发 MSSP 的边数，同时保证近似的论证不失效。&lt;/p&gt;
&lt;p&gt;仍然假定 $d(p_i(u),u)\le d(u,v)/2$。回顾不等式 $(1)$：
$$
d(u,p(u))+\boxed{d(p(u),v)}\le d(u,p(u))+\boxed{d(p(u),u)+d(u,v)}
$$
实际不需要准确求出 $d(p_i(u),v)$，而只求一个近似的 $\delta(p_i(u),v)\in[d(p_i(u),v),d(p_i(u),u)+d(u,v)]$ 即可。进一步，如果 $\pi(u,v)$ 形如 $u\rightsquigarrow u^\prime\to x\rightsquigarrow v$，其中 $u^\prime\in B_{i+1}(u)$，$x\notin B_{i+1}(u)$，那么可以拆成
$$
d(p_i(u),u)+d(u,u^\prime)+w(u^\prime,x)+d(x,v)
$$&lt;/p&gt;
&lt;center&gt;&lt;img src=&#34;5.png&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/center&gt;
&lt;p&gt;建立这样的图：$p_i(u)$ 向所有与 $B_{i+1}(u)$ 相邻的点（及上述 $x$ 这样的点）连边，边权
$$
\delta^\prime(p_i(u),x)=\min_{u^\prime}\set{d(p_i(u),u)+d(u,u^\prime)+w(u^\prime,x)}
$$
另外对于所有的点 $v$，将与 $v$ 相邻的权 $\le d(v,p_{i+1}(v))$ 的边加入。跑 Dijkstra。设 $\pi(x,v)=x\to\cdots\to v_1\to v$。由于 $x\in B_{i+1}(v)$，故 $(v_1,v)$ 是保留的；由于 $d(v_1,p_{i+1}(v_1))+w(v_1,v)\ge d(v,p_i(v))$，故 $x\in B_{i+1}(v_1)$，所以 $(v_2,v_1)$ 也保留，以此类推。&lt;/p&gt;
&lt;p&gt;求 $\delta^\prime$ 所需的时间是
$$
\sum_{u^\prime}\mathrm{deg}_{u^\prime}|C_{i+1}(u)|=\tilde\Omicron(m|C_{i+1}|)
$$
我们相当于把菊花形的各束边改成了第二类边，它们的数量这么考虑：如果 $S_{i+1}$ 是以 $q$ 的概率选点的话，那么对于不在 $S_{i+1}$ 中的点，将其邻边按边权从小到大扫描，每次有 $q$ 的概率把剩余的扔掉。因此期望边数为 $\sum (1-q)^i\le 1/q$，用 Chernoff bound 一类的东西放缩下就是高概率 $\tilde\Omicron(n/q)$。从这个意义上来看，束结构也是限制度数的，基本打通了无权和有权的思想。&lt;/p&gt;
&lt;p&gt;因此总的复杂度是
$$
\tilde\Omicron\left(\frac mq+|S_i|\frac nq+n^2\right)=\tilde\Omicron\left(\frac{mn}{|S_{i+1}|}+\frac{n^2|S_i|}{|S_{i+1}|}\right)
$$
考虑关键点集包含链 $V=S_0\supset S_1\supset\cdots\supset S_k$。其中 $S_i$ 中的每个点以 $1/2$ 概率出现在 $S_{i+1}$ 中。如果 $\pi(u,v)$ 在 $S_k$ 的下仍有束间点，那么就只能用原来情况 1 的做法，从 $S_k$ 出发跑 MSSP；否则一定存在某个 $S_{i}-S_{i+1}$ 交界，就用上面的方法。设 $k=(1-r)\log_2n$，则 $|S_k|=\tilde\Theta(n^r)$，时间为 $\tilde\Omicron(mn^{1-r}+n^2+T_1(n,m,n^r))$，$T_1$ 是 MSSP 的复杂度。&lt;/p&gt;
&lt;p&gt;实际实现时，第一类边权的 $\min$ 只需要拿 $B_k(u)$ 内所有点的邻边去松弛就行，那么为了保证 $|C_k(u)|$ 的大小，需要强制往 $S_k$ 里加已知 1 里的构造，不过这个不影响复杂度。总的做法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;求出 $\set{S_i}$，建出束结构。&lt;/li&gt;
&lt;li&gt;对于每个 $u$，每个 $i$，每个 $B_k(u)$ 内点的邻边，更新 $\delta^\prime(p_i(u),x)$。&lt;/li&gt;
&lt;li&gt;对于每个 $p_i(u)$ 建图跑 Dijkstra。&lt;/li&gt;
&lt;li&gt;对于 $S_k$ 在原图上跑 MSSP。&lt;/li&gt;
&lt;li&gt;对每个 $(u,v)$ 求答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;套用算法-1&#34;&gt;套用算法
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;MSSP 直接用 Dijkstra，时间 $mn^r$，取 $r=0.5$ 得 $\tilde\Omicron(mn^{0.5}+n^2)$，这就是 [BK10]。&lt;/li&gt;
&lt;li&gt;MSSP 用已知 2，这样是 $2+\epsilon$ 近似，是 $mn^{1-r}+n^2+n^{\omega(r)}\epsilon^{-\Omicron(1)}\log W$，对于稠密图的平衡结果，和稠密情况那个一样。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>读论文系列 #5——多带图灵机中的空间换时间</title>
        <link>https://littlereuben.github.io/study/paper5/</link>
        <pubDate>Sun, 14 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>https://littlereuben.github.io/study/paper5/</guid>
        <description>&lt;div style=&#34;background-color: #FFE1B9; color: #794500; padding-left: 1em; border-left: 4px solid #DE9B41; line-height: 25pt;&#34;&gt;这是一篇&lt;b&gt;摘抄笔记&lt;/b&gt;。&lt;/div&gt;
&lt;h3 id=&#34;引入&#34;&gt;引入
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://arxiv.org/abs/2502.17779&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;paper&lt;/a&gt;，&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v=1qwDO5ulUFs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;部分讲解视频&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$\gdef\b#1{\boldsymbol{#1}}$下文中 $d$、$m$ 代表常数。&lt;/p&gt;
&lt;p&gt;考虑运行时间为 $t(n)$ 的 $d$ 带图灵机，我们考虑的问题是可以用多少空间的多带图灵机模拟它。这一问题的重要性在于：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 $\forall\varepsilon&amp;gt;0$，$\mathsf{TIME}[t(n)]\subseteq\mathsf{SPACE}[t(n)^\varepsilon]$，则 $\mathsf{P}\ne\mathsf{PSPACE}$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最新的这篇文章做到了 $\mathsf{TIME}[t(n)]\subseteq\mathsf{SPACE}[\sqrt{t(n)\log t(n)}]$，大致的思路是缝合了空间模拟时间的基本思想，以及一个 $\mathsf{L}\text{ vs }\mathsf{P}$ 方面的最新进展。&lt;/p&gt;
&lt;h3 id=&#34;单带情况&#34;&gt;单带情况
&lt;/h3&gt;&lt;p&gt;在限制空间的情况下，其实显而易见的思路只有一条，就是做一个 time-space tradeoff，以重复计算的代价换取不存储完整纸带的能力。&lt;/p&gt;
&lt;p&gt;考虑每时每刻，只在 $M^\prime$ 中存储 $M$ 的纸带上的一小段，在上面进行模拟。如果读写头离开了当前段进入其他部分，就 recover 另一小段的当前情况，继续模拟。&lt;/p&gt;
&lt;center&gt;&lt;img src=&#34;1.png&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/center&gt;
&lt;p&gt;具体到单带图灵机上，考虑小段长为 $b(n)$，那么在跨段时，需要重新模拟新进入段的所有历史操作，但模拟过程不能递归依赖其他段的信息。为此，只需存储历史上每次跨段时的信息即可，这所需记录条目数是平均 $\frac{t(n)}{b(n)}$ 的，每个条目需要记录段号与状态，是 $\log\frac{t(n)}{b(n)}+\Omicron(1)$ 的，如果改成记录 $\pm 1$ 就是 $\Omicron(1)$（这个和四毛子优化 RMQ 是一样的）。为了避免 $M$ 在段边界反复横跳导致卡到最劣，可以枚举分段起始点的偏移，根据鸽巢原理一定存在一个偏移量满足跨段次数 $\le\frac{t(n)}{b(n)}$。&lt;/p&gt;
&lt;p&gt;显然这里取 $b(n)=\sqrt{t(n)}$，平衡到 $\Omicron(\sqrt{t(n)})$ 的空间复杂度。&lt;/p&gt;
&lt;p&gt;但是这个思路在多带完全不行：各带读写头的跨段没法同步，就算同步了，考虑 $(x,y)$ 表示当前第一条纸带的读写头在第 $x$ 段，第二条在 $y$，那么比如当前在 $(2,3)$ 恢复所需要的历史操作可能是 $(2,1)$、$(2,2)$、$(1,3)$、$(3,3)$ 这些情形，它就爆炸了。简而言之，依赖关系从单带的链，变成多带的 DAG。&lt;/p&gt;
&lt;h3 id=&#34;多带历史思路&#34;&gt;多带历史思路
&lt;/h3&gt;&lt;p&gt;首先展开说一下多带跨段的同步以及标准化。我们希望将位置和时间同时分块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于多带图灵机，存在等效的多带“分块图灵机” with 块大小 $b(n)$，时间 $\Theta(t(n))$（实际上要求 $\log t(n)\le b(n)\le t(n)$，以及 $t(n)$、$b(n)$ time-constructible，不过这些不太重要）。分块图灵机指的是，各纸带划分为 $b(n)$ 长的小段，读写头跨段只能出现在 $b(n)$ 倍数的时刻。&lt;/li&gt;
&lt;/ul&gt;
&lt;details style=&#34;background-color: rgba(127, 127, 127, 0.1); padding: 5px;&#34;&gt;
    &lt;summary&gt;构造思路&lt;/summary&gt;
    加的一条带作为“时钟”，读写头持续在 $b(n)$ 的范围内来回移动，如果其他头需要跨段但“时钟”未到“整点”（下文我称时间的分段为时间块），就等着到整点再动。但这仍然会遇到段边界反复横跳的问题。处理方法是，扩展字母表/带数使得每带的每段都记录相邻两段的信息，这样就无需等待，只需在当前时间块完成后，额外花若干（常数个）时间块把更新的信息复制到相邻段即可。
    &lt;center&gt;&lt;img src=&#34;prf.png&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/center&gt;
&lt;/details&gt;
&lt;p&gt;设纸带数为 $d$。&lt;/p&gt;
&lt;p&gt;刻画多带的历史依赖关系的结构被称为 computation graph：每个时间块 $i$ 对应一个节点，其存储 $\text{content}_i$，内容为该时间块结尾时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图灵机的状态 $q_i$；&lt;/li&gt;
&lt;li&gt;各读写头位置 $h_{i,1}\sim h_{i,d}$；&lt;/li&gt;
&lt;li&gt;各读写头所在纸带段的最终内容 $c_{i,1}\sim c_{i,d}$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;空间为 $\Omicron(b(n)+\log t(n))$。&lt;/p&gt;
&lt;p&gt;为了得到 $\text{content}_i$，我们需要 $\text{content}_{i-1}$，以及另外某些 $\text{content}_{k_1,\cdots,k_d}$。如果对于某纸带 $j$，
$$
\left\lfloor\frac{h_{i,j}}{b(n)}\right\rfloor=\left\lfloor\frac{h_{k,j}}{b(n)}\right\rfloor\land\forall k^\prime\in(k,i),\left\lfloor\frac{h_{i,j}}{b(n)}\right\rfloor\ne\left\lfloor\frac{h_{k^\prime,j}}{b(n)}\right\rfloor
$$
也就是说，$\text{content}_k$ 中有时间块 $i$ 所需的纸带 $j$ 的最新信息，那么连边 $k\to i$。因此，每个点入度 $\le d+1$。&lt;/p&gt;
&lt;p&gt;两个注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发现不强制标准化分块也是可以的，就是要每带记录两个块，入度 $\le 2d+1$。&lt;/li&gt;
&lt;li&gt;处理输入有两种思路，一种是加个只存输入的 $\text{content}_0$，一种是在每个点额外存历史首次访问到的段的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假定已知 computation graph 的结构，待求 $\text{content}_{t(n)/b(n)}$。当前的模型形如：给定一张 DAG，指定源和汇。每次如果一个点是源，或它的所有入点上都有石子，可以在这个点上也放石子；也可以任意拿掉石子。问使得汇上有石子，最少需要备多少石子。这被称为 (standard/black) pebble game。&lt;/p&gt;
&lt;center&gt;&lt;img src=&#34;eg.png&#34; style=&#34;zoom:70%;&#34; /&gt;&lt;/center&gt;
&lt;p&gt;例如这张图应该至少需要四个石子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+0, +1, +2, -1, +3, -0, +4, -3, +0, +1, +2, -0, -1, +5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;记 $P_k(n)$ 为最大入度为 $k$ 的 $n$ 点图中，最多的所需石子数（可以任意指定一个汇）。[HPV75] 中证明了对于常数 $k$，$P_k(n)=\Omicron(n/\log n)$。&lt;/p&gt;
&lt;details style=&#34;background-color: rgba(127, 127, 127, 0.1); padding: 5px;&#34;&gt;
    &lt;summary&gt;证明&lt;/summary&gt;
    记 $R_k(n)$ 为最大入度为 $k$，所需 $n$ 个石子的图中，最少的边数。只需证明 $R_k(n)=\Omega(n\log n)$ 即可，考虑用割 + 归纳的证法。取这样一张图 $G=(V,E)$ 中，用 $\le n/2$ 个石子就能达到的所有点 $V_1$，剩余为 $V_2$。如果将 $V_2$ 的导出子图拿出，入度为 $0$ 的点可以随意放石子，那么这部分需要至少 $n/2-k$ 个石子。这是因为，在整张图中，如果要将 $V_2$ 中的一个入度为 $0$ 的点上放上石子，就需要在 $V_1$ 中至多 $k$ 个点上放石子，就需要备至多 $n/2+k-1$ 个石子。如果 $V_2$ 部分只需 ${{}&lt;{}}n/2-k$，两者相加就与需要 $n$ 个石子矛盾了（似乎常数项可以更紧一点？）。另外 $V_1$ 中一定有需 $\ge n/2-k$ 个石子的点，因此
    $$
    R_k(n)\ge 2R_k\left(\frac n2-k\right)+\text{cut}(V_1,V_2)
    $$
    只需 $\text{cut}(V\_1,V\_2)$ 不太小（$=\Theta(n)$）就行。如果 $\text{cut}(V_1,V_2){{}&lt;{}}n/4$，那么可以在 $V_1$ 中与 $V_2$ 有边的节点上全留石子，因此 $V_2$ 部分单独拿出来做，需要至少 $3n/4$ 的石子。于是
    $$
    R_k(n)\ge\min\Set{2R_k\left(\frac n2-k\right)+\frac n4,R_k\left(\frac n2-k\right)+R_k\left(\frac{3n}4\right)}
    $$
    归纳可证 $R_k(n)\ge cn\log n$。
&lt;/details&gt;
&lt;p&gt;另外存在卡到 $\Theta(n/\log n)$ 的构造，详见 &lt;a class=&#34;link&#34; href=&#34;https://dl.acm.org/doi/10.1145/800113.803643&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Space bounds for a game on graphs&lt;/a&gt;，似乎是形如 FFT 电路。&lt;/p&gt;
&lt;p&gt;这就意味着无论怎么取 $b(n)$，空间被限制在 $\Omega(n/\log n)$。为完成整个证明，还需解决两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何求出 computation graph？直接枚举每个头每个时间块的位置，是 $\Omicron\big(\frac{t(n)}{b(n)}\log\frac{t(n)}{b(n)}\big)$ bits，当然也可以枚举差分。如果模拟过程中发现读写头走的方向与枚举的不符，就返回 &lt;code&gt;FAIL&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如何求出一组达到 $\Omicron\big(\frac{t(n)}{b(n)}/\log\frac{t(n)}{b(n)}\big)$ 的放石子顺序？直接枚举的话递归栈大小会爆，但无论如何每次猜一步，总还是 $\mathsf{NSPACE}\big[\frac{t(n)}{b(n)}\big]$ 的。$b(n)$ 稍微取大点，用下 Savitch 即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;整体的思想是，局部纸带段—历史跨段记录的平衡。&lt;/li&gt;
&lt;li&gt;computation graph 是对整个结构的很本质的刻画，但是直接在这上面跑组合算法是没前途的。&lt;/li&gt;
&lt;li&gt;两个细节处理的 trick：分块化，以及猜 computation graph。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容易感受到，之前研究者们都偏向于相信，$n/\log n$ 没法再优化了。&lt;/p&gt;
&lt;h3 id=&#34;tree-evaluation-problem&#34;&gt;tree evaluation problem
&lt;/h3&gt;&lt;p&gt;如果把 computation graph 展开，我们可以得到一棵高度为 $\Omicron\big(\frac{t(n)}{b(n)}\big)$，$\Omicron(d)$ 叉的树。尽管看似变得冗余了，但是树上的这一问题有代数做法，这就给了突破口。tree evaluation problem (TEP) 指的是，给定一颗高度为 $h$ 的满 $d$ 叉树，每个节点 $u$ 上有 $b$ 位 $01$ 串 $\text{content}_u$。初始给定叶子的串，以及每个节点由其各儿子串决定其本身串的函数，即 $(\set{0,1}^b)^d\to\set{0,1}^b$ 的函数，求根的串。&lt;/p&gt;
&lt;p&gt;输入的长度是 $\Theta(b2^{bd}d^h)=2^{\Theta(b+h)}$ 的，而这一问题是否 $\in\mathsf{NL}$ 还是 open 的（大家偏向于否）。但是 [CM24] 提出了一个空间 $\Omicron(db+h\log(db))$ 的做法，对于大小为 $n$ 的输入而言，这是 $\Omicron(\log n\log\log n)$ 的（据说还能多除个 $\log\log\log n$？）。&lt;/p&gt;
&lt;p&gt;一般的 dfs 做法需要 $\Omicron(dhb)$ 的空间：&lt;/p&gt;
&lt;center&gt;&lt;img src=&#34;2.png&#34; style=&#34;zoom:30%;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;font color=&#39;gray&#39; size=2&gt;紫色为当前节点，黄色为需存储节点&lt;/font&gt;&lt;/center&gt;
&lt;p&gt;而 [CM24] 的想法是，把上面各层的信息给叠起来，但利用单位根的性质（说白了就是单位根反演）把叠起来的垃圾抵消了。&lt;/p&gt;
&lt;p&gt;具体而言，每个节点的函数可以看作 $b$ 个 $\mathbb{F}_2^{bd}\to\mathbb{F}_2$ 的函数，具体来说，如果原函数是 $f(\b x_1,\cdots,\b x_d)$（每个 $\b x_i$ 是一个儿子的 $b$ 位），那么对应的函数是：
$$
\tilde{f}(\b x_1,\cdots,\b x_d)_i=\sum_{\b a_1,\cdots,\b a_d\in\mathbb{F}_2^b}f(\b a_1,\cdots,\b a_d)_i\prod_{j=1}^d\prod_{k=1}^b(\b x_{j,k}-\b a_{j,k}+1)
$$
这个东西的想法和拉格朗日插值/CRT 是一样的，在特征为 $2$ 的域中，$x-y+1$ 等价于 $[x=y]$。我们将定义域和值域扩到 $\mathbb{F}_{2^q}$，公式不变。&lt;/p&gt;
&lt;p&gt;现在只需存储 $(d+1)b$ 个 $\mathbb{F}_{2^q}$ 内的元素便可以计算。记这些寄存器为 $\b x_1,\cdots,\b x_{d+1}\in\mathbb{F}_{2^q}^b$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$\text{calc}(u,\b y):$&lt;br&gt;
——将 $\text{content}_u$ 加给 $\b y$，其他寄存器的内容不变。方便起见记其他寄存器为 $\b x_1\sim\b x_d$。&lt;/p&gt;
&lt;div style=&#34;padding-left: 1em;&#34;&gt;&lt;blockquote&gt;	
$\text{for }i=0\to m-1:$
&lt;div style=&#34;padding-left: 1em;&#34;&gt;&lt;blockquote&gt;
$(1)$ 对于每个儿子调用 $\text{calc}$，使 $\b x_j$ 变为 $\omega_m^i\b x_j+\text{content}\_{\text{son}_{u,j}}$
&lt;p&gt;$\b y\xleftarrow{+}\tilde f(\b x_1,\cdots,\b x_d)$&lt;/p&gt;
&lt;p&gt;原样撤回 $(1)$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;
&lt;/blockquote&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里 $\omega_m$ 是 $m$ 次单位根，有性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 $&amp;lt;m$ 次多项式 $P$，$\displaystyle\sum_{i=0}^{m-1}P(\omega_m^iu_1+v_1,\cdots,\omega_m^iu_k+v_k)=P(v_1,\cdots,v_k)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;证明很简单：考虑 $P(x_1,\cdots,x_k)=x_1^{p_1}\cdots x_k^{p_k}$，那么
$$
\displaystyle\sum_{i=0}^{m-1}P(\omega_m^iu_1+v_1,\cdots,\omega_m^iu_k+v_k)=\sum_{q_1,\cdots,q_k}\left(\sum_{i=0}^{m-1}\omega^{i\cdot\sum_{j=1}^kq_j}\right)\prod_{j=1}^k\binom{p_j}{q_j}u_j^{q_j}v_j^{p_j-q_j}=v_1^{p_1}\cdots v_k^{p_k}
$$
只有 $m\mid\sum q_j$ 时打括号的和式才非零，而且特征为 $2$，$m$ 是奇数，所以后一个就直接取等过去了。&lt;/p&gt;
&lt;p&gt;空间是（再次注意，这里不计输入）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$u$，全局记着就是 $h\log d$&lt;/li&gt;
&lt;li&gt;所有寄存器，$(d+1)bq$&lt;/li&gt;
&lt;li&gt;局部循环变量，$h\log(d^2b)$&lt;/li&gt;
&lt;li&gt;求 $\tilde f$ 时所需的临时空间，$db+q$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在只要求 $db&amp;lt;m&amp;lt;2^q$，因此总共 $\Omicron((h+db)\log(db))$。一个显而易见的优化空间是，可以把若干 $01$ 位压到 $\tilde f$ 的一个参数里：考虑 $\set{0,1}^p\to\mathbb{F}_{2^q}$ 的单射，设值域为 $S$。这时对于 $x,y\in S$，
$$
[x=y]=\frac{\prod_{z\in S\setminus\set{y}}(x-z)}{\prod_{z\in S\setminus\set{y}}(y-z)}
$$
因此 $\deg\tilde f=db2^p/p$，寄存器的空间是 $(d+1)bq/p$，只需要 $db/p&amp;lt;2^{q-p}$ 即可，那索性取 $p=\log(db)=q/2$。这样空间就优化到 $\Omicron(h\log(db)+db)$。&lt;/p&gt;
&lt;p&gt;假定 computation graph 已知，直接套用，代入 $h=t(n)/b(n)$，$b=b(n)$，就直接平衡到了惊人的 $\Omicron(\sqrt{t(n)\log t(n)})$。&lt;/p&gt;
&lt;h3 id=&#34;细节处理&#34;&gt;细节处理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;仍然将原图灵机先分块化。&lt;/li&gt;
&lt;li&gt;为了处理输入 $\text{content}_0$ 在 $t(n)=\omicron(n^2)$ 时过长，需要将它再分块。所以索性将所有节点存储的信息都缩减成单带的一段。现在节点有两种：$(h,i)$ 表示第 $h$ 带的第 $i$ 时间块，$(h,0,i)$ 表示第 $h$ 带初始时第 $i$ 段。连边还是类似的。&lt;/li&gt;
&lt;li&gt;枚举 computation graph。只需枚举每个时间块结束时每个读写头怎么移动，总共是 $(\log_23)d\frac{t(n)}{b(n)}$ bits。没必要把图显式建出，求儿子可以枚举后暴力区间求和检验。&lt;/li&gt;
&lt;li&gt;在调用上述 TEP 算法过程中，求 $\tilde f$ 时需要对于 $f$ 的每组输入模拟。如果输入中有 &lt;code&gt;FAIL&lt;/code&gt; 直接返回 &lt;code&gt;FAIL&lt;/code&gt;，否则可以原地模拟，再检查最后一步的走向是否与枚举的相符，不符也返回 &lt;code&gt;FAIL&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;TEP 算法中的 $u$ 是不是可以直接用节点号描述啊……反正瓶颈不在这。另外 computation graph 对应的树不是满的，补补齐就行。&lt;/li&gt;
&lt;li&gt;另外有个小细节，我们不要求 $t(n)$ 是 time/space-constructible 的，因为我们可以在整个模拟外套上枚举 $t(n)$ 的循环。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;多维推广&#34;&gt;多维推广
&lt;/h3&gt;&lt;p&gt;设维数为 $m$。将每个纸带划分为边长为 $b(n)$ 的超立方体。论文里说多维不存在分块图灵机，我不太理解，应该也可以用类似上面叠相邻块内容的方法啊？&lt;/p&gt;
&lt;p&gt;不分块也没什么问题。同一时间块内，每一维可能跨两段，因此访问到的总段数不超过 $2^m$，从而 computation graph 中每个节点的入度不超过 $(2^m+1)d$，每个节点的 content 仍包括：状态、时间块结束时读写头位置（$d\log t(n)$）、访问到的段的相对位置及内容（$2^db(n)^d$ 或 $3^db(n)^d$），因此位数是 $\Theta(b(n)^d+d\log t(n))$ 的，方便起见认为 $\log t(n)=\omicron(b(n))$。代入 TEP 的复杂度：
$$
\Omicron\left(\frac{t(n)}{b(n)}\log b(n)+b(n)^d\right)
$$
取 $b(n)=\sqrt[d+1]{t(n)\log t(n)}$ 得 $\Omicron((t(n)\log t(n))^{1-\frac{1}{d+1}})$。&lt;/p&gt;
&lt;h3 id=&#34;推论&#34;&gt;推论
&lt;/h3&gt;&lt;p&gt;对于 space-constructible 的 $t(n)$，
$$
\mathsf{TIME}[t(n)]\subseteq\mathsf{SPACE}[\sqrt{t(n)\log t(n)}]\subsetneq\mathsf{SPACE}[t(n)^{\frac12+\varepsilon}]
$$
特别地，$\mathsf{SPACE}[n]$ 中有语言 $\notin\mathsf{TIME}[n^{2-\varepsilon}]$ 及 $\notin\mathsf{TIME}[n^2/\log^{&amp;gt;1}n]$。可以考虑一个“$\mathsf{SPACE}[n]$-complete”的例子：
$$
\set{\langle M,x,1^k\rangle\mid \lvert M\rvert\le k\text{ 且 }M\text{ 在 }k\text{ 空间内停机}}
$$
另外，如果 $\mathsf{TIME}[t(n)]\subseteq\mathsf{SPACE}[t(n)^{\frac12-\varepsilon}]$，那么交替图灵机和随机存取图灵机都可以在时间 $t(n)^{1-2\varepsilon}$ 内模拟 $t(n)$ 的图灵机。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>OIer 速通编入门</title>
        <link>https://littlereuben.github.io/study/course-cppstudio/</link>
        <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
        
        <guid>https://littlereuben.github.io/study/course-cppstudio/</guid>
        <description>&lt;img src="https://littlereuben.github.io/study/course-cppstudio/cover.png" alt="Featured image of post OIer 速通编入门" /&gt;&lt;div style=&#34;background-color: #FFF9B9; color: #796E00; padding-left: 1em; border-left: 4px solid #DED041; line-height: 25pt;&#34;&gt;这是一篇&lt;b&gt;学习笔记&lt;/b&gt;。&lt;/div&gt;
&lt;h3 id=&#34;c-动态内存&#34;&gt;C 动态内存
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;malloc&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;字节数&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 返回 void* 类型，可以隐式与别的指针类型转换
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;calloc&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;数量&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;单个元素字节数&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 全置 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;realloc&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;指针&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;新的字节数&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 指针可以是先前申请的或 NULL，如果是申请的，相当于 free，malloc 并复制。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;free&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;指针&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 释放
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;糖：&lt;code&gt;int * p = calloc(10, sizeof * p);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对了，关于 C++ 的 &lt;code&gt;new&lt;/code&gt; 有两点提一下，一个时 &lt;code&gt;new int [1]&lt;/code&gt; 必须用 &lt;code&gt;delete []&lt;/code&gt; 因为 &lt;code&gt;new&lt;/code&gt; 数组时会额外申请空间记录数组大小。另一个是 &lt;a class=&#34;link&#34; href=&#34;https://en.m.wikipedia.org/wiki/Placement_syntax&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;placement new&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;多文件编译&#34;&gt;多文件编译
&lt;/h3&gt;&lt;h4 id=&#34;odr&#34;&gt;ODR
&lt;/h4&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;In any translation unit, a template, type, function, or object can have no more than one definition. Some of these can have any number of declarations. A definition provides an instance.&lt;/li&gt;
&lt;li&gt;In the entire program, an object or non-inline function cannot have more than one definition; if an object or function is used, it must have exactly one definition. You can declare an object or function that is never used, in which case you don&amp;rsquo;t have to provide a definition. In no event can there be more than one definition.&lt;/li&gt;
&lt;li&gt;Some things, like types, templates, and extern inline functions, can be defined in more than one translation unit. For a given entity, each definition must have the same sequence of tokens. Non-extern objects and functions in different translation units are different entities, even if their names and types are the same.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;头文件-ifndef&#34;&gt;头文件 ifndef
&lt;/h4&gt;&lt;p&gt;多文件编译的原理为：将 &lt;code&gt;.h&lt;/code&gt; 中的内容加到每个 &lt;code&gt;.cpp&lt;/code&gt; 中（preprocess），然后编译这些 &lt;code&gt;.cpp&lt;/code&gt;，然后把他们链接起来。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.h&lt;/code&gt; 里的 &lt;code&gt;#ifndef&lt;/code&gt; 那些东西是为了避免同一个 &lt;code&gt;.cpp&lt;/code&gt; &lt;code&gt;include&lt;/code&gt; 多次同一个 &lt;code&gt;.h&lt;/code&gt;。例如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// a.cpp
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;h1.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;h2.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// h1.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;h.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// h2.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;h.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// h.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PI&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;3.14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;常量、类定义等内容不能在一个翻译单元中定义多次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，这个技巧不能避免多个文件之间的重复定义，例如在 &lt;code&gt;.h&lt;/code&gt; 里加了 &lt;code&gt;int a;&lt;/code&gt; 之类的照样会造成 redefinition。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;链接性&#34;&gt;链接性
&lt;/h4&gt;&lt;p&gt;链接性分为外部、内部、无。外部链接性意味着作用域可以在多个 &lt;code&gt;.cpp&lt;/code&gt;，前提是在定义所在的文件以外的文件中，要写 &lt;code&gt;extern&lt;/code&gt;（并且不初始化）。内部链接性意味着作用域只在当前文件内，无链接性就是在代码块内。&lt;/p&gt;
&lt;p&gt;全局变量、函数都是默认外部的，这就意味着它们不能在多个文件里或头文件里定义（但是函数可以多次声明，甚至在同一个文件里连续写两次 &lt;code&gt;int f(int) ;&lt;/code&gt; 都没问题）。如果要变成内部就在开头加 &lt;code&gt;static&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;头文件里可以定义什么&#34;&gt;头文件里可以定义什么
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;#define&lt;/code&gt; 肯定没什么问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt; 比较特殊，它是内部链接的，所以可以写在头文件里。如果要强制它变成外部的，就加 &lt;code&gt;extern&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt; 可以，但是成员函数不能在头文件里放在外面。类不能重复定义，但是可以在链接是出现重复，但是两个重复的不能不同，否则会出一些奇怪的情况。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// a.cpp
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;h.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// b.cpp
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;h.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// h.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样不会 CE，但是会出现一些诡异的问题，比如一个文件里得按另一个的名字来。&lt;/p&gt;
&lt;p&gt;类定义不能在外部链接，也就是说不能在另一个文件里写 &lt;code&gt;extern node x;&lt;/code&gt; 来定义一个 &lt;code&gt;node&lt;/code&gt;（在另一个文件里定义的类）的实例。&lt;/p&gt;
&lt;h3 id=&#34;cmake&#34;&gt;CMake
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;cmake 目录&lt;/code&gt; 指令会对目录中的文件（含 &lt;code&gt;CMakeLists.txt&lt;/code&gt;、源文件）生成 build system。这一步还没有编译，可以理解为生成了以 &lt;code&gt;Makefile&lt;/code&gt; 为代表的一系列文件。&lt;/p&gt;
&lt;p&gt;如果要进一步指定目录，&lt;code&gt;-B&lt;/code&gt; 可指定输出目录，&lt;code&gt;-S&lt;/code&gt; 可指定输入目录。如果没有这个目录，直接 &lt;code&gt;cmake 目录&lt;/code&gt; 会报错，但 &lt;code&gt;cmake -B 目录&lt;/code&gt; 则会自动创建一个。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;cmake&lt;/code&gt; 报错&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Running
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &amp;#39;nmake&amp;#39; &amp;#39;-?&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  failed with:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   系统找不到指定的文件。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就在 &lt;code&gt;cmake&lt;/code&gt; 后面加 &lt;code&gt;-G &amp;quot;MinGW Makefiles&amp;quot;&lt;/code&gt;。或者直接改环境变量：&lt;code&gt;setx CMAKE_GENERATOR &amp;quot;MinGW Makefiles&amp;quot; /m&lt;/code&gt;（需要管理员模式运行 Powershell，或者直接图形界面改也行）。&lt;/p&gt;
&lt;p&gt;注意一旦 &lt;code&gt;cmake&lt;/code&gt; 失败一次，就需要删掉所有相关文件再重新 &lt;code&gt;cmake&lt;/code&gt;，不然会傻傻地仍然报错，或提示已经 build 过。&lt;/p&gt;
&lt;p&gt;然后正式编译，使用 &lt;code&gt;make [-C 目录]&lt;/code&gt;（不写 &lt;code&gt;-C&lt;/code&gt; 只能 &lt;code&gt;make&lt;/code&gt; 当前目录）或 &lt;code&gt;cmake --build [目录]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以后改代码，只需重新 &lt;code&gt;make&lt;/code&gt; 就行。&lt;/p&gt;
&lt;p&gt;一般习惯把 build system 的部分放到子文件夹里。汇总：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir build 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; build
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake ..
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./对应名字
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://wshibin.github.io/misc/cmake/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://wshibin.github.io/misc/cmake/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cmake.org/cmake/help/latest/guide/tutorial/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://cmake.org/cmake/help/latest/guide/tutorial/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV14h41187FZ/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.bilibili.com/video/BV14h41187FZ/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;vcpkg&#34;&gt;vcpkg
&lt;/h3&gt;&lt;p&gt;vs 或 wsl，请。&lt;/p&gt;
&lt;h3 id=&#34;类&#34;&gt;类
&lt;/h3&gt;&lt;p&gt;基本结构、重载运算符、后置 &lt;code&gt;const&lt;/code&gt;、构造析构略。&lt;/p&gt;
&lt;h4 id=&#34;c-struct&#34;&gt;C struct
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里 &lt;code&gt;_&lt;/code&gt; 可省，直接写成匿名结构体。&lt;/p&gt;
&lt;h4 id=&#34;静态成员变量和函数&#34;&gt;静态成员变量和函数
&lt;/h4&gt;&lt;p&gt;顾名思义，加 &lt;code&gt;static&lt;/code&gt;，就是与类关联而不是与某个对象关联。注意 C++11 之前，类里是不能 &lt;code&gt;const&lt;/code&gt; 的，只能 &lt;code&gt;static const&lt;/code&gt;，或者 &lt;code&gt;enum&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;成员函数&#34;&gt;成员函数
&lt;/h4&gt;&lt;p&gt;成员函数如果传同类参，可以访问对方的 &lt;code&gt;private&lt;/code&gt; 成员。&lt;/p&gt;
&lt;p&gt;类内定义的成员函数是自动内联的。&lt;/p&gt;
&lt;p&gt;成员函数可以类外定义，必须再类内先声明，定义时要加 &lt;code&gt;::&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;众所周知，在成员函数头后加 &lt;code&gt;const&lt;/code&gt; 可以保证成员不被改变。但是它还能用于重载，拓宽了可使用情景：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cerr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;non-const&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cerr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;const&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码会输出 &lt;code&gt;non-const\nconst\n&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;友元&#34;&gt;友元
&lt;/h4&gt;&lt;p&gt;友元函数是一种非成员函数，其声明必须在类内，定义可以在类内或类外，但在类内时不能直接使用成员变量。其关键作用是能在类外访问私有成员。显然这种东西不可能是私有的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;friend&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ostream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ostream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;ostream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ostream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意声明时参列里 &lt;code&gt;&amp;amp;&lt;/code&gt; 不能少。&lt;/p&gt;
&lt;p&gt;友元类是在类定义中写 &lt;code&gt;friend class 另一个类的名字&lt;/code&gt;，然后另一个类就可以访问这个类的私有成员了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;friend&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;sa&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果只希望 &lt;code&gt;B&lt;/code&gt; 的某个函数可以访问 &lt;code&gt;A&lt;/code&gt; 的私有成员（以限制 &lt;code&gt;B&lt;/code&gt; 不在别的地方瞎搞），可以用友元成员函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 必须要有！
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;friend&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;sa&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们来仔细考虑一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 定义 → &lt;code&gt;B&lt;/code&gt; 定义：&lt;code&gt;A&lt;/code&gt; 里根本写不了 &lt;code&gt;B&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 定义 → &lt;code&gt;A&lt;/code&gt; 定义：&lt;code&gt;B&lt;/code&gt; 里根本写不了 &lt;code&gt;A&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 声明 → &lt;code&gt;B&lt;/code&gt; 定义 → &lt;code&gt;A&lt;/code&gt; 定义：&lt;code&gt;B&lt;/code&gt; 定义里要用 &lt;code&gt;A&lt;/code&gt; 的成员，但 &lt;code&gt;A&lt;/code&gt; 没定义。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; 声明 → &lt;code&gt;A&lt;/code&gt; 定义 → &lt;code&gt;B&lt;/code&gt; 定义：&lt;code&gt;A&lt;/code&gt; 要写 &lt;code&gt;friend void B :: ...&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt; 是得定义完的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以最后只能 &lt;code&gt;A&lt;/code&gt; → &lt;code&gt;B&lt;/code&gt; → &lt;code&gt;A&lt;/code&gt; → &lt;code&gt;B&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;唐。&lt;/p&gt;
&lt;h4 id=&#34;类继承&#34;&gt;类继承
&lt;/h4&gt;&lt;p&gt;思想：两个类有共同特征，不想重复写这部分。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class 派生类名 : [public|protected|private] 基类名 { 定义派生类独有的内容 } ;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果要继承多个，就用 &lt;code&gt;,&lt;/code&gt; 分隔。注意 &lt;code&gt;class C : public A, B&lt;/code&gt; 相当于 &lt;code&gt;class C : public A, private B&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;基类中 &lt;code&gt;private&lt;/code&gt; 的无法在派生类中访问，如果想访问但不希望被外面访问，就用 &lt;code&gt;protected&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;继承方式\基类内权限&lt;/th&gt;
&lt;th&gt;&lt;code&gt;public&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;protected&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;private&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;public&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;public&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;protected&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;inaccessible&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;protected&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;protected&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;protected&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;inaccessible&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;private&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;private&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;private&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;inaccessible&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;构造函数：推荐在派生类初始化列表中调用基类的构造函数，而不是直接赋值基类的元素。如果不写，则调用基类的默认构造函数。注意，唯一不行的是在初始化列表中初始化基类的元素，因为构造函数是先调用基类的构造函数，如果这样写就重复了。&lt;/p&gt;
&lt;p&gt;如果不写构造函数，也可以用初始化列表的方式（C++ 17），注意列表对应顺序是先基类后派生类。&lt;/p&gt;
&lt;p&gt;派生类无法使用基类的重载运算符和友元函数。&lt;/p&gt;
&lt;h4 id=&#34;多态&#34;&gt;多态
&lt;/h4&gt;&lt;p&gt;派生类可以重载基类的变量和函数，如果要使用基类中的，就用 &lt;code&gt;::&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;多态可以展开讲的最大的点就是虚方法。考虑：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Value = &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Sum = &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prod&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prod&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Product = &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prod&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// do something to b1, b2, c1, c2.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 指针和引用可以从派生类隐式转换到基类
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显然他会输出四行 &lt;code&gt;Value = ...&lt;/code&gt;，但是我们希望它能输出两行 &lt;code&gt;Sum&lt;/code&gt;，两行 &lt;code&gt;Product&lt;/code&gt;，又懒得一个个 &lt;code&gt;. print()&lt;/code&gt;。那怎么办呢？&lt;/p&gt;
&lt;p&gt;我们在基类的函数开头加一个 &lt;code&gt;virtual&lt;/code&gt;（必须），然后在派生类的函数大括号前加 &lt;code&gt;override&lt;/code&gt;（可选）。在多重继承时，会自动找到最深的重载。&lt;/p&gt;
&lt;p&gt;如果强制一个类的派生类不能重载，就加 &lt;code&gt;final&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;问题：如何使继承链中途不再虚？&lt;/p&gt;
&lt;p&gt;问题：如果真的基类对象调用纯虚函数会怎样？&lt;/p&gt;
&lt;p&gt;抽象基类是具有纯虚函数的类，纯虚函数是不给出定义的虚函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;virtual&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种情况下，不能建立该类的对象，且必须在（要有对象的）派生类中给出纯虚函数的定义。&lt;/p&gt;
&lt;p&gt;析构函数是一类在类继承中往往必须要是虚函数的函数。考虑以下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 析构函数必须是公有的或保护的，不然程序结束时都调用不了，直接 CE
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;程序结束时会调用 &lt;code&gt;b&lt;/code&gt; 的析构函数，先执行 &lt;code&gt;~B()&lt;/code&gt;，再执行 &lt;code&gt;~A()&lt;/code&gt;，输出 &lt;code&gt;ba&lt;/code&gt;。这没啥问题。（注意：动态分配内存的对象在程序结束时不会调用析构函数）&lt;/p&gt;
&lt;p&gt;但是如果 &lt;code&gt;main&lt;/code&gt; 里有这样的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那就会导致只有基类的析构函数被调用。这在派生类里没有单独的动态内存时是没问题的（有静态变量是没问题的，也会跟着删掉），但是如果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那就会造成内存泄露。所以如果存在基类指针指向派生类对象的情况，析构函数就必须要是虚的。&lt;/p&gt;
&lt;p&gt;虚函数的多态的原理，是动态联编，大概就是每个对象都记录了一个函数指针表，用于查找它应该调用哪一级的重载的函数。因为类指针指向的对象类型可能取决于输入之类的，所以不得不边运行边确定，导致很慢。&lt;/p&gt;
&lt;h4 id=&#34;虚继承&#34;&gt;虚继承
&lt;/h4&gt;&lt;p&gt;复杂的继承会出问题，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;D&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个 &lt;code&gt;D&lt;/code&gt; 对象，没法直接访问 &lt;code&gt;.a&lt;/code&gt;，必须指定是 &lt;code&gt;.B::a&lt;/code&gt; 还是 &lt;code&gt;.C::a&lt;/code&gt;，函数同理。&lt;/p&gt;
&lt;p&gt;如果希望合并两个 &lt;code&gt;a&lt;/code&gt;，需要把 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 的继承方式改成虚继承 &lt;code&gt;virtual public A&lt;/code&gt;，与此同时当 &lt;code&gt;D&lt;/code&gt; 的构造函数递归调用 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 的构造函数时，将会忽略对 &lt;code&gt;A&lt;/code&gt; 的构造函数的递归调用，需要单独调用 &lt;code&gt;A&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是重载的函数还是没法合并，所以最好 &lt;code&gt;D&lt;/code&gt; 自己写一个，当然可以直接调用 &lt;code&gt;B::&lt;/code&gt; 和 &lt;code&gt;C::&lt;/code&gt; 的，这个的重复就无法避免了。&lt;/p&gt;
&lt;h3 id=&#34;模板&#34;&gt;模板
&lt;/h3&gt;&lt;p&gt;最基础的略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;double res = max(2.5, 3);&lt;/code&gt; 不行，&lt;code&gt;double res = max &amp;lt;double&amp;gt; (2.5, 3);&lt;/code&gt; 可以。&lt;/p&gt;
&lt;p&gt;显式实例化：&lt;code&gt;template 返回类型 函数名 &amp;lt;具体化类型&amp;gt; (参数列表) ;&lt;/code&gt; 表示生成一个对应的实例。&lt;/p&gt;
&lt;p&gt;显式具体化：&lt;code&gt;template &amp;lt;&amp;gt; 返回类型 函数名 (&amp;lt;具体化类型&amp;gt;) (参数列表) { ... }&lt;/code&gt; 其中第二个 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 是可选的。和实例化不同的是，它相当于一种“内容不同的重载”，必须有函数定义，且出现在第一次调用之前（否则与隐式实例化冲突）。例如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;strcmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;模板类：开头加一样的东西就行。类外定义函数： &lt;code&gt;template &amp;lt;typename T&amp;gt; 返回类型 类名 &amp;lt;T&amp;gt; :: 函数头 { ... }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后我们考虑一个例子：希望写一个 &lt;code&gt;max&lt;/code&gt;，它能接受一个 &lt;code&gt;int&lt;/code&gt; 和一个 &lt;code&gt;double&lt;/code&gt;（之类的），并返回 &lt;code&gt;double&lt;/code&gt;（选择级别高的类型）。如果这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;3.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;3.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个就会有问题。可以用 &lt;code&gt;C++14&lt;/code&gt; 的特性，自动推导返回类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;stl-查漏补缺&#34;&gt;STL 查漏补缺
&lt;/h3&gt;&lt;p&gt;遍历一些 STL 对象时，建议用 &lt;code&gt;const_iterator&lt;/code&gt;，对应 &lt;code&gt;. cbegin()&lt;/code&gt; 和 &lt;code&gt;. cend()&lt;/code&gt;。作用是无法修改内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;++ it&lt;/code&gt; 比 &lt;code&gt;it ++&lt;/code&gt; 快，考虑 &lt;code&gt;it ++&lt;/code&gt; 具体该怎么实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;iterator&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;iterator&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tmp&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// do increment
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;STL 提供了一个一般的 &lt;code&gt;find&lt;/code&gt;，它是暴力，不要将它用于已经有自己的 &lt;code&gt;find&lt;/code&gt; 的类。&lt;/p&gt;
&lt;h3 id=&#34;移动语义和右值引用&#34;&gt;移动语义和右值引用
&lt;/h3&gt;&lt;p&gt;左值是有地址的，可以赋值的变量。&lt;/p&gt;
&lt;p&gt;右值的例子包括字面量、四则运算的结果、函数的非引用返回值等。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;能否引用&lt;/th&gt;
&lt;th&gt;非常量左值引用&lt;/th&gt;
&lt;th&gt;常量左值引用&lt;/th&gt;
&lt;th&gt;非常量右值引用&lt;/th&gt;
&lt;th&gt;常量右值引用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;非常量左值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;常量左值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;右值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;目前不知道常量右值是什么，也不知道常量右值引用有啥用。&lt;/p&gt;
&lt;p&gt;右值引用实际上是开了空间的。因此可以这样：&lt;code&gt;int &amp;amp;&amp;amp; p = 1; p = 2;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以用 &lt;code&gt;move&lt;/code&gt;（C++ 11）将左值转成右值。&lt;/p&gt;
&lt;p&gt;目前看起来右值引用没啥用。在复杂的类的应用中，考虑提高这段代码的效率：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;o&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意必须重载复制构造函数和赋值，否则会导致多对一。&lt;/p&gt;
&lt;p&gt;如果将一个对象复制给另一个对象，且这个对象不再使用（例如，这个对象是函数的返回值），那么暴力赋值就可以优化——我们希望直接把赋值者的内容转移给被赋值者，但是为了避免多对一析构爆炸，得把赋值者清空（&lt;code&gt;delete nullptr&lt;/code&gt; 不会发生任何事）。这就必须要求我们能修改等号右边的东西，这就是右值引用在移动语义中的作用。我们可以新增一个“移动构造函数”：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;移动赋值同理。如果要将 &lt;code&gt;a&lt;/code&gt; 赋值给 &lt;code&gt;b&lt;/code&gt; 且 &lt;code&gt;a&lt;/code&gt; 不再用了，写 &lt;code&gt;b = move(a)&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;智能指针&#34;&gt;智能指针
&lt;/h3&gt;&lt;p&gt;我们现在希望偷懒不写 &lt;code&gt;delete&lt;/code&gt;，于是类似上面，我们会写个指针类来自动 &lt;code&gt;delete&lt;/code&gt;，但是与上面不同的是，指针类并不负责申请内存，也不负责复制内容，只负责自动释放空间。这就导致如果两个指针指向同一片内存就会爆。&lt;/p&gt;
&lt;p&gt;头文件 &lt;code&gt;memory&lt;/code&gt;。C++98 有 &lt;code&gt;auto_ptr&lt;/code&gt;，略。C++11 有 &lt;code&gt;unique_ptr&lt;/code&gt; 和 &lt;code&gt;shared_ptr&lt;/code&gt;。&lt;code&gt;unique_ptr&lt;/code&gt; 禁止复制（构造和赋值），只能 &lt;code&gt;move&lt;/code&gt; 之后再赋；&lt;code&gt;shared_ptr&lt;/code&gt; 会维护一个计数器，等最后一个相关智能指针对象析构时才 &lt;code&gt;delete&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;用法 1：&lt;code&gt;unique/shared_ptr &amp;lt;int&amp;gt; p (new int [100]);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不推荐用法 2：&lt;code&gt;int * p = new int [100]; unique/shared_ptr &amp;lt;int&amp;gt; q (p);&lt;/code&gt; 会导致多对一。&lt;/p&gt;
&lt;p&gt;用法 3：&lt;code&gt;auto p (make_unique/shared &amp;lt;int&amp;gt; (100));&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;类型转换&#34;&gt;类型转换
&lt;/h3&gt;&lt;p&gt;C++ 的类型转换：&lt;code&gt;static_cast &amp;lt;转换成的类型&amp;gt; (原变量)&lt;/code&gt;。在编译时会检查转换是否合法。&lt;/p&gt;
&lt;p&gt;C 中，这样的代码是可以的（逆天）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;C++ 中，不能这样 &lt;code&gt;static_cast &amp;lt;int &amp;amp;&amp;gt;&lt;/code&gt; 但是可以 &lt;code&gt;const_cast &amp;lt;int &amp;amp;&amp;gt;&lt;/code&gt;。只有特殊情况需要修改时才用。&lt;/p&gt;
&lt;p&gt;C 中，这样的代码是可以的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;C++ 中，不能这样 &lt;code&gt;static_cast &amp;lt;node *&amp;gt;&lt;/code&gt; 但是可以 &lt;code&gt;reinterpret_cast &amp;lt;node *&amp;gt;&lt;/code&gt;。总的来说，感觉就是避免你无意识地瞎转类型，但是你硬要转也是可以的，效果和 C 的一样，就是“棒转”，不做任何事情。&lt;/p&gt;
&lt;p&gt;有且只有 &lt;code&gt;dynamic_cast&lt;/code&gt; 只能用于指针和引用。&lt;code&gt;dynamic_cast&lt;/code&gt; 可以把基类转换到派生类（&lt;code&gt;static_cast&lt;/code&gt; 也可以做）。如果被转换者类型不对（包括把本身就指向基类对象的指针转成派生类），会返回 &lt;code&gt;nullptr&lt;/code&gt;。&lt;code&gt;dynamic_cast&lt;/code&gt; 转换的必须是多态类型，即至少声明或继承（可以在本身 &lt;code&gt;override&lt;/code&gt;）了一个虚函数的类。&lt;/p&gt;
&lt;h3 id=&#34;异常&#34;&gt;异常
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;抛出异常 &lt;code&gt;throw 信息&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;try&lt;/code&gt; 开始代码块，里面可以用 &lt;code&gt;throw&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;捕获异常 &lt;code&gt;catch (信息类型 [变量名字]) { ... }&lt;/code&gt; 接在 &lt;code&gt;try&lt;/code&gt; 的代码块后，可以接多个处理方式。&lt;code&gt;catch (...)&lt;/code&gt; 通用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以跨函数处理（再抛出）。跨的函数有返回值的赋值也会跳过。&lt;/p&gt;
&lt;p&gt;为了区分不同（大类的）异常情况，可以建立各种异常类。值得注意的是，如果抛出的类型是派生类，而捕获的类型中既有基类又有派生类，且前者写在前面，那就会被前者捕获。&lt;/p&gt;
&lt;p&gt;STL 中的东西的异常都是 &lt;code&gt;std :: exception&lt;/code&gt; 的派生类，可以调用 &lt;code&gt;. what()&lt;/code&gt; 知道它是哪种。&lt;/p&gt;
&lt;h3 id=&#34;优化原理&#34;&gt;优化原理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;分支预测&lt;/li&gt;
&lt;li&gt;循环展开&lt;/li&gt;
&lt;li&gt;并行处理、SIMD&lt;/li&gt;
&lt;li&gt;循环顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;标准属性&#34;&gt;标准属性
&lt;/h3&gt;&lt;p&gt;发现有个 project 里有些 &lt;code&gt;[[...]]&lt;/code&gt; 这种东西，加在声明或定义的类型名前面。这是起到修改编译器对一些特殊情况的反应的。包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[[nodiscard]]&lt;/code&gt; 加在函数声明前，如果该函数的返回值未被使用会报警告，可以通过 &lt;code&gt;[[nodiscard(&amp;quot;...&amp;quot;)]]&lt;/code&gt; 加警告信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[deprecated]]&lt;/code&gt; 表示对应东西可能被弃用，不鼓励使用（使用会警告），同上。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[noreturn]]&lt;/code&gt; 表示对应函数不会正常返回（&lt;code&gt;exit&lt;/code&gt; 或 &lt;code&gt;throw&lt;/code&gt; 之类），提示编译器优化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[likely]]&lt;/code&gt; 和 &lt;code&gt;[[unlikely]]&lt;/code&gt; 加在分支语句后，表示更可能进入哪个分支，提示编译器优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;可变参数&#34;&gt;可变参数
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/694317432&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/694317432&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;例题&#34;&gt;例题
&lt;/h3&gt;&lt;p&gt;有个题感觉还是很 educational 的。如何实现一个高维数组，每维的长度都是 $n$，但维数 $d$ 不定？可以用模板类：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Array&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Array&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但这里的问题是 $d=0$ 的时候爆了。可以用部分具体化：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Array&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>算设 Survey：一些经典问题的 log 因子优化算法</title>
        <link>https://littlereuben.github.io/study/course-algo-survey/</link>
        <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
        
        <guid>https://littlereuben.github.io/study/course-algo-survey/</guid>
        <description>&lt;div style=&#34;background-color: #FFF9B9; color: #796E00; padding-left: 1em; border-left: 4px solid #DED041; line-height: 25pt;&#34;&gt;这是一篇&lt;b&gt;学习笔记&lt;/b&gt;。&lt;/div&gt;
&lt;embed src= &#34;main.pdf&#34; width= &#34;100%&#34; height= &#34;800px&#34; type=&#34;application/pdf&#34; &gt;
&lt;a href=&#34;main.pdf&#34; style=&#34;display:block;text-align:center;&#34;&gt;&lt;b&gt;[PDF file]&lt;/b&gt;&lt;/a&gt;
</description>
        </item>
        
    </channel>
</rss>
